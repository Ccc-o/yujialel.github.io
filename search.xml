<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构与算法-双向链表|双向循环链表</title>
    <url>/2020-07-01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95--%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%7C%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>在前面研究了<code>单链表</code> 和 <code>单向循环链表</code> 的结构设计以及对链表的一些修改和查找操作的设计, 接下来再对 <code>双向链表</code> 继续进行研究。从 前面了解到 <code>单向链表</code> 的结构中包含一个后继结点的 <strong>指针域</strong>, 那么 <code>双向链表</code> 又包含哪些呢?</p>
</blockquote>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>双向链表</code> (也叫 <code>双链表</code>)  不同于<code>单向链表</code> 的点在于, 他的每个数据结点包含两个<code>指针域</code>, 这两个指针分别指向该结点的 <code>直接前驱</code> 和 <code>直接后继</code>。所以, 从双向链表的任意结点开始, 都能够很方便的找到他的前驱结点和后继结点, 下面通过几张图来看一下他们的结构:</p>
<img src="/images/双链表-1.png" style="zoom:50%;">

<center>结点的结构</center>
<img src="/images/双链表-2.png" style="zoom:50%;">

<center>双向链表的结构图</center>
<img src="/images/双链表-3.png" style="zoom:50%;">

<center>双向循环链表结构图</center>
从上面的图可以总结如下几点:

<ol>
<li>双向链表的结点包含两个指针, <code>prior</code> 前驱指针, 指向当前结点的前一个结点; <code>next</code> 后继指针, 指向当前结点的后一个结点</li>
<li>在双向循环链表中, 尾结点的后继指向的是 <code>头结点</code> </li>
<li>双向链表为空时, 头结点指向的是 <code>NULL</code>; 而双向循环链表为空时, 头结点指向的是他本身, 所以此时的链表是一个只包含头结点的环状结构</li>
</ol>
<blockquote>
<p><em>注意: 为了方便处理, 在进行双向链表研究时, 我们这里默认是添加了头结点的。</em></p>
</blockquote>
<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>了解了双向链表的结构, 下面来对他的结构进行设计, 其实他的结构通单链表是差不多的, 只不过多了一个指向前驱的指针域, 结构设计如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int Status; &#x2F;* Status是函数的类型,其值是函数结果状态代码，如OK等 *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">typedef int ElemType; &#x2F;* ElemType类型根据实际情况而定，这里假设为int *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">struct DoubleNode &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ElemType data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    struct DoubleNode *next; &#x2F;&#x2F; 后继结点</span></pre></td></tr><tr><td class="code"><pre><span class="line">    struct DoubleNode *prior; &#x2F;&#x2F; 前驱结点</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;DoubleNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">typedef struct DoubleNode * DoubleLinkList;</span></pre></td></tr></table></figure>



<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li>创建头结点, 给头结点的两个指针域和数据域赋初值</li>
<li>添加测试数据, 这里采用的是 <code>尾插法</code> , 需要将 <code>尾结点</code> 的 <code>next</code> 指向新节点, 并将新节点的 <code>prior</code> 指向尾结点 </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建双向链表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">createDoubleLinkList</span> <span class="params">(DoubleLinkList *L)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 让 *L 指向头结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    *L = (DoubleLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DoubleNode));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 非空判断</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 头结点赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    (*L)-&gt;next = nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (*L)-&gt;prior = nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (*L)-&gt;data = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 添加数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleLinkList p = *L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 创建临时结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        DoubleLinkList temp = (DoubleLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DoubleNode));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp-&gt;prior = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp-&gt;next = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp-&gt;data = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 将创建的结点加入到链表中去</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;next = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp-&gt;prior = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 将 P 进行移位, 为了方便进行下次添加结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>遍历打印链表</p>
<ol>
<li>首先非空判断肯定需要有的</li>
<li>这里是通过 <code>while</code> 循环进行打印的, 首先定义一个 temp 临时结点, 然后通过逐步移位值打印, 当 temp 为 NULL 时结束打印</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历打印双向链表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">printDoubleLinkList</span><span class="params">(DoubleLinkList L)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"空指针\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleLinkList temp = L-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"链表不能为空!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"打印的链表为: "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (temp) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, temp-&gt;data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>关于 L 和 *L:</p>
<p>这里可以看到函数的参数传入的是 L , 而在之前的函数参数传入的是 *L , 那么在什么时候需要 L, 什么时候需要 *L?</p>
<p>这个问题涉及到了 C 语言 <code>值传递</code>、<code>指针传递</code> 和 <code>引用传递</code> 三种函数参数的传递方式, 具体内容可以去百度一下, 下面就放一张图表来简要说明一下吧:</p>
<table>
<thead>
<tr>
<th>传递方式</th>
<th>函数定义</th>
<th>函数调用</th>
<th><strong>函数内对a修改的影响</strong></th>
</tr>
</thead>
<tbody><tr>
<td>值传递</td>
<td>fun(int a)</td>
<td>fun(x)</td>
<td>外部 x 不变</td>
</tr>
<tr>
<td>指针传递</td>
<td>fun(int *a)</td>
<td>fun(&amp;x)</td>
<td>外部 x 同步更改</td>
</tr>
<tr>
<td>引用传递</td>
<td>fun(int &amp;a)</td>
<td>fun(x)</td>
<td>外部 x 同步更改</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><img src="/images/双链表-4.png" style="zoom:50%;">

<center>双向链表插入</center>
结点的插入需要考虑两种情况: 插入位置在链表边缘 和 插入位置在链表内部:

<p>插入链表边缘位置:</p>
<ol>
<li>插入位置 1, 因为我们引入了 <code>头结点</code> (位置0 就是我们的 <code>头结点</code>) , 所以这种情况下和插入链表内部的情况一样</li>
<li>插入位置在最后, 这种情况下就相当于前面初始化里面的尾插法, 不需要过多考虑, 直接插入即可</li>
</ol>
<p>插入位置在链表内部:</p>
<p>需要重点注意的是, 需要首先将 待插入的结点分别于两端的结点建立联系, 不然会导致链表损坏。比如上面的图, 如果我们首先指向步骤 1 和步骤 3, 那么此后 <code>A</code> 的 <code>next</code> 就变成了结点 <code>CC</code> , 就会导致 <code>B</code> 结点丢失。</p>
<p>代码实现如下:</p>
<blockquote>
<p>这里如果插入的位置超过链表的长度是默认插入到最后的, 如果不想插入到最后可以增加判断</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DoubleLinkListInsert</span><span class="params">(DoubleLinkList *L, <span class="keyword">int</span> i, ElemType a)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"插入位置不合法!!!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 新建结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleLinkList p = (DoubleLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DoubleNode));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;prior = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;data = a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 找到插入的位置的前一个结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleLinkList temp = *L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span> &amp;&amp; m &lt; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        m++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 插入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断插入位置是否为链表尾部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;prior = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp-&gt;next = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;prior = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;next = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp-&gt;next = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp-&gt;next-&gt;prior = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><img src="/images/双链表-5.png" style="zoom:50%;">

<center>双向链表删除</center>
1. 判断链表是否合法 和 删除位置是否合法
2. 寻找要删除的结点
3. 判断结点位置是 `尾结点` 或者 `非尾结点`。尾结点, 直接与前一个结点断开; 非尾结点将要删除结点的两端结点建立联系
4. 需要声明一个临时变量来接收待删除的结点, 因为删除之后需要做 `free()` 释放结点

<h4 id="1-根据传入的位置删除指定结点"><a href="#1-根据传入的位置删除指定结点" class="headerlink" title="1. 根据传入的位置删除指定结点"></a>1. 根据传入的位置删除指定结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DoubleLinkListDelete</span><span class="params">(DoubleLinkList *L, <span class="keyword">int</span> i, ElemType *a)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除位置不合法!!!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 找到删除的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleLinkList temp = (*L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"链表为空!!!!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (temp-&gt;next &amp;&amp; m &lt; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        m++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (m &lt; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除位置不合法!!!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 删除元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 定义一个临时变量接收要删的元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleLinkList node = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (node-&gt;next == <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node-&gt;prior-&gt;next = node-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node-&gt;prior = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node-&gt;prior-&gt;next = node-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node-&gt;next-&gt;prior = node-&gt;prior;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *a = node-&gt;data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">free</span>(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="2-根据传入的值删除指定结点"><a href="#2-根据传入的值删除指定结点" class="headerlink" title="2. 根据传入的值删除指定结点"></a>2. 根据传入的值删除指定结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除指定数据的元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DoubleLinkListDelete2</span><span class="params">(DoubleLinkList *L, <span class="keyword">int</span> data)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((*L)-&gt;next == <span class="literal">NULL</span> || *L == <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除链表不合法!!!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 找到要删除的结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleLinkList temp = (*L)-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (temp-&gt;data != data &amp;&amp; temp-&gt;next != <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (temp-&gt;data != data) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"要删除的结点不存在!!!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleLinkList p = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;prior-&gt;next = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;prior = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;prior-&gt;next = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;next-&gt;prior = p-&gt;prior;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">free</span>(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找指定元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DoubleLinkListSearch</span><span class="params">(DoubleLinkList L, <span class="keyword">int</span> data)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((L)-&gt;next == <span class="literal">NULL</span> || L == <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找的链表不合法!!!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 找到要删除的结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleLinkList temp = (L)-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (temp-&gt;data != data &amp;&amp; temp-&gt;next != <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (temp-&gt;data != data) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"所查找的结点不存在!!!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"所查找的元素位置在 %d\n"</span>, a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ol>
<li>找到要更新的结点</li>
<li>给要更新的结点重新赋值</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新双向链表中某个结点的数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DoubleLinkListUpdate</span><span class="params">(DoubleLinkList *L, <span class="keyword">int</span> index, ElemType data)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((*L)-&gt;next == <span class="literal">NULL</span> || *L == <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"链表不合法!!!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置不合法!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleLinkList temp = (*L)-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (temp-&gt;next &amp;&amp; m &lt; index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        m++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (m == index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp-&gt;data = data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"未找到需要更新的元素!\n\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><p>验证代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @autoreleasepool &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// insert code here...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        NSLog(@<span class="string">"Hello, World!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> a, data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DoubleLinkList <span class="built_in">list</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 空指针打印</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        printDoubleLinkList(<span class="built_in">list</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 创建链表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        createDoubleLinkList(&amp;<span class="built_in">list</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 循环打印链表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        printDoubleLinkList(<span class="built_in">list</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 插入数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入插入的位置和数据: "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DoubleLinkListInsert(&amp;<span class="built_in">list</span>, a, data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        printDoubleLinkList(<span class="built_in">list</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 删除元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入删除元素的位置: "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DoubleLinkListDelete(&amp;<span class="built_in">list</span>, a, &amp;data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除了数据 %d\n"</span>, data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        printDoubleLinkList(<span class="built_in">list</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 删除指定内容元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入删除元素的内容: "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DoubleLinkListDelete2(&amp;<span class="built_in">list</span>, data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        printDoubleLinkList(<span class="built_in">list</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 查找指定元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入查找元素的内容: "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DoubleLinkListSearch(<span class="built_in">list</span>, data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 更新指定元素的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入需要更新元素的位置和更新后的值: "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DoubleLinkListUpdate(&amp;<span class="built_in">list</span>, a, data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        printDoubleLinkList(<span class="built_in">list</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>打印结果:</p>
<img src="/images/双链表-6.png" style="zoom:50%;">



<h1 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h1><p>根据文章开头的两种结构图片可以看出来, 双向链表 与 双向循环链表 的主要区别在于后者的尾结点是跟头结点链接到一起的, 所以两者在结构设计上是完全一样的, 不同的地方在于对于尾结点的判断等, 下面直接开始部分算法的实现。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>在尾插法插入节点之后, 需要将尾结点指向头结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建双向循环链表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">createLinkList</span><span class="params">(DoubleRepeatLinkList *L)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 创建头结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    *L = (DoubleRepeatLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DoubleNode));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 赋初值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    (*L)-&gt;next = (*L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (*L)-&gt;prior = (*L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (*L)-&gt;data = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 添加子节点, 后插法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleRepeatLinkList p = (*L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DoubleRepeatLinkList temp = (DoubleRepeatLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DoubleNode));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp-&gt;data = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;next-&gt;prior = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;next = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp-&gt;prior = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp-&gt;next = (*L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="打印-1"><a href="#打印-1" class="headerlink" title="打印"></a>打印</h3><p>区别于双向链表的 <code>NULL</code> 判断, 这里对于结尾的判断变成了 <code>p-&gt;next == L</code> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印双向循环链表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">printDoubleRepeatLinkList</span><span class="params">(DoubleRepeatLinkList L)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"打印的链表不合法\n\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleRepeatLinkList p = L-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (p == L) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"打印的链表为空表\n\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"双向循环链表打印结果为: "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (p != L) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><ol>
<li>遍历链表时的尾结点判断变了</li>
<li>在插入操作的时候不再需要进行 <code>尾结点</code> 判断处理了</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkListInsert</span><span class="params">(DoubleRepeatLinkList *L, <span class="keyword">int</span> i, ElemType data)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 找到要插入位置的前一个元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleRepeatLinkList p = (*L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (p-&gt;next != (*L) &amp;&amp; m &lt; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        m++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleRepeatLinkList temp = (DoubleRepeatLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DoubleNode));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp-&gt;data = data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp-&gt;prior = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;next-&gt;prior = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp-&gt;next = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;next = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp-&gt;prior = p;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>变化的地方同插入操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据下标删除元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkListDeleteNode</span><span class="params">(DoubleRepeatLinkList *L, <span class="keyword">int</span> index, ElemType *data)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"链表不合法\n\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((*L)-&gt;next == *L) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"链表为空表\n\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"下标不合法\n\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 根据下标找到要删除的元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleRepeatLinkList p = (*L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (a &lt; index &amp;&amp; p-&gt;next != (*L)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (p-&gt;next == (*L) &amp;&amp; a &lt; index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"未找到要删除的结点\n\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 删除找到的元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    DoubleRepeatLinkList temp = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data = &amp;(temp-&gt;data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp-&gt;prior-&gt;next = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp-&gt;next-&gt;prior = temp-&gt;prior;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">free</span>(temp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>验证代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @autoreleasepool &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// insert code here...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        NSLog(@<span class="string">"Hello, World!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> i, data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        DoubleRepeatLinkList <span class="built_in">list</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        createLinkList(&amp;<span class="built_in">list</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        printDoubleRepeatLinkList(<span class="built_in">list</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"插入元素\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入插入元素的位置和值: "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;i, &amp;data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LinkListInsert(&amp;<span class="built_in">list</span>, i, data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        printDoubleRepeatLinkList(<span class="built_in">list</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除元素\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入要删除元素的位置: "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LinkListDeleteNode(&amp;<span class="built_in">list</span>, i, &amp;data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        printDoubleRepeatLinkList(<span class="built_in">list</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>打印结果:</p>
<img src="/images/双链表-7.png" style="zoom:50%;">



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次主要内容为对 <code>双向链表</code> 和 <code>双向循环链表</code> 的相关算法设计, 以及两者在结构和算法上需要注意的一些区别。关于双向链表的内容就这些了, 如果有不对的地方还请指正, 感谢 !!!</p>
<p>和谐学习, 不急不躁~</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法-单向链表与单向循环链表(一)</title>
    <url>/2020-04-11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8(%E4%B8%80)/</url>
    <content><![CDATA[<blockquote>
<p>前面研究了顺序表示下的线性表, 接下来一起来看一下链式存储结构下的线性表–<strong>链表</strong></p>
</blockquote>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是线性表的一种链式存储结构, 与顺序存储不同, 链表是 <strong>用一组任意的存储单元进行数据元素的存储</strong>, 这些存储单元可以是连续的, 也可以是不连续的。为了表示每个数据元素与其直接后继数据元素的逻辑关系, 链表除了存储本身的信息之外, 还需要存储其直接后继的存储位置信息。这两部分信息组成一个 “结点”。</p>
<img src="/images/单向链表-1.png" style="zoom:50%;">

<center>结点</center>
如上图, 存储数据的部分叫做 **数据域** , 存储下一个结点地址的部分称为 **指针域** , 这一系列的结点通过 **指针域** 所存储的地址信息进行逻辑关系相连, 这就组成了我们今天要研究的 **链表** 。关于链表将其分为 **单向链表** 和 **双向链表** 两部分来研究, 下面先来看一下 **单向链表**。

<h1 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><img src="/images/单向链表-2.png" style="zoom:50%;">

<p>根据上面的单向链表的结构图可以总结出以下特点:</p>
<ol>
<li>方向是单向的, 对链表的访问需要从头部开始按顺序读取</li>
<li>物理结构不相邻, 需要借助 指针域的信息才能访问 后继结点</li>
<li>因为是单向的, 只能访问后继结点, 不能反向访问</li>
<li>在进行 插入/删除 操作时, 需要修改涉及到的结点的前驱和后继</li>
<li>每次插入操作时动态申请内存, 不需要考虑存储上限</li>
<li>删除操作时需要释放结点内存, 防止内存泄漏</li>
</ol>
<blockquote>
<p>关于头结点</p>
<p>头结点是我们在链表的第一个元素结点(首元结点) 之前设置的一个结点, 他的 数据域可以不存储任何信息, 指针域指向链表的首元结点。添加头结点的目的是为了减少在对链表进行 <strong>添加/删除</strong> 时遇到的特殊情况的处理, 降低程序的复杂性。(有了头结点以后, 在 删除/添加 时就不用再去考虑首元结点与首指针之间的关系了)</p>
<p><strong>注意: 添加了头结点的链表在进行销毁时需要对头结点进行销毁操作。</strong></p>
</blockquote>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h3><p>单向链表的结构与顺序表的区别在于, 除去 <strong>数据域</strong> 之外单向链表还需要引入 <strong>指针域</strong> , 所以其结构设计如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ElementType data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;Node;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span></span></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initLinkList</span><span class="params">(LinkList *L)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 头结点分配空间, 并让首指针指向头结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 存储空间分配失败, 抛出异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 头结点的指针域置空</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入需要考虑两种情况, 一种是需要插入特定位置时, 另一种是不需要插入特定位置, 那么就需要制定一个插入规则, 常用的规则主要有 前插法 和 后插法。</p>
<h4 id="插入特定位置"><a href="#插入特定位置" class="headerlink" title="插入特定位置"></a>插入特定位置</h4><img src="/images/单向链表-3.png" style="zoom:50%;">

<p>算法步骤:</p>
<ol>
<li>遍历链表, 找到所要插入位置的前一个位置的结点, 定义一个局部变量接收一下</li>
<li>判断找到的结点存不存在</li>
<li>创建新节点, 并将需要插入的值赋值给新节点的数据域</li>
<li>将找到的结点的后继赋值给新节点的后继</li>
<li>将新节点赋值给找到的结点的后继</li>
</ol>
<p><strong>注意: 这里的顺序是不能改变的, 为了防止链表断裂, 新的结点C必须先于结点A的后继结点B建立联系, 因为A结点是我们已经找到的, 所以之后再将A与C建立联系。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertLinkList</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, ElementType e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList temp, addNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp = *L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 遍历寻找 i 的上一个结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (temp &amp;&amp; j &lt; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        j++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断结点是否存在</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!temp || j &gt; i) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 创建用来插入的新结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    addNode = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 把想要插入的值给新的结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    addNode-&gt;data = e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 新的结点的后继指向 temp 的后继</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    addNode-&gt;next = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// temp 的后继指向新节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp-&gt;next = addNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="插入非特定位置"><a href="#插入非特定位置" class="headerlink" title="插入非特定位置"></a>插入非特定位置</h4><ul>
<li><strong>前插法</strong></li>
</ul>
<img src="/images/单向链表-4.png" style="zoom:50%;">

<p>如上图, 前插法就像其名字一样, 每次在首元结点之前做插入, 这样只需要拿到头结点, 然后在头结点的后面做插入就可以了</p>
<p>算法如下:</p>
<ol>
<li>生成新的结点, 将需要插入的值赋给 data</li>
<li>将新节点的 next 指向头结点的 next</li>
<li>将头结点的 next 指向新的结点</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">headInsertLinkList</span><span class="params">(LinkList *L, ElementType e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 创建新的结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;data = e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 结点p 指向 头结点的后继 (也就是首元结点)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;next = (*L)-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 头结点 指向 结点p (取代之前的首元结点)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    (*L)-&gt;next = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<ul>
<li><strong>后插法</strong></li>
</ul>
<img src="/images/单向链表-5.png" style="zoom:50%;">

<p>后插法就是在链表的尾部做插入操作, 这种操作就需要找到链表的尾结点, 然后再把新的结点放到尾结点的后面就可以了</p>
<p>算法如下:</p>
<ol>
<li>创建新的结点, 将新节点的 <code>next</code> 指向 <code>NULL</code> , 因为尾结点是没有后继的</li>
<li>通过一个 <code>while</code> 循环找到尾结点</li>
<li>将尾结点的 <code>next</code> 指向 新的结点</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tailInsertLinkList</span><span class="params">(LinkList *L, ElementType e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 创建新的结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;data = e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 建立一个尾结点 tailNode, 通过while循环遍历到尾部找到尾结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList tailNode = (*L)-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (tailNode-&gt;next) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tailNode = tailNode-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将新的结点放到尾结点之后</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    tailNode-&gt;next = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><p>由于链表在内存中不是连续的, 所以不能通过下标直接获取结点, 需要通过当前结点的指针域找到下一个结点。这里在取值时我们顶一个一个临时结点, 用来保存每一步循环之后的结点信息, 然后循环到想要取值的位置时, 直接读取这个临时结点的值就可以了。</p>
<p>代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElem</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, ElementType *e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 创建临时结点 p</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 让 p 指向首元结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p = (*L)-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 循环到要取结点的位置 i</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断如果 p 不存在直接返回error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果 j &gt; i, 说明 传入的 i是小于1的值, 不合法直接返回error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!p || j &gt; i) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 赋值操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    *e = p-&gt;data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 打印</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printLinkList</span><span class="params">(LinkList L)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p = L-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, p-&gt;data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><img src="/images/单向链表-6.png" style="zoom:50%;">

<p>删除结点如上图, 我们要把 A, B, C 三个结点的 B 结点移除出去, 首先需要找到 A 结点, 也就是 B 的前驱, 然后定义一个 临时结点来指向 B (<strong>注意在将B移除以后还需要对这块内存进行释放</strong> ), 然后就是将 A 的后继指向 临时结点的后继就可以了, 最后就是需要把 B 的空间进行释放。</p>
<p>算法实现:</p>
<ol>
<li>判断传入的删除位置是否合法</li>
<li>定义一个临时结点p, 用来保存当前遍历到的结点, 然后进行循环遍历, 找到要删结点的前驱结点</li>
<li>遍历结束以后需要看一下结点 p 的后继是否存在, 因为我们要删除的就是 p 的后继</li>
<li>定义 temp 结点指向要删除的结点 (也就是 p-&gt;next), 让 p 结点的后继指向 要删结点的后继, 这样 需要删除的结点就被分离出去了</li>
<li>最后需要把 temp 结点释放掉</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletElem</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, ElementType *e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 删除位置必须从1开始</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 定义两个临时结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList p, temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p = *L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 找到要删结点 i 位置的前驱, (注意这里是 j &lt; i)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i &amp;&amp; p-&gt;next; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断 p 结点的后继结点(也就是要删除的结点) 存不存在, 不存在的话就没有删除的必要了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!p-&gt;next) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 用我们的临时结点 temp 去接收 要删的结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将要删结点的前驱 p 的后继指向 要删结点的后继</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;next = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    *e = temp-&gt;data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 释放内存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">free</span>(temp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// insert code here...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 创建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    initLinkList(&amp;p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 插入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    insertLinkList(&amp;p, <span class="number">1</span>, <span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    insertLinkList(&amp;p, <span class="number">0</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    insertLinkList(&amp;p, <span class="number">1</span>, <span class="number">30</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    insertLinkList(&amp;p, <span class="number">44</span>, <span class="number">25</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"前插法\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 前插法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    headInsertLinkList(&amp;p, <span class="number">99</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    headInsertLinkList(&amp;p, <span class="number">22</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"后插法\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 后插法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    tailInsertLinkList(&amp;p, <span class="number">88</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tailInsertLinkList(&amp;p, <span class="number">55</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"取值\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 取值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ElementType a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    getElem(&amp;p, <span class="number">2</span>, &amp;a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ElementType b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    getElem(&amp;p, <span class="number">99</span>, &amp;b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"b = %d\n"</span>, b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 删除</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ElementType c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    deletElem(&amp;p, <span class="number">99</span>, &amp;c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"c = %d\n"</span>, c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ElementType d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    deletElem(&amp;p, <span class="number">4</span>, &amp;d);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"d = %d\n"</span>, d);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 输出结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">初始化</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">插入</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">10</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">30</span>	<span class="number">10</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line">前插法</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">22</span>	<span class="number">99</span>	<span class="number">30</span>	<span class="number">10</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line">后插法</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">22</span>	<span class="number">99</span>	<span class="number">30</span>	<span class="number">10</span>	<span class="number">88</span>	<span class="number">55</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line">取值</span></pre></td></tr><tr><td class="code"><pre><span class="line">a = <span class="number">99</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">b = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">删除</span></pre></td></tr><tr><td class="code"><pre><span class="line">c = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">d = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">22</span>	<span class="number">99</span>	<span class="number">30</span>	<span class="number">88</span>	<span class="number">55</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 安装与环境搭建</title>
    <url>/2020-05-26-Flutter%20%E5%AE%89%E8%A3%85%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="一-Flutter-安装"><a href="#一-Flutter-安装" class="headerlink" title="一. Flutter 安装"></a>一. Flutter 安装</h1><h2 id="1-下载-Flutter-SDK"><a href="#1-下载-Flutter-SDK" class="headerlink" title="1. 下载 Flutter SDK"></a><strong>1. 下载 Flutter SDK</strong></h2><p>① 可以选择去 <a href="https://flutter.dev" target="_blank" rel="noopener">官网</a> 下载</p>
<img src="/images/Flutter安装-1.png" style="zoom:50%;">

<img src="/images/Flutter安装-2.png" style="zoom:50%;">

<p>进入官网, 右上角选择 “Get started”, 然后在后面的页面选择自己需要的版本, 我这里使用的 “macOS”, 包括后面的问题也都是针对 Mac 系统的。这种方式存在一个问题, 就是国内网络可能会比较慢, 下面通过另外一种方式去获取 SDK。</p>
<p>② 网上去找国内的一些镜像文件下载</p>
<p>关于镜像有很多地方去找, 我这里选择的是 <a href="https://mirror.tuna.tsinghua.edu.cn" target="_blank" rel="noopener">清华大学开源软件镜像</a> 去下载的, 打开镜像地址, 然后直接搜索 “flutter” 就可以看到要找的镜像了</p>
<img src="/images/Flutter安装-3.png" style="zoom:50%;">

<p>这里的第一个就是我们需要的镜像, 然后点击后面的问号可以查看镜像获取方法, 如下图</p>
<img src="/images/Flutter安装-4.png" style="zoom:50%;">

<p>具体的步骤非常详细, 这里不做赘述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以看到上面的命令是将镜像配置到 .bashrc 里面的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 在配置完成以后最后执行以下下面这行代码将 .bashrc 重新加载以下</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ source ~/.bashrc</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 然后在到自己想要的目录下面进行 clone 就可以了</span></span></pre></td></tr></table></figure>



<h2 id="2-配置-Flutter-环境变量"><a href="#2-配置-Flutter-环境变量" class="headerlink" title="2. 配置 Flutter 环境变量"></a><strong>2. 配置 Flutter 环境变量</strong></h2><blockquote>
<p>因为Flutter 在运行的时候, 有时候需要去官方下载所需要的资源. 所以如果没有配置镜像的话, 会非常的慢. 这里如果在第一步进行过镜像设置的话也可以使用第一步设置的镜像。</p>
</blockquote>
<p>这里我选择对 <code>Shell</code> 的配置文件进行配置</p>
<p>如果系统默认的是 <code>bash</code>(老版系统) 就选择在 <code>.bash_profile</code> 文件进行配置</p>
<p>如果系统默认的是 <code>zsh</code>, 就选择在 <code>.zshrc</code> 文件进行配置</p>
<p>① 配置 Flutter 镜像</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#Flutter 镜像配置</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ <span class="keyword">export</span> PUB_HOSTED_URL=https:<span class="comment">//pub.flutter-io.cn</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ <span class="keyword">export</span> FLUTTER_STORAGE_BASE_URL=https:<span class="comment">//storage.flutter-io.cn</span></span></pre></td></tr></table></figure>

<p>镜像源也可以使用上面第一步的</p>
<p>② 配置 Flutter 环境变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#Flutter 配置</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ <span class="keyword">export</span> FLUTTER=~/flutter/bin 		<span class="comment">// Flutter路径,我的是在 home 下面的, 需要根据自己放的位置配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ <span class="keyword">export</span> PATH=$FLUTTER:$PATH</span></pre></td></tr></table></figure>

<p>③ 重新载入配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#你自己的配置文件路径</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ source ~/.zshrc		<span class="comment">// 需要改成你自己的文件路径</span></span></pre></td></tr></table></figure>

<p>④ 检查 Flutter 配置结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ flutter doctor</span></pre></td></tr></table></figure>

<img src="/images/Flutter安装-5.png" style="zoom:50%;">

<p>这里如果没有安装 <strong>Android Studio</strong> 的话, 第2个和第4个应该是 ❌ 的, 接下来进行安装 <strong>Android Studio</strong>。</p>
<blockquote>
<p>ps: 这里你可能会发现, 你的系统默认的是 <code>zsh</code>, 但是你找不到 <code>.zshrc</code> 文件</p>
<p>解决办法 :</p>
<ol>
<li>使用 <code>touch ~/.zshrc</code> 命令创建一个 <code>.zshrc</code> 文件, (在执行 source 时可能会出现没有执行权限的问题, 此时需要执行 <code>chmod 755 ~/.zshrc</code> 重新分配权限, 具体的指令操作可以查看 <code>Linux</code> 相关指令)</li>
<li>安装后面将要说到的 <code>iTerm2</code> 工具, 然后安装 <code>oh my zsh</code> , 他会帮我们生成 <code>.zshrc</code> 文件, 然后按上述步骤进行配置就可以了 (关于 iTerm2 工具可以去搜一下, 安装步骤也很简单, 如果安装过程中有问题可以在评论区进行回复。)</li>
</ol>
</blockquote>
<h1 id="二-安装-Android-Studio"><a href="#二-安装-Android-Studio" class="headerlink" title="二. 安装 Android Studio"></a>二. 安装 Android Studio</h1><p>首先, Android Studio 的下载可以直接去 <a href="https://developer.android.google.cn/studio" target="_blank" rel="noopener">国内官网</a> 下载, 安装步骤此处省略, 进入后面的配置环境。</p>
<h2 id="1-配置-Android-SDK"><a href="#1-配置-Android-SDK" class="headerlink" title="1. 配置 Android SDK"></a>1. 配置 Android SDK</h2><img src="/images/Flutter安装-6.png" style="zoom:50%;">

<p>在安装好之后首次打开, 一般会提醒我们去下载 SDK, 直接按默认的去下载就可以了。 全程无需翻墙, 稍微等一会就可以了。</p>
<h2 id="2-安装-Android-Studio-插件"><a href="#2-安装-Android-Studio-插件" class="headerlink" title="2. 安装 Android Studio 插件"></a>2. 安装 Android Studio 插件</h2><ol>
<li><p>在配置界面找到 <code>Plugins</code> 插件, 搜索 <code>Flutter</code> 进行安装</p>
</li>
<li><p>有可能会提示需要首先安装 <code>Dart</code> 才能安装 <code>Flutter</code>, 那么就先去安装 <code>Dart</code> 插件</p>
</li>
<li><p>安装好后, 重启 <code>Android Studio</code></p>
</li>
</ol>
<img src="/images/Flutter安装-7.png" style="zoom:50%;">

<p>界面如果出现这个东西, 证明安装成功。</p>
<h2 id="3-许可证问题"><a href="#3-许可证问题" class="headerlink" title="3. 许可证问题"></a>3. 许可证问题</h2><p>回过头去再次执行 <code>flutter doctor</code>, 有可能会报错</p>
<img src="/images/Flutter安装-8.png" style="zoom:50%;">

<p>(偷的图)</p>
<p>执行下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ flutter doctor --android-licenses</span></pre></td></tr></table></figure>

<p>再次检查一下, 应该已经解决了</p>
<h2 id="4-关于-android-模拟器配置"><a href="#4-关于-android-模拟器配置" class="headerlink" title="4. 关于 android 模拟器配置"></a>4. 关于 android 模拟器配置</h2><p>关于安卓模拟器的配置, 因为我选择用苹果的模拟器, 所以这里我不管了😝, 有兴趣的去问一下做安卓的同学吧。 </p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法-单向链表与单向循环链表(二)</title>
    <url>/2020-04-11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h1><img src="/images/单向链表-7.png" style="zoom:50%;">

<p>如上图, 单向循环链表与单向链表的不同点在于, <strong>单向循环链表的最后一个节点的指针指向链表头部, 而不是指向NULL</strong>, 即单向循环链表的尾结点是指向头结点的 (空表的时候就是头结点指向本身) 。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p><em>注: 因为大部分的算法步骤跟单向链表是相似的, 所以这里不再描述具体步骤, 只在需要注意的地方添加说明。</em></p>
<h3 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ElementType data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;Node;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span></span></pre></td></tr></table></figure>

<p><em>只是尾结点的指向不同, 所以在结构设计上单向链表和单向循环链表是一致的。</em></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initLinkList</span><span class="params">(LinkList *L)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 创建头结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断是否创建成功</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 给数据域随便赋值, 将头结点的 next 指向本身</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    (*L)-&gt;data = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (*L)-&gt;next = (*L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><em>初始化时跟单向链表的不同点在于, 在最后需要将头结点的 next 指向其自己</em></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="插入特定位置"><a href="#插入特定位置" class="headerlink" title="插入特定位置"></a>插入特定位置</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertLinkList</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, ElementType e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 创建遍历记录结点和待插入的新节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList p, temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp = (*L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 创建结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;data = e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 通过 while 循环找到待插入位置的上一个结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// (temp-&gt;next != (*L) 用来判断 temp 是否是尾结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; (temp-&gt;next != (*L))) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 对 i 的合理性判断, 如果 j &gt; i, i应该是 &lt;1 的值, 不满足</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果 i &gt; j+1, 说明 i-1 &gt; j, 即 j 不是 i 的前一个结点 (当 i 的值超出链表的长度 +1 时出现)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (j &gt; i || (i &gt; j+<span class="number">1</span>)) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 插入操作, 将新节点的 next 指向 temp 的next</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将 temp 的 next 指向 新节点p</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;next = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp-&gt;next = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><em>插入时需要注意的点在于 *</em>循环的判断条件<strong>, 因为循环链表是收尾相连的, 所以判断条件应该是 <em>*当前结点的 next 指向头结点</em></strong></p>
<h4 id="插入非特定位置"><a href="#插入非特定位置" class="headerlink" title="插入非特定位置"></a>插入非特定位置</h4><ul>
<li><strong>前插法</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前插法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">headInsertLinkList</span><span class="params">(LinkList *L, ElementType e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 创建结点 | 判断是否创建成功</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;data = e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 新节点的 next 指向 头结点的后继(非空表时是首元结点, 空表时是头结点)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;next = (*L)-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 头结点的 next 指向 新节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    (*L)-&gt;next = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li><strong>后插法</strong><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后插法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tailInsertLinkList</span><span class="params">(LinkList *L, ElementType e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList p, temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 创建结点 | 判断是否创建成功</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;data = e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 循环找到尾结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp = *L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">while</span> (temp-&gt;next != *L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 插入操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;next = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp-&gt;next = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletElem</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, ElementType *e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 空表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((*L)-&gt;next == (*L)) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList p, temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p = (*L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 循环找到要删除结点的上一个结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; (p-&gt;next != *L)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        j++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// j != i, 循环提前因为 p-&gt;next == *L 跳出, 给的 i 值超过链表长度; 或者 i 值 小于1 造成</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// p-&gt;next == *L, 要删除结点的位置刚好在 尾结点的后面时产生, 如果不加这个判断就会把头结点干掉了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (j != i || (p-&gt;next == *L)) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 用定义的 temp接管要删除的结点, 然后将其从链表中断开</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;next = temp-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将删除加点的内容给e, 然后释放掉</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    *e = temp-&gt;data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">free</span>(temp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><em>删除时基本与单链表类似, 不同点在于对于要删除位置的判断, 然后在删除过后对结点进行释放。</em></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElem</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, ElementType *e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p = (*L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 循环找到查找的结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (j &lt;= i &amp;&amp; (p-&gt;next != *L)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        j++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 对 i 值的合理性判断</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (j<span class="number">-1</span> != i) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    *e = p-&gt;data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 打印</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printLinkList</span><span class="params">(LinkList L)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p = L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, p-&gt;data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">while</span> (p-&gt;next != L);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// insert code here...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化---------------\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinkList L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    initLinkList(&amp;L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入---------------\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    insertLinkList(&amp;L, <span class="number">1</span>, <span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    insertLinkList(&amp;L, <span class="number">2</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    insertLinkList(&amp;L, <span class="number">1</span>, <span class="number">30</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    insertLinkList(&amp;L, <span class="number">4</span>, <span class="number">40</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"头插法---------------\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    headInsertLinkList(&amp;L, <span class="number">12</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    headInsertLinkList(&amp;L, <span class="number">13</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"尾插法---------------\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tailInsertLinkList(&amp;L, <span class="number">22</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tailInsertLinkList(&amp;L, <span class="number">23</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除---------------\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ElementType a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    deletElem(&amp;L, <span class="number">1</span>, &amp;a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除了 %d\n"</span>, a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ElementType b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    deletElem(&amp;L, <span class="number">5</span>, &amp;b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printLinkList(L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除了 %d\n"</span>, b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"查找---------------\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ElementType c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    getElem(&amp;L, <span class="number">1</span>, &amp;c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"找到了 %d\n"</span>, c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ElementType d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    getElem(&amp;L, <span class="number">4</span>, &amp;d);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"找到了 %d\n"</span>, d);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 打印结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Hello, World!</span></pre></td></tr><tr><td class="code"><pre><span class="line">初始化---------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">插入---------------</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">10</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">10</span>	<span class="number">20</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">30</span>	<span class="number">10</span>	<span class="number">20</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">30</span>	<span class="number">10</span>	<span class="number">20</span>	<span class="number">40</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line">头插法---------------</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">12</span>	<span class="number">30</span>	<span class="number">10</span>	<span class="number">20</span>	<span class="number">40</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">13</span>	<span class="number">12</span>	<span class="number">30</span>	<span class="number">10</span>	<span class="number">20</span>	<span class="number">40</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line">尾插法---------------</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">13</span>	<span class="number">12</span>	<span class="number">30</span>	<span class="number">10</span>	<span class="number">20</span>	<span class="number">40</span>	<span class="number">22</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">13</span>	<span class="number">12</span>	<span class="number">30</span>	<span class="number">10</span>	<span class="number">20</span>	<span class="number">40</span>	<span class="number">22</span>	<span class="number">23</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line">删除---------------</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">12</span>	<span class="number">30</span>	<span class="number">10</span>	<span class="number">20</span>	<span class="number">40</span>	<span class="number">22</span>	<span class="number">23</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line">删除了 <span class="number">13</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">12</span>	<span class="number">30</span>	<span class="number">10</span>	<span class="number">20</span>	<span class="number">22</span>	<span class="number">23</span>	</span></pre></td></tr><tr><td class="code"><pre><span class="line">删除了 <span class="number">40</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">查找---------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">找到了 <span class="number">12</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">找到了 <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次内容主要涉及了 <strong>链表</strong> 的相关概念, 以及 <code>单向链表</code> 和 <code>单向循环链表</code> 的结构和基本操作的算法设计。如果有不足的地方或者不正确的地方可以在回复中留言, 本人看到以后一定积极改正。</p>
<p>和谐学习, 不急不躁~</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法--顺序表</title>
    <url>/2020-04-04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95--%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>前面一篇文章主要介绍了数据结构和算法的一些基本概念, 从这篇文章开始进行对数据结构的展开分析。从前面我们了解到数据结构主要研究的是数据的 <code>逻辑结构</code> 和 <code>物理结构</code> 以及他们之间的关系,  接下来我们就展开来研究一下不同的结构和关系下产生的各种数据结构。</p>
</blockquote>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>线性表是最基本、最简单、也是最常用的一种数据结构, 一个线性表是 n 个具有相同特性的数据元素的有限序列。</p>
<blockquote>
<p> 举个例子来说明一下:</p>
</blockquote>
<p>假如我们这里有一张学生表, 表里面存储的每一个学生都是一个数据元素, 每一个数据元素都包含诸如 姓名、年龄、性别等数据项。</p>
<p>这张表里的各个学生就是不同的数据元素, 但是组成学生的各个数据项是相同的(也就是学生具有相同的特性), 像这样由 n(n &gt;= 0) 个特性相同的数据元素组成的有限序列就叫做 <strong>线性表</strong>。</p>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>说到 <code>线性</code> , 首先肯定可以想到 <strong>逻辑结构</strong> 中的 <code>线性结构</code> , 这里我们说的 <code>线性</code> 和 <code>非线性</code> 都是在 <strong>逻辑层次</strong> 上的讨论, 而没有去考虑 <strong>存储结构</strong> 。所以后面将要说的 <code>链表</code> 也属于 <strong>线性表</strong> 。</p>
<p>如果在逻辑结构上细分的话, 线性表又可以分为 <code>一般线性表</code> 和 <code>受限线性表</code> 。一般线性表也就是我们通常说的线性表, 他可以自由的 删除或者添加结点。至于受限线性表主要包括 <code>栈</code> 和 <code>队列</code> , 所谓受限就是对结点的操作受限制 ( <code>栈</code> 为 “先进后出”, <code>队列</code> 为 “先进先出”) 。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>根据存储结构的不同, 线性表主要有 <code>顺序表示</code> 和 <code>链式表示</code> 两种, 在实际使用中, 常以 栈、队列、字符串等形式使用。</p>
<p><code>顺序表示</code> 是指用一组地址连续的存储单元依次存储数据元素 (称为线性表的 <code>顺序存储结构</code>)。通过 “物理位置相邻” 来表示线性表中数据元素之间的逻辑关系, 可以随机存取表中的任一元素。</p>
<p><code>链式表示</code> 是指用一组任意的存储单元存储数据元素 (称为线性表的 <code>链式存储结构</code>)。他们可以是连续的, 也可以是不连续的, 在表示数据元素之间的逻辑关系时, 除了存储自身的信息之外, 还需要存储其直接后继的信息, 这两部分信息组成了数据元素的存储映像, 称为结点(node) 。他包括两个部分, 存储数据的部分为 <code>数据域</code>, 存储直接后继位置的部分为 <code>指针域</code> 。指针域存储的信息称为 <code>指针或链</code>。</p>
<p><strong>注: 本篇我们主要研究 顺序表示 存储结构下的线性表。</strong></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>回到线性表, 线性表中元素的个数 <code>n</code> 定义为线性表的 <strong>长度</strong> , 如果 <code>n = 0</code> 的话, 我们称为 <strong>空表</strong> 。</p>
<p>对于非空的 <strong>线性表</strong> 或 <strong>线性结构</strong> 有以下特点:</p>
<ul>
<li>存在唯一的一个被称作 <code>第一个</code> 的数据元素</li>
<li>存在唯一的一个被称作 <code>最后一个</code> 的数据元素</li>
<li>除了第一个数据元素之外, 结构中的每个数据元素均有一个前驱</li>
<li>除了最后一个元素之外, 结构中的每个数据元素均有一个后继</li>
</ul>
<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><img src="/images/顺序表.png" style="zoom:50%;">

<center>顺序表</center>

<h2 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h2><p>我们知道, 顺序表示指的是一组地址连续的存储单元依次存储线性表的数据元素, 这种表示也称为 <strong>线性表的顺序存储结构 或 顺序映像</strong> , 通常称这种结构的线性表为 <strong>顺序表</strong> 。他的特点在于, 逻辑上相邻的数据元素, 物理次序也是相邻的。</p>
<p>顺序表的存储结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 宏定义顺序表的长度 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序表结构</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ElementType *data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;seqList;</span></pre></td></tr></table></figure>



<h2 id="顺序表的操作实现"><a href="#顺序表的操作实现" class="headerlink" title="顺序表的操作实现"></a>顺序表的操作实现</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>表的结构完成了, 在使用表之前首先需要进行表的初始化, 也就是生成一个空的顺序表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initList</span><span class="params">(SeqList *L)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 为顺序表开辟一个大小为 100 的空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  L-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType *) * <span class="number">100</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 非空判断, 如果开辟失败直接退出程序, 注意这里用的是 exit()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!L-&gt;data) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 空表赋值长度为 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  L-&gt;length = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> YES;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>关于 exit( ) 和 return 的区别 ? </p>
</blockquote>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入时需要注意顺序表是插入的位置判断, 是否超过顺序表存储长度, 以及插入完成以后对顺序表长度进行 <code>+1</code> 操作。</p>
<p>算法步骤如下:</p>
<ol>
<li>首先声明函数需要三个参数: 待插入数据的顺序表, 插入位置, 插入的数据元素</li>
<li>判断插入位置是否合法, 即 位置是否是从 1(或者0) 开始</li>
<li>判断顺序表是否已满</li>
<li>判断插入的位置是否在表尾, 如果不在表尾需要对之后的数据做移位操作(所以我们这里是采用的倒序遍历, 将插入数据后面的数据做后移一位)</li>
<li>将需要插入的元素放到想要插入的位置</li>
<li>顺序表长度 <code>+1</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(SeqList *L, <span class="keyword">int</span> i, ElementType a)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断 i 值是否合法 (当为 length + 1 时说明是插在表尾)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;length + <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断存储空间是否已满</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (L-&gt;length &gt; MAXSIZE) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断插入位置是否在表尾</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i &lt;= L-&gt;length) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L-&gt;length; j &gt;= i; j--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 插入位置之后的位置做后移</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            L-&gt;data[j+<span class="number">1</span>] = L-&gt;data[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 插入数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    L-&gt;data[i] = a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 长度 +1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ++L-&gt;length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><p>取值操作与插入操作一样需要3个参数, 操作的顺序表, 要取值的位置 和 要取值的接收者</p>
<p>算法步骤如下:</p>
<ol>
<li>首先判断所要取的位置是否合法</li>
<li>根据传入的位置取值, 并将取出的值交给赋给接收者</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElem</span> <span class="params">(SeqList *L, <span class="keyword">int</span> i, ElementType *e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断 i 值是否有效</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;length) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 取值, 然后赋给接收者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    *e = L-&gt;data[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 循环打印</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printSeqList</span> <span class="params">(SeqList *L)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L-&gt;length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, L-&gt;data[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除操作因为是要做减操作, 所以首先需要判断顺序表是否为空, 然后判断传入的位置是否合法, 最后在进行完删除以后还要讲 <code>length</code> 做 <code>-1</code> 操作</p>
<p>算法步骤如下:</p>
<ol>
<li>首先判断顺序表的长度是否为 0</li>
<li>判断想要删除的位置是否有效</li>
<li>循环遍历, 将想要删除的位置之后的元素向前移动 (注意: 这里可以看到如果删除的位置是最后一个是不会进循环的, 只需要进行第4步就可以了)</li>
<li>顺序表长度 <code>-1</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletElem</span> <span class="params">(SeqList *L, <span class="keyword">int</span> i)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断长度是否为0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!L-&gt;length) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断删除位置是否有效</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;length) <span class="keyword">return</span> ERROR;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将删除位置 i 之后的元素都往前移动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L-&gt;length; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        L-&gt;data[j] = L-&gt;data[j+<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 表的长度 -1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    --L-&gt;length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> OK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// insert code here...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    SeqList L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    initList(&amp;L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 插入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ListInsert(&amp;L, <span class="number">1</span>, <span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ListInsert(&amp;L, <span class="number">2</span>, <span class="number">15</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ListInsert(&amp;L, <span class="number">3</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ListInsert(&amp;L, <span class="number">4</span>, <span class="number">35</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ListInsert(&amp;L, <span class="number">5</span>, <span class="number">50</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ListInsert(&amp;L, <span class="number">6</span>, <span class="number">15</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printSeqList(&amp;L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------------------\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 查找</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ElementType e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    getElem(&amp;L, <span class="number">4</span>, &amp;e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"e: %d\n"</span>, e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------------------\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 删除</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    deletElem(&amp;L, <span class="number">4</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    printSeqList(&amp;L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"end!!!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 打印结果:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">15</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">35</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">50</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">15</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">----------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">e: <span class="number">35</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">----------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">15</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">50</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">15</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">end</span>!!!</span></pre></td></tr><tr><td class="code"><pre><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是本次的全部内容, 主要是是研究 <strong>顺序表</strong> 的定义和一些基本操作的实现。然后对 <strong>逻辑结构</strong> 和 <strong>物理结构</strong> 也有了进一步的认识, 后续内容将继续研究不同结构下的各种数据结构。感谢大家, 希望本次内容能让你有所收获。</p>
<p>和谐学习, 不急不躁!</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法--基础概念</title>
    <url>/2020-04-01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95--%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><p>数据结构是计算机存储、组织数据的方式, 是指相互之间存在一种或多种特定关系的数据元素的集合。它研究的是数据的 <code>逻辑结构</code> 和 <code>物理结构</code> 以及他们之间的相互关系, 并对这种结构定义相应的运算, 设计出相应的算法, 所以数据结构和算法也是不可分割的。</p>
<h4 id="2-相关术语"><a href="#2-相关术语" class="headerlink" title="2. 相关术语"></a>2. 相关术语</h4><p>数据结构中常见的几个概念, 先放一张偷来的图:</p>
<img src="/images/基本概念-1.png" style="zoom:50%;">

<ul>
<li><strong>数据</strong></li>
</ul>
<p>描述客观事物的符号, 能够被计算机识别, 是计算机中可以操作的对象。包括 整型、浮点型等数值类型, 也包括 字符、声音、视频等非数值类型。</p>
<ul>
<li><strong>数据项</strong></li>
</ul>
<p>数据不可分割的最小标识单位, 用来组成数据元素。数据线通常不具有完整确定的实际意义, 或不被当做一个整体对待, 数据项又被成为 <em>字段或域</em>。</p>
<ul>
<li><strong>数据元素</strong></li>
</ul>
<p>数据元素是数据的基本单位, 在程序中作为一个整体考虑和处理, 是运算的基本单位。通常具有完整的实际意义, 又被成为 <em>元素、结点、顶点或记录</em>。</p>
<ul>
<li><strong>数据对象</strong></li>
</ul>
<p>具有相同性质的数据元素的集合, 是数据的子集。</p>
<blockquote>
<p>性质相同: 指数据元素具有相同数量和类型的数据项, 类似数组中的元素保持性质一致。</p>
</blockquote>
<p>下面通过两个表格来通俗的理解一下上面的概念:</p>
<table>
<thead>
<tr>
<th align="center">姓名</th>
<th align="center">性别</th>
<th align="center">身高(cm)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">李磊</td>
<td align="center">男</td>
<td align="center">180</td>
</tr>
<tr>
<td align="center">韩梅梅</td>
<td align="center">女</td>
<td align="center">260</td>
</tr>
</tbody></table>
<center>表 A</center>
| 课程编号 | 课程名 |
| :------: | :----: |
|   1001   |  语文  |
|   1002   |  数学  |

<center>表 B</center>
1. 上面我们定义了两张表, 表A为人员表, 表B为课程表, 这两张表就是 **数据**

<ol start="2">
<li>单独的一张表的话, 就是我们说的 <strong>数据对象</strong></li>
<li>每张表的每一行就称为 <strong>数据元素</strong></li>
<li>组成 <strong>数据元素</strong> 的部分, 比如姓名, 性别, 身高等, 这些称为 <strong>数据项</strong></li>
</ol>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>逻辑结构指的是<strong>数据元素之间的相互关系</strong> 。根据相互关系的不同, 逻辑结构分为四种类型: 集合结构, 线性结构, 树形结构, 图形结构。</p>
<h4 id="1-集合结构"><a href="#1-集合结构" class="headerlink" title="1. 集合结构"></a>1. 集合结构</h4><img src="/images/基本概念-2.png" style="zoom:50%;">

<p>数据元素同属于一个集合, 之间没有任何其他联系, 各个元素之间都是平等的。</p>
<h4 id="2-线性结构"><a href="#2-线性结构" class="headerlink" title="2. 线性结构"></a>2. 线性结构</h4><img src="/images/基本概念-3.png" style="zoom:50%;">

<p>线性结构中的数据元素之间是 <strong>一对一的关系</strong>, 常见的线性结构有: 线性表, 栈, 队列, 数组等。</p>
<h4 id="3-树形结构"><a href="#3-树形结构" class="headerlink" title="3. 树形结构"></a>3. 树形结构</h4><img src="/images/基本概念-4.png" style="zoom:50%;">

<p>树形结构可以表示数据元素之间 <strong>一对多的关系</strong> , 是很重要的 <strong>非线性数据结构</strong>。常见的树形结构有: 二叉树, B树, 红黑树等。</p>
<h4 id="4-图形结构"><a href="#4-图形结构" class="headerlink" title="4. 图形结构"></a>4. 图形结构</h4><img src="/images/基本概念-5.png" style="zoom:50%;">

<p>图形结构数据元素是 <strong>多对多的关系</strong> 。常见的图形结构有: 邻近矩阵等。</p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>物理结构 (又称”存储结构”), 指的是<strong>数据的逻辑结构在计算机中的存储形式</strong>。存储形式主要有2种: 顺序存储 和 链式存储。</p>
<h4 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="1. 顺序存储结构"></a>1. 顺序存储结构</h4><img src="/images/基本概念-6.png" style="zoom:50%;">

<p>顺序存储结构是把数据元素放到地址连续的存储单元里面, 数据之间的逻辑关系和物理关系是一致的。个人理解顺序就是指相邻数据元素之间的地址连续, 类似于排队一样。</p>
<p>顺序存储结构就像我们生活中排队一样, 假如中间有人插队或者有人离队的话, 整个结构都需要发生变化, 这时候就需要引入链式存储结构了。</p>
<h4 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="2. 链式存储结构"></a>2. 链式存储结构</h4><img src="/images/基本概念-7.png" style="zoom:50%;">

<p>链式存储结构把数据元素放在任意的存储单元里, 这些存储单元可以是连续的, 也可以是不连续的。数据元素的存储关系并不能反映逻辑关系, 因此这里引入了指针, 用一个指针存放数据元素的地址, 这样通过地址就可以找到相关联数据元素的位置。</p>
<p>很显然链式结构比较灵活, 数据存储位置不重要, 只要指针存放了相应的地址, 就可以通过指针找到相邻元素了。从这一点也能看到 <strong>顺序存储结构</strong> 和 <strong>链式存储结构</strong> 最大的区别就是链式存储结构引进了指针的概念，通过指针来存储地址，从而通过地址来寻找相邻元素。</p>
<h3 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h3><p><a href="https://baike.baidu.com/item/数据结构/1450?fr=aladdin" target="_blank" rel="noopener">注意: 这里的内容来自百度百科, 详细内容可以去这里看一下</a></p>
<ul>
<li><strong>数组 (Array)</strong></li>
</ul>
<p><a href="https://baike.baidu.com/item/数组/3794097" target="_blank" rel="noopener">数组</a>是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。</p>
<ul>
<li><strong>栈 (Stack)</strong></li>
</ul>
<p><a href="https://baike.baidu.com/item/栈/12808149" target="_blank" rel="noopener">栈</a>是一种特殊的<a href="https://baike.baidu.com/item/线性表/3228081" target="_blank" rel="noopener">线性表</a>，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。</p>
<ul>
<li><strong>队列 (Queue)</strong></li>
</ul>
<p><a href="https://baike.baidu.com/item/队列/14580481" target="_blank" rel="noopener">队列</a>和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。</p>
<ul>
<li><strong>链表 (Linked List)</strong></li>
</ul>
<p><a href="https://baike.baidu.com/item/链表/9794473" target="_blank" rel="noopener">链表</a>是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。</p>
<ul>
<li><strong>树 (Tree)</strong></li>
</ul>
<p><a href="https://baike.baidu.com/item/树/2699484" target="_blank" rel="noopener">树</a>是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0。</p>
<ul>
<li><strong>图 (Graph)</strong></li>
</ul>
<p><a href="https://baike.baidu.com/item/图/13018767" target="_blank" rel="noopener">图</a>是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。</p>
<ul>
<li><strong>堆 (Heap)</strong></li>
</ul>
<p><a href="https://baike.baidu.com/item/堆/20606834" target="_blank" rel="noopener">堆</a>是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。</p>
<ul>
<li><strong>散列表 (Hash)</strong></li>
</ul>
<p>散列表源自于<a href="https://baike.baidu.com/item/散列函数/2366288" target="_blank" rel="noopener">散列函数</a>(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法就是描述解决问题的方法, 人们在实际开发中会遇到很多的问题, 解决问题的方法也是千变万化。每个人对问题的解决方案都是不一样的, 不同的算法可能用不同的时间、空间或效率来完成同样的任务, 一个算法的优劣可以用 <code>空间复杂度</code> 与 <code>时间复杂度</code> 来衡量。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>一个算法必须具备下面的几个基本特性:</p>
<ul>
<li><strong>输入输出</strong></li>
</ul>
<p>输入用来获取对象的已知条件, 输出用来反映算法执行后的结果。一个算法可以有 0 个输入(算法本身定出了初始条件), 但是不可以没有输出, 没有输出的算法是毫无意义的。</p>
<ul>
<li><strong>有穷性</strong></li>
</ul>
<p>指算法在执行有限的步骤之后自动结束, 而不是无限执行下去。</p>
<ul>
<li><strong>确定性</strong></li>
</ul>
<p>算法的每一步都具有确定的含义, 需要保证算法的相同条件下只有一条执行路径, 相同的输入只能有唯一的输出结果</p>
<ul>
<li><strong>可行性</strong></li>
</ul>
<p>也称为有效性, 一个算法是可行的, 即算法中描述的操作都是通过已经实现的基本运算执行有限次来实现的。</p>
<h3 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h3><p>在不考虑效率的情况下, 一个合格的算法必须满足下面的三个条件:</p>
<ul>
<li><strong>正确性</strong></li>
</ul>
<p>算法的正确性是评价一个算法优劣的最重要的标准。</p>
<ul>
<li><strong>可读性</strong></li>
</ul>
<p>可读性是指一个算法可供人们阅读的容易程度, 可读性高有助于人们理解算法; 晦涩难懂的算法往往很难调试和修改。</p>
<blockquote>
<p>注意: 代码越少, 越牛逼!!! 这种想法是不可取的, 如今团队协作的今天, 不再是个人英雄主义的时代, 我觉得能让人更容易读懂才是关键。</p>
<p>( 所以, 能加注释的顺手加上吧, 队友很难受的。)</p>
</blockquote>
<ul>
<li><strong>健壮性</strong></li>
</ul>
<p>健壮性是值一个算法对不合理数据输入的反应能力和处理能力, 也成为 <strong>容错性</strong> 。</p>
<ul>
<li><strong>时间效率和存储效率</strong></li>
</ul>
<p>这里就是下面要说到的 <em>时间复杂度 与 空间复杂度</em> ,  在保证上面的一切的同时, 还要尽可能的提升算法的 执行效率 和 资源占用情况。    </p>
<h3 id="效率度量"><a href="#效率度量" class="headerlink" title="效率度量"></a>效率度量</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h5 id="1-时间复杂度定义"><a href="#1-时间复杂度定义" class="headerlink" title="1. 时间复杂度定义"></a>1. 时间复杂度定义</h5><p>在进行算法分析时, 语句的总执行次数 T(n) 是关于问题规模 n 的函数, 进而分析T(n)随着n变化情况并确定T(n)的数量级, 算法的时间复杂度, 也就是算法的时间量度 </p>
<center>T(n) = O(f(n))</center>
他表示随着问题的规模 n 的增大, 算法执行时间的增长率和 f(n) 的增长率相同, 成为算法的**渐进时间复杂度**, 简称**时间复杂度**。(*这种使用 O( ) 来体现算法时间复杂度的记法, 我们称之为大O表示法。*)

<h5 id="2-大-O-表示法"><a href="#2-大-O-表示法" class="headerlink" title="2. 大 O 表示法"></a>2. 大 O 表示法</h5><ul>
<li>大 O 表示法规则</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*大O表示法</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 1. 用常数1取代运行时间中所有常数 3-&gt;1 O(1)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 2. 在修改运行次数函数中,只保留最高阶项 n^3+2n^2+5 -&gt; O(n^3)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 3. 如果在最高阶存在且不等于1,则去除这个项目相乘的常数 2n^3 -&gt; n^3</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *&#x2F;</span></pre></td></tr></table></figure>

<ul>
<li>使用大 O 表示法计算时间复杂度</li>
</ul>
<blockquote>
<p>时间复杂度总共可以分为: 常数阶, 线性阶, 平方阶, 对数阶, 立方阶, nlog阶, 指数阶</p>
<p>指数阶目前不考虑, 因为如果n增大以后, 时间复杂度会噩梦般的增长, 有点不切实际</p>
</blockquote>
<ol>
<li>常数阶</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 + 1 + 1 = 3  O(1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> test1(<span class="keyword">int</span> n)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;                <span class="comment">//执行1次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sum = (<span class="number">1</span>+n)*n/<span class="number">2</span>;            <span class="comment">//执行1次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    printf(<span class="string">"testSum1:%d\n"</span>,sum);<span class="comment">//执行1次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 不管传进来的 n 为多少, 程序执行的代码都是固定的, 所以时间复杂度为常数阶, O(1)</span></span></pre></td></tr></table></figure>

<ol start="2">
<li>线性阶</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行 n 次  x &#x3D; x+1;  O(n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">void test2(int x,int n)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x &#x3D; x+1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据传进来的 n 的值成 n 倍数增长, 时间复杂度为 O(n)</span></pre></td></tr></table></figure>

<ol start="3">
<li>对数阶</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 2的x次方等于n x &#x3D; log2n  -&gt;O(logn) ...(log2n 里的 2为下标)</span></pre></td></tr><tr><td class="code"><pre><span class="line">void test3(int n)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int count &#x3D; 1;         &#x2F;&#x2F;执行1次</span></pre></td></tr><tr><td class="code"><pre><span class="line">    while (count &lt; n) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        count &#x3D; count * 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr></table></figure>

<ol start="4">
<li>平方阶</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;x&#x3D;x+1; 执行n*n次 -&gt;O(n^2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">void test4(int x,int n)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int i &#x3D; 0; i&lt; n; i++) &#123; &#x2F;&#x2F; n</span></pre></td></tr><tr><td class="code"><pre><span class="line">        for (int j &#x3D; 0; j &lt; n ; j++) &#123; &#x2F;&#x2F; n * n</span></pre></td></tr><tr><td class="code"><pre><span class="line">            x&#x3D;x+1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ol start="5">
<li>立方阶</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1+n+(n*n)+(n*n*n)+(n*n*n) &#x3D; 1+n+n^2+2n^3 -&gt; O(n^3)</span></pre></td></tr><tr><td class="code"><pre><span class="line">void test5(int n)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int sum &#x3D; 1;                         &#x2F;&#x2F;执行1次</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;        &#x2F;&#x2F;执行n次</span></pre></td></tr><tr><td class="code"><pre><span class="line">        for (int j &#x3D; 0 ; j &lt; n; j++) &#123;   &#x2F;&#x2F;执行n*n次</span></pre></td></tr><tr><td class="code"><pre><span class="line">            for (int k &#x3D; 0; k &lt; n; k++) &#123;&#x2F;&#x2F;执行n*n*n次</span></pre></td></tr><tr><td class="code"><pre><span class="line">                sum &#x3D; sum * 2;          &#x2F;&#x2F;执行n*n*n次</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 程序存储空间计算因素:</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;*</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		1. 寄存本身的指令</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		2. 常数</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		3. 变量</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		4. 输入</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		5. 对数据进行操作的辅助空间</span></pre></td></tr><tr><td class="code"><pre><span class="line">*&#x2F;</span></pre></td></tr></table></figure>

<p>算法的空间复杂度通过计算算法所需的存储空间实现, 算法空间复杂度的计算公式为:</p>
<center>S(n) = n(f(n))</center>
一般情况下, 程序在机器上执行时除了需要寄存本身的指令, 数据等之外, 还需要一些执行数据操作的辅助存储空间。在考量算法的空间复杂度上，主要考虑算法执行时所需要的辅助空间。

<p>下面通过两个例子来看一下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 问题: 将一维数组a中的n个数逆序存放在原数组中.</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">int temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt; n&#x2F;2 ; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp &#x3D; a[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a[i] &#x3D; a[n-i-1];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a[n-i-1] &#x3D; temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(int i &#x3D; 0;i &lt; 10;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        printf(&quot;%d\n&quot;,a[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">int b[10] &#x3D; &#123;0&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt; n;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        b[i] &#x3D; a[n-i-1];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a[i] &#x3D; b[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for(int i &#x3D; 0;i &lt; 10;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        printf(&quot;%d\n&quot;,a[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<ol>
<li>算法1声明了一个临时变量 <code>temp</code> , 借助 <code>temp</code> 解决问题, 与 <code>n</code> 的大小没有关系, 所以他的空间复杂度为 <strong>O(1)</strong> 。</li>
<li>算法2 借助了一个大小为 <code>n</code> 的辅助数组, 所以他的空间复杂度为 <strong>O(n)</strong> 。</li>
</ol>
<blockquote>
<p><strong>注意: 空间复杂度不是整个算法内存占用空间大小, 而是指在算法实现时需要开辟出的辅助空间占用的大小</strong></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了关于 数据结构 和 算法 的一些定义, 主要是一些文字性的叙述, 所以有些地方可能表达的不是很准确。如果有不对的地方或者不是很明白的地方, 欢迎进行提问和指出。这里也算是对 数据结构 和 算法 学习的一个开始, 以后会陆续增加更多内容。</p>
<p><em>和谐学习, 不急不躁 ~</em></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS探索--类的结构分析(二)</title>
    <url>/2020-03-25-iOS%E6%8E%A2%E7%B4%A2--%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90(%E4%BA%8C)/</url>
    <content><![CDATA[<blockquote>
<p>接上一篇 <a href="https://juejin.im/post/5e758452f265da57602c728b" target="_blank" rel="noopener">iOS探索–类的结构分析(一)</a> , 在上一篇文章中, 我们进行类类的内部结构分析, 主要针对 <code>class_rw_t</code> 进行了一些研究, 发现了类当中的 <code>属性</code> 、<code>成员变量</code> 、<code>类方法</code> 和 <code>实例方法</code> 是怎么存储的。但是还有一个东西我们没有去关注, 那就是 <code>cache_t</code> 部分, 在本次探索中我们一起来看一下。</p>
</blockquote>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>在我们的 <code>objc_class</code> 结构体找到 <code>cache_t</code> , 查看一下他的内部结构到底是什么样子的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_class</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Class ISA;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class superclass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span></pre></td></tr><tr><td class="code"><pre><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    class_rw_t *data() &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        return bits.data();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;*</span></pre></td></tr><tr><td class="code"><pre><span class="line">  函数</span></pre></td></tr><tr><td class="code"><pre><span class="line">  *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; cache_t</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct cache_t &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    struct bucket_t *_buckets;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mask_t _mask;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mask_t _occupied;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    struct bucket_t *buckets(); &#x2F;&#x2F; buckets() 函数, 返回 </span></pre></td></tr><tr><td class="code"><pre><span class="line">    mask_t mask();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mask_t occupied();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void incrementOccupied();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void initializeToEmpty();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mask_t capacity();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bool isConstantEmptyCache();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bool canBeFreed();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    static size_t bytesForCapacity(uint32_t cap);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    static struct bucket_t * endMarker(struct bucket_t *b, uint32_t cap);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    void expand();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void reallocate(mask_t oldCapacity, mask_t newCapacity);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    struct bucket_t * find(cache_key_t key, id receiver);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    static void bad_cache(id receiver, SEL sel, Class isa) __attribute__((noreturn));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#if __LP64__</span></pre></td></tr><tr><td class="code"><pre><span class="line">typedef uint32_t mask_t;  &#x2F;&#x2F; x86_64 &amp; arm64 asm are less efficient with 16-bits</span></pre></td></tr><tr><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="code"><pre><span class="line">typedef uint16_t mask_t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line">typedef uintptr_t cache_key_t;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bucket_t</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct bucket_t &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">private:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; IMP-first is better for arm64e ptrauth and no worse for arm64.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; SEL-first is better for armv7* and i386 and x86_64.</span></pre></td></tr><tr><td class="code"><pre><span class="line">#if __arm64__</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MethodCacheIMP _imp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cache_key_t _key;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cache_key_t _key;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MethodCacheIMP _imp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  inline cache_key_t key() const &#123; return _key; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  inline IMP imp() const &#123; return (IMP)_imp; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  inline void setKey(cache_key_t newKey) &#123; _key &#x3D; newKey; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  inline void setImp(IMP newImp) &#123; _imp &#x3D; newImp; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  void set(cache_key_t newKey, IMP newImp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>从上面的源码可以看到, <code>cache_t</code> 结构体主要有三部分组成: <code>_mask</code> 、<code>occupied</code> 和一个 <code>bucket_t</code> 类型的结构体指针, 且前面两个都是 <code>unit32_t</code> 类型的。</p>
<p>至于 <code>bucket_t</code> , 可以在里面发现了 <code>_imp</code> 和 <code>_key</code>, 其实 <code>_key</code> 就是我们的 <code>SEL</code> , 通过这些我们其实可以看出, <code>bucket_t</code> 里面存放的就是我们的方法缓存。</p>
<blockquote>
<p>关于 <code>SEL</code> 和 <code>IMP</code></p>
<p>SEL: 类的成员方法(实例方法) 的指针, 不同于C语言中的函数指针, 函数指针直接保存方法的地址, 但是 SEL 只是方法的符号</p>
<p>IMP: 一个函数指针, 保存了方法的地址</p>
<p>系统通过SEL在类里面找到对应的IMP然后再由IMP去调用方法。</p>
<p><em>关于 SEL 和 IMP, 有兴趣的可以去搜索一下, 这里有可能表达的不够好。</em></p>
</blockquote>
<h3 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h3><h4 id="1-初探"><a href="#1-初探" class="headerlink" title="1. 初探"></a>1. 初探</h4><p>通过上面的分析, 我们判断 <code>cache_t</code> 其实就是对方法调用的一个缓存, 那么具体是怎么去缓存的, 我们一起来验证一下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 准备</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)sayHello;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)sayGood;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)sayByebye;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)sayHappy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 调用</span></pre></td></tr><tr><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">Class pClass &#x3D; object_getClass(person);</span></pre></td></tr><tr><td class="code"><pre><span class="line">[person sayHello];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[person sayHappy];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[person sayHappy];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[person sayGood];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[person sayByebye];</span></pre></td></tr></table></figure>

<p>上面我们准备了4个实例方法, 然后在调用过程中进行断点调试, 分别打印一下在调用方法的过程中我们的 <code>cache_t</code> 的值是什么样子的。开搞:</p>
<p><img src="/images/cache_t-1.png" alt="cache_t-1"></p>
<ol>
<li>首先类首地址偏移 16位(上图错别字请忽略😝), 得到 <code>cache_t</code> 的地址并打印</li>
<li>打印 <code>cache_t</code> 中的 <code>_buckets</code> 得到 <code>bucket_t</code> 结构体指针, 然后直接打印该指针的值, 发现结果是空的 <code>bucket_t</code></li>
<li>根据命名 <code>_buckets</code> 我们猜测其是一个数组, 根据下标一次打印, 终于在第3个下标找到 <code>init</code> 方法缓存 (ps: <em>init</em> 对象方法同样会做缓存; 至于 <em>alloc</em> 我们之前说过, 他是存储在元类里面的类方法)</li>
<li>继续往下走把我们的所以方法执行完毕, 打印一下看看</li>
</ol>
<p><img src="/images/cache_t-2.png" alt="cache_t-1"></p>
<ol start="5">
<li>执行结束我们依然接着上面的进行打印, 发现此时的 <code>_mask = 7 , _occupied = 2</code> , 但是, 我们在方法缓存里面却只找到了两个方法, 其余 3个方法不见了。</li>
</ol>
<p>通过上面的打印, 我们发现在 <code>_buckets</code> 类似一个数组, 可以通过下标打印里面的内容, 而且我们在里面找到了方法的缓存数据。但是在第二次打印的时候发生了奇怪的事情, <strong><code>_buckets</code> 的存储数量变大了(_mask 和 _occupied都发生了变化, _mask变大了, _occupied好像是缓存的方法数量), 但是里面并没有包含我们调用的所有方法, 并且缓存的排布也是不规律的。</strong> 这中间到底发生了什么不可告人的秘密, 我们接下来深入探索一下吧。</p>
<h4 id="2-深入探索"><a href="#2-深入探索" class="headerlink" title="2. 深入探索"></a>2. 深入探索</h4><p>上面的过程我们一直针对 <code>_buckets</code> 进行了打印, 但是忽略了另外两个东西 <code>_mask</code> 和 <code>_occupied</code> 。既然存在肯定有他的价值的, 并且他们两个的值也在变化。下面我们先从方法的角度一起来寻找一下他们两个的用途:</p>
<h5 id="2-1-cache-fill-nolock"><a href="#2-1-cache-fill-nolock" class="headerlink" title="2.1 cache_fill_nolock"></a>2.1 cache_fill_nolock</h5><p>首先查看方法, 发现 <code>mask() 和 occupied()</code> 方法, 查看其内部实现发现都是返回其本身, 应该是 <code>get</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mask_t cache_t::mask() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return _mask; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mask_t cache_t::occupied() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return _occupied;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>接下来我们全局搜索一下 <code>mask()</code> 和 <code>occupied()</code> 方法, 看看都在哪里用到了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; mask() 搜索</span></pre></td></tr><tr><td class="code"><pre><span class="line">mask_t cache_t::capacity() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return mask() ? mask()+1 : 0; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; occupied() 搜索</span></pre></td></tr><tr><td class="code"><pre><span class="line">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cacheUpdateLock.assertLocked();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Never cache before +initialize is done</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (!cls-&gt;isInitialized()) return;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Make sure the entry wasn&#39;t added to the cache by some other thread </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; before we grabbed the cacheUpdateLock.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (cache_getImp(cls, sel)) return;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cache_t *cache &#x3D; getCache(cls);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cache_key_t key &#x3D; getKey(sel);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Use the cache as-is if it is less than 3&#x2F;4 full</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mask_t newOccupied &#x3D; cache-&gt;occupied() + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mask_t capacity &#x3D; cache-&gt;capacity();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (cache-&gt;isConstantEmptyCache()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; Cache is read-only. Replace it.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    else if (newOccupied &lt;&#x3D; capacity &#x2F; 4 * 3) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; Cache is less than 3&#x2F;4 full. Use it as-is.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; Cache is too full. Expand it.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cache-&gt;expand();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Scan for the first unused slot and insert there.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; There is guaranteed to be an empty slot because the </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; minimum size is 4 and we resized at 3&#x2F;4 full.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bucket_t *bucket &#x3D; cache-&gt;find(key, receiver);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (bucket-&gt;key() &#x3D;&#x3D; 0) cache-&gt;incrementOccupied();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bucket-&gt;set(key, imp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>全局搜索发现用的地方不多, 这里没有一一列举, 首先发现 <code>capacity()</code> 方法中使用 了 <code>mask()</code> , 并且如果 <code>mask</code> 有值的话, 取出时进行了 <code>+ 1</code> 操作。然后在 <code>cache_fill_nolock</code> 方法中使用了 <code>capacity() 和 occupied()</code> 方法, 仔细查看该方法名, 猜测该方法就是用来进行做方法 <strong>缓存</strong> 的。下面我们来分步看一下里面的操作:</p>
<ol>
<li><p>if (!cls-&gt;isInitialized()) return;</p>
<p>判断类是否已经初始化对象, 没有就直接返回</p>
</li>
<li><p>if (cache_getImp(cls, sel)) return;</p>
<p>根据传入的 类<code>cls</code> 和 方法的<code>sel</code> 查找 <code>imp</code> 的缓存数据, 如果过去到就返回, 避免重复缓存</p>
</li>
<li><p>获取当前缓存 <code>cache</code>, 将传入的 <code>sel</code> 转化成存储需要的 <code>key</code>; 并且从 <code>cache</code> 中获取到 <code>mask + 1</code> 的结果(即 <code>capacity</code> 总容量) 和 <code>occupied</code> 的值做 <code>＋1</code> 处理( 即 <code>newOccupied</code> 新的缓存数量)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cache_t *cache &#x3D; getCache(cls);</span></pre></td></tr><tr><td class="code"><pre><span class="line">cache_key_t key &#x3D; getKey(sel);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">mask_t newOccupied &#x3D; cache-&gt;occupied() + 1; &#x2F;&#x2F; 旧的缓存 +1, 得到新的缓存数量</span></pre></td></tr><tr><td class="code"><pre><span class="line">mask_t capacity &#x3D; cache-&gt;capacity(); &#x2F;&#x2F; 缓存的总容量</span></pre></td></tr></table></figure>
</li>
<li><p>使用上面获取到的结果进行判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (cache-&gt;isConstantEmptyCache()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	&#x2F;&#x2F; Cache is read-only. Replace it.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">else if (newOccupied &lt;&#x3D; capacity &#x2F; 4 * 3) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	&#x2F;&#x2F; Cache is less than 3&#x2F;4 full. Use it as-is.</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	&#x2F;&#x2F; Cache is too full. Expand it.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	cache-&gt;expand();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; INIT_CACHE_SIZE</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;* Initial cache bucket count. INIT_CACHE_SIZE must be a power of two. *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">enum &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    INIT_CACHE_SIZE_LOG2 &#x3D; 2,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    INIT_CACHE_SIZE      &#x3D; (1 &lt;&lt; INIT_CACHE_SIZE_LOG2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>使用第三步获取到的东西进行判断:</p>
<p>首先判断 <code>cache</code> 是否为空, 如果是空就根据传进来的 <code>capacity</code> 进行空间开辟, 这里的 <code>INIT_CACHE_SIZE</code> 需要说明一下, 可以看下面的枚举, 他的值默认是 <code>1 &lt;&lt; 2</code>, 也就是 4 (100 二进制) , 上面的注释里也说明 <em>INIT_CACHE_SIZE 必须是 2的多少次方的结果。</em></p>
<p>然后判断 <code>newOccupied &lt;= capacity / 4 * 3</code> , 如果 <strong>新的缓存占用大小</strong> 小于 <strong>缓存总容量的四分之三</strong> 的话, 可以进行缓存</p>
<p>如果 <strong>大于缓存总容量的四分之三</strong>, 执行 <code>cache-&gt;expand()</code> 。</p>
</li>
<li><p>执行缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Scan for the first unused slot and insert there.</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; There is guaranteed to be an empty slot because the </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; minimum size is 4 and we resized at 3&#x2F;4 full.</span></pre></td></tr><tr><td class="code"><pre><span class="line">bucket_t *bucket &#x3D; cache-&gt;find(key, receiver);</span></pre></td></tr><tr><td class="code"><pre><span class="line">if (bucket-&gt;key() &#x3D;&#x3D; 0) cache-&gt;incrementOccupied();</span></pre></td></tr><tr><td class="code"><pre><span class="line">bucket-&gt;set(key, imp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; incrementOccupied()</span></pre></td></tr><tr><td class="code"><pre><span class="line">void cache_t::incrementOccupied() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _occupied++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过 <code>key</code> 在 <code>cache</code> 中找到对应的 <code>bucket</code> , 判断如果 <code>bucket-&gt;key() == 0</code> (也就是还没有存储进去) , 执行 <code>_occupied++</code> , 把 <code>key</code> 和 <code>imp</code> 存储到该 <code>bucket</code> 中去。</p>
</li>
</ol>
<h5 id="2-2-reallocate"><a href="#2-2-reallocate" class="headerlink" title="2.2 reallocate ( )"></a>2.2 reallocate ( )</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bool freeOld &#x3D; canBeFreed();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    bucket_t *oldBuckets &#x3D; buckets();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bucket_t *newBuckets &#x3D; allocateBuckets(newCapacity);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Cache&#39;s old contents are not propagated. </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; This is thought to save cache memory at the cost of extra cache fills.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; fixme re-measure this</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert(newCapacity &gt; 0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert((uintptr_t)(mask_t)(newCapacity-1) &#x3D;&#x3D; newCapacity-1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    setBucketsAndMask(newBuckets, newCapacity - 1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (freeOld) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cache_collect_free(oldBuckets, oldCapacity);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cache_collect(false);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; canBeFreed()</span></pre></td></tr><tr><td class="code"><pre><span class="line">bool cache_t::canBeFreed() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return !isConstantEmptyCache();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; allocateBuckets()</span></pre></td></tr><tr><td class="code"><pre><span class="line">bucket_t *allocateBuckets(mask_t newCapacity) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Allocate one extra bucket to mark the end of the list.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; This can&#39;t overflow mask_t because newCapacity is a power of 2.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; fixme instead put the end mark inline when +1 is malloc-inefficient</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bucket_t *newBuckets &#x3D; (bucket_t *)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        calloc(cache_t::bytesForCapacity(newCapacity), 1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bucket_t *end &#x3D; cache_t::endMarker(newBuckets, newCapacity);</span></pre></td></tr><tr><td class="code"><pre><span class="line">#if __arm__</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; End marker&#39;s key is 1 and imp points BEFORE the first bucket.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; This saves an instruction in objc_msgSend.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    end-&gt;setKey((cache_key_t)(uintptr_t)1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    end-&gt;setImp((IMP)(newBuckets - 1));</span></pre></td></tr><tr><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; End marker&#39;s key is 1 and imp points to the first bucket.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    end-&gt;setKey((cache_key_t)(uintptr_t)1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    end-&gt;setImp((IMP)newBuckets);</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (PrintCaches) recordNewCache(newCapacity);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return newBuckets;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; setBucketsAndMask()</span></pre></td></tr><tr><td class="code"><pre><span class="line">void cache_t::setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; objc_msgSend uses mask and buckets with no locks.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; It is safe for objc_msgSend to see new buckets but old mask.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; (It will get a cache miss but not overrun the buckets&#39; bounds).</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; It is unsafe for objc_msgSend to see old buckets and new mask.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Therefore we write new buckets, wait a lot, then write new mask.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; objc_msgSend reads mask first, then buckets.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; ensure other threads see buckets contents before buckets pointer</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mega_barrier();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    _buckets &#x3D; newBuckets;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; ensure other threads see new buckets before new mask</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mega_barrier();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    _mask &#x3D; newMask;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _occupied &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上的代码是执行 <code>reallocate ( )</code> , 也就是开辟 <code>cache</code> 空间的操作。 </p>
<ul>
<li>首先 <code>canBeFreed()</code> , 是用来判断 <code>cache</code> 是否有值, 可以看到实现里是用的 <code>!isConstantEmptyCache()</code> , 如果是有值的, 在方法的最后做了 <code>freeOld</code> 操作, 清空了旧的缓存数据</li>
<li>使用传进来的 <code>newCapacity</code> 调用 <code>allocateBuckets()</code> 方法创建新的 <code>bucket_t</code></li>
<li>调用 <code>setBucketsAndMask()</code> 方法, 设置新的 <code>bucket</code> , 并且 <code>_mask = newCapacity - 1, _occupied = 0</code> (所以我们打印的 mask的值 其实是 最大数量 - 1)</li>
</ul>
<blockquote>
<p>这里在创建完新的把旧的缓存直接删除了, 而不是读取出来重新存到新的缓存中去。</p>
<p>一 是因为如果重新读出来再缓存进去浪费时间, 直接抹掉速度更快</p>
<p>二 是因为读写操作不安全</p>
</blockquote>
<h5 id="2-3-expand"><a href="#2-3-expand" class="headerlink" title="2.3 expand( )"></a>2.3 expand( )</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void cache_t::expand()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cacheUpdateLock.assertLocked();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint32_t oldCapacity &#x3D; capacity();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint32_t newCapacity &#x3D; oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    if ((uint32_t)(mask_t)newCapacity !&#x3D; newCapacity) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; mask overflow - can&#39;t grow further</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; fixme this wastes one bit of mask</span></pre></td></tr><tr><td class="code"><pre><span class="line">        newCapacity &#x3D; oldCapacity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    reallocate(oldCapacity, newCapacity);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>expand()</code> 从名字意思也可以判断出, 这个方法是用来扩容的</p>
<ul>
<li>可以看到在扩容之前, 首先获取到了旧的 <code>capacity</code>, 也就是 <code>mask + 1</code></li>
<li>然后判断, 如果旧的 <code>capacity</code> 如果有值的话 <strong>直接乘以2, 增加一倍</strong> , 如果没有值的话, 就给他赋值为 <strong>4 (INIT_CACHE_SIZE 为 4)</strong></li>
<li>最后进行 <code>reallocate()</code> 方法开辟新的空间</li>
</ul>
<h5 id="2-4-find"><a href="#2-4-find" class="headerlink" title="2.4 find( )"></a>2.4 find( )</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bucket_t * cache_t::find(cache_key_t k, id receiver) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert(k !&#x3D; 0);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    bucket_t *b &#x3D; buckets();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mask_t m &#x3D; mask();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 通过cache_hash函数【begin  &#x3D; k &amp; m】计算出key值 k 对应的 index值 begin，用来记录查询起始索引</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mask_t begin &#x3D; cache_hash(k, m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; begin 赋值给 i，用于切换索引</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mask_t i &#x3D; begin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    do &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (b[i].key() &#x3D;&#x3D; 0  ||  b[i].key() &#x3D;&#x3D; k) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F;用这个i从散列表取值，如果取出来的bucket_t的 key &#x3D; k，则查询成功，返回该bucket_t，</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F;如果key &#x3D; 0，说明在索引i的位置上还没有缓存过方法，同样需要返回该bucket_t，用于中止缓存查询。</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return &amp;b[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; while ((i &#x3D; cache_next(i, m)) !&#x3D; begin);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 这一步其实相当于 i &#x3D; i-1,回到上面do循环里面，相当于查找散列表上一个单元格里面的元素，再次进行key值 k的比较，</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;当i&#x3D;0时，也就i指向散列表最首个元素索引的时候重新将mask赋值给i，使其指向散列表最后一个元素，重新开始反向遍历散列表，</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;其实就相当于绕圈，把散列表头尾连起来，不就是一个圈嘛，从begin值开始，递减索引值，当走过一圈之后，必然会重新回到begin值，</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;如果此时还没有找到key对应的bucket_t，或者是空的bucket_t，则循环结束，说明查找失败，调用bad_cache方法。</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; hack</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class cls &#x3D; (Class)((uintptr_t)this - offsetof(objc_class, cache));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cache_t::bad_cache(receiver, (SEL)k, cls);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; cache_hask()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Class points to cache. SEL is key. Cache buckets store SEL+IMP.</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Caches are never built in the dyld shared cache.</span></pre></td></tr><tr><td class="code"><pre><span class="line">static inline mask_t cache_hash(cache_key_t key, mask_t mask) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return (mask_t)(key &amp; mask);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; cache_next()</span></pre></td></tr><tr><td class="code"><pre><span class="line">#if __arm__  ||  __x86_64__  ||  __i386__</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_msgSend has few registers available.</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Cache scan increments and wraps at special end-marking bucket.</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define CACHE_END_MARKER 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return (i+1) &amp; mask;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#elif __arm64__</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_msgSend has lots of registers available.</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Cache scan decrements. No end marker needed.</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define CACHE_END_MARKER 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return i ? i-1 : mask;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="code"><pre><span class="line">#error unknown architecture</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr></table></figure>

<p>前面的几个方法一直围绕 插入缓存和重新开辟新的缓存区域做处理, 那么既然存储进去了肯定有读取的地方。下面我们来看看 <code>find()</code> 是如何实现读取的</p>
<p><strong>注意: 在这里我们终于发现 bucket_t 到底是什么了, 他起始是一个 哈希表(散列表), 所以里面存储的数据是随机存储的</strong></p>
<ul>
<li>先通过 <code>buckets()</code> 方法, 获取到的 <code>_buckets</code> ; 使用 <code>mask()</code> 获取到 <code>_mask</code></li>
<li>调用 <code>cache_hask()</code> 也就是 <code>key &amp; mask</code> 得到一个起始的索引 <code>begin</code></li>
<li>将 <code>begin</code> 赋值给 <code>i</code> , 进行一个 <code>do-while</code> 循环, 看一下循环的条件 <code>cache_next()</code> , 这里其实是在做 <code>i-1</code> 操作, 当 <code>i-1</code> 为 <code>0</code> 时, 返回的是 <code>mask</code> (也就是最后一个元素) , 然后进行反向循环, 从而达到查询每一个元素</li>
<li>最后如果在这过程中找到就没有问题, 如果一直执行到 <strong>回到 begin</strong> 都没有找到, 就继续往下走调用 <code>bad_cache</code> 错误处理</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此我们对 <code>cache_t</code> 的探索基本结束了, 下面一起来总结一下关于 <code>cache</code> 都有哪些内容:</p>
<ol>
<li><p><code>cache_t</code> 是对的实例方法进行的缓存操作, 包含 <code>_mask</code> 、<code>_occupied</code> 和 <code>_buckets</code> 三部分</p>
</li>
<li><p><code>mask</code> 的大小为 <em>缓存容量的大小 - 1</em> , 主要使用在查找缓存时的 哈希算法 中; <code>occupied</code> 存储的是 <em>缓存的方法的数量</em></p>
</li>
<li><p><code>capacity</code> 可以通过 <code>capacity()</code> 方法获取到, 表示当前缓存的大小, 初始大小为 <strong>4</strong> , 如果进行 <code>cache_fill_nolock()</code> 缓存操作时, 判断到缓存后的 <code>occupied</code> 大于 <code>capacity</code> 的 <strong>四分之三</strong> , 就会对其进行扩容为原来的 <strong>2倍</strong></p>
<p><strong><em>至于为什么是 四分之三扩容, 这里牵扯到哈希冲突, 有兴趣的可以去网上搜索一下</em></strong></p>
</li>
<li><p>还有一点需要说明的是在进行扩容以后, <strong>系统将之前的缓存数据全部清除了</strong>, 这里涉及到 <strong>LRU算法 (最近最少使用原则)</strong> 。</p>
<p>这里我觉得应该算是相似吧, 因为我们这里是在扩容之后把 <strong>之前的所有数据删除</strong>, 而 <strong>LRU</strong>的原则是 <strong>当空间存满时, 把最久没有被访问到的数据淘汰</strong> 。</p>
<p><strong><em>因为对算法不是很熟悉, 关于这一点, 希望能有大佬帮我解惑一下, 是不是这样字的。</em></strong></p>
</li>
</ol>
<p>以上就是本次的全部内容了, 如果有什么不足的地方或者有疑问的地方, 欢迎各大佬指正和提出。</p>
]]></content>
      <categories>
        <category>iOS底层学习</category>
      </categories>
      <tags>
        <tag>iOS探索</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS探索之--类的结构分析(一)</title>
    <url>/2020-03-21-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90(%E4%B8%80)/</url>
    <content><![CDATA[<blockquote>
<p> 在前面的几篇文章对 <code>iOS</code> 对象的原理进行了探索, 那么类在底层的实现又是什么样子的呢? 类是以什么样的形式存在的? 他的结构又是什么样子的呢? 接下来我们一起来展开对类的一些相关内容探索, 看一下他的真面目。</p>
</blockquote>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><blockquote>
<p> 说到 <code>类</code> , 我相信看这篇文章的人都不会陌生, 那么什么是类呢? </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类 (Class) 是面向对象程序设计 (OOP, Object-Oriented Programming) 实现信息封装的基础。类是一种用户自定义的数据类型,</span></pre></td></tr><tr><td class="code"><pre><span class="line">也称类类型。每个类包含数据说明和一组操作数据或传递信息的函数(或者方法)。类的实例称为对象。</span></pre></td></tr></table></figure>

<p>在我们 <code>iOS</code> 中, 我们知道大多数情况下我们使用的类都是从 <code>NSObject</code> 这个基类所派生出来的, 在 <code>OC</code> 的底层, 我们的类到底是什么样子的呢? 接下来开始我们的探索:</p>
<ol>
<li>首先在我们的工程里面去尝试直接点进去查看一下, 看看能不能有什么发现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Class</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.</span></pre></td></tr><tr><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_class</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct objc_class &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#if !__OBJC2__</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; OBJC2_UNAVAILABLE;</span></pre></td></tr></table></figure>

<p>查看 <code>Class</code> , 发现有一个关于他的结构体定义, 可以看出 <code>Class</code> 本质其实是一个 <code>objc_class</code> 类型的 <strong>结构体指针</strong>。然后我们继续去查看关于 <code>objc_class</code> 的相关内容, 发现了关于该结构体的一些声明, 但是有一个东西需要注意 <code>OBJC2_UNAVAILABLE</code> , 从该宏定义的名字可以看出, 这个定义在我们的 <code>OBJC2</code> 中已经废弃掉了。</p>
<blockquote>
<p>关于 <code>OBJC2_UNAVAILABLE</code> 的宏定义, 我在 <code>objc</code> 源码中找到了 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&#x2F;* OBJC2_UNAVAILABLE: unavailable in objc 2.0, deprecated in Leopard *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;#if !defined(OBJC2_UNAVAILABLE)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;#   if __OBJC2__</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;#       define OBJC2_UNAVAILABLE UNAVAILABLE_ATTRIBUTE</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;#   else</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#x2F;* plain C code also falls here, but this is close enough *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;#       define OBJC2_UNAVAILABLE                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">           __OSX_DEPRECATED(10.5, 10.5, &quot;not available in __OBJC2__&quot;) \</span></pre></td></tr><tr><td class="code"><pre><span class="line">           __IOS_DEPRECATED(2.0, 2.0, &quot;not available in __OBJC2__&quot;)   \</span></pre></td></tr><tr><td class="code"><pre><span class="line">           __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE __BRIDGEOS_UNAVAILABLE</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;#   endif</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;#endif</span></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li>很显然我们没有办法去直接查看 <code>objc_class</code> , 接下来我们去之前一直在使用的 <code>objc</code> 源码中去搜索一下, 发现了新的声明</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_class (一个隐藏的 ISA), 继承自 objc_object</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Class ISA; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class superclass; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span></pre></td></tr><tr><td class="code"><pre><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;*</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...一大堆函数</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_object (包含 isa)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class.</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct objc_object &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>在源码中我们找到了新的 <code>objc_class</code> 定义, 发现他继承自 <code>objc_object</code> , 并且 <code>isa</code> 也是从 <code>objc_object</code> 继承过来的, 并没有自己去定义。然后从继承关系上我们还可以得出, <strong>类其实也是一种对象</strong>, 他也有自己的 <code>isa</code> , 并且指向 <strong>元类</strong>。</p>
<blockquote>
<p><strong>万物皆对象</strong></p>
<p>每个实例对象都有个 isa 指针, 指向对象的 (Class)类; 而类对象里也有个 isa 指针, 指向的是 meteClass(元类)。关于 isa 的指向可以去看看我之前的文章 <a href="https://juejin.im/post/5e69972fe51d4527086b4e67" target="_blank" rel="noopener">iOS探索–isa的初始化和指向分析</a></p>
</blockquote>
<h2 id="类的结构分析"><a href="#类的结构分析" class="headerlink" title="类的结构分析"></a>类的结构分析</h2><p>在上面的过程中我们找到了关于类的定义, 接下来我们具体看看类的结构是什么样子的? 每一部分的作用又是什么? (注意, 这里内存占用情况默认为 64位情况下)</p>
<h3 id="1-Class-isa"><a href="#1-Class-isa" class="headerlink" title="1. Class isa"></a>1. Class isa</h3><p>类对象中的 <code>isa</code> 指针, 用于关联 <code>元类</code> , 关于这一点在之前的 <code>isa</code> 指向流程图中可以看出来。<code>Class</code> 类型是一个指针, 所以 <code>isa</code> 占用 8 字节。</p>
<h3 id="2-Class-superclass"><a href="#2-Class-superclass" class="headerlink" title="2. Class superclass"></a>2. Class superclass</h3><p>根据名字应该可以看出来表示 <code>当前类的父类</code> ,同样是 <code>Class</code> 类型, 所以 <code>superclass</code> 也占 8 个字节。</p>
<h3 id="3-cache-t-cache"><a href="#3-cache-t-cache" class="headerlink" title="3. cache_t cache"></a>3. cache_t cache</h3><p>缓存, 用于缓存已经调用的方法, 可以加速方法的调用, 具体分析我们放的以后。接下来分析一下他的内存占用情况:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct cache_t &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    struct bucket_t *_buckets; &#x2F;&#x2F; 8</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mask_t _mask;  &#x2F;&#x2F; 4</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mask_t _occupied; &#x2F;&#x2F; 4</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  	&#x2F;*</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	一堆函数...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	*&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#if __LP64__</span></pre></td></tr><tr><td class="code"><pre><span class="line">typedef uint32_t mask_t;  &#x2F;&#x2F; x86_64 &amp; arm64 asm are less efficient with 16-bits</span></pre></td></tr><tr><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="code"><pre><span class="line">typedef uint16_t mask_t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#ifndef _UINT32_T</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define _UINT32_T</span></pre></td></tr><tr><td class="code"><pre><span class="line">typedef unsigned int uint32_t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif &#x2F;* _UINT32_T *&#x2F;</span></pre></td></tr></table></figure>

<p>可以看出, <code>cache_t</code> 结构体包含 一个结构体指针和两个 <code>mask_t</code> 类型的成员变量, 且 <code>mask_t</code> 在 64位情况下位 int 类型。所以 <code>cache</code> 部分总共占用内存为 16 位。</p>
<h3 id="4-class-data-bits-t-bits"><a href="#4-class-data-bits-t-bits" class="headerlink" title="4. class_data_bits_t bits"></a>4. class_data_bits_t bits</h3><p>可以看出 <code>bits</code> 也是一个结构体类型, 但是当我们去查看 <code>objc_class</code> 里面的函数时, 会发现很多地方都跟 <code>bits</code> 有关。然后我们去查看 <code>bits</code> 的函数实现, 发现了一个有趣的东西, 内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class_rw_t* data() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct class_rw_t &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint32_t flags;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint32_t version;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    const class_ro_t *ro;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    method_array_t methods;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    property_array_t properties;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    protocol_array_t protocols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class firstSubclass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class nextSiblingClass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    char *demangledName;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#if SUPPORT_INDEXED_ISA</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint32_t index;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	&#x2F;*</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	...函数</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	*&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在 <code>class_data_bits_t</code> 的 <code>data()</code> 函数返回了一个 <code>class_rw_t</code> 类型的指针对象, 然后我们在 <code>class_rw_t</code> 结构体里面发现了一些我们很熟悉的东西 <code>methods</code>、<code>properties</code>、<code>protocols</code> 等。难道我们的类声明的方法、属性等存储在这里面吗, 所以后面我们来一起着重对这个 <code>bits</code> 来进行研究。</p>
<h2 id="类的结构探究"><a href="#类的结构探究" class="headerlink" title="类的结构探究"></a>类的结构探究</h2><h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h3><p>开始探究之前, 我们先回到我们的 <code>objc</code> 源码里面, 新建一个 <code>target</code> , 新建一个 <code>Person</code> 类, 然后开始我们的探索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 类</span></pre></td></tr><tr><td class="code"><pre><span class="line">@interface Person : NSObject &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSString *name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *sex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, assign) NSInteger age;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">+ (void)person_sayHello;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)person_study;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@end</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.m</span></pre></td></tr><tr><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @autoreleasepool &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; insert code here...</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Person *person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class pClass &#x3D; object_getClass(person);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        NSLog(@&quot;%@&quot;, pClass);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p><strong>类和元类的创建时机</strong></p>
</blockquote>
<p>开始之前我们先看一个东西, 在方法执行之前打一个断点, 然后对我们的 <code>Person</code> 类进行打印, 看一下是否存在。</p>
<p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-1.png" alt="类的结构分析(一)"></p>
<p>如上图所示, 此时我们的 <code>person</code> 对象还没有被创建, 但是我们对 <code>Person</code> 的类对象进行打印, 发现已经存在在内存当中了。所以在类进行 <code>alloc</code> 操作之前, 类和元类就已经存在了, 说明类和元类在编译时期就已经被创建了。</p>
<h3 id="2-bits-探索"><a href="#2-bits-探索" class="headerlink" title="2. bits 探索"></a>2. bits 探索</h3><p>想要去探索 <code>bits</code> , 我们首先要解决如何找到他的问题, 然后才能在内存中对其结构进行一一分析。在上面的结构分析中我们知道, <code>objc_class</code> 内部一共包含 <code>isa</code>、<code>superclass</code>、<code>cache</code> 和 <code>bits</code> 组成, 前面的三位总共占 32 位, 那么我们接下来就借助指针平移来找到 <code>bits</code> 。</p>
<ul>
<li><strong>找到 bits 的内存地址</strong></li>
</ul>
<p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-2.png" alt="类的结构分析(一)"></p>
<p>!<img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-3.png" alt="类的结构分析(一)"></p>
<p>通过指针平移后得到新的地址, 然后进行打印验证得出 <code>bits</code> 的指针地址。</p>
<ul>
<li><strong>关于 class_rw_t</strong></li>
</ul>
<p>找到了 <code>bits</code> , 我们上面提到过, <code>bits</code> 可以通过 <code>data()</code> 函数返回一个 <code>class_rw_t</code> 类型的指针对象。所以为了去查看 <code>class_rw_t</code> 的结构, 我们继续往下面走</p>
<p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-4.png" alt="类的结构分析(一)"></p>
<p>上面我们通过 <code>data()</code> 函数得到了 <code>class_rw_t</code> 类型的指针, 然后又通过打印发现, 果然是我们想要找的内容, 在里面也发现了我们想要寻找的 <code>methods</code> 、<code>properties</code> 和 <code>protocols</code>  。接下来一起看看我们的 属性 和 方法是否在这里面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 关于指针前面的 &quot; * &quot; 符号</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 对于指针而言, 星号一般出现的场合, 一个是指针定义时, 另一个是使用指针时。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">1. int *p</span></pre></td></tr><tr><td class="code"><pre><span class="line">指针定义时前面的星号, 目的是告诉编译器变量 p 是一个指针</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">2. *p + 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">使用指针时, 可以理解为 指针的值, 比如上面这里就是 指针指向的值 加上 1 。</span></pre></td></tr></table></figure>



<p><strong>1. properties 分析</strong></p>
<p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-5.png" alt="类的结构分析(一)"></p>
<p>首先我们直接打印 <code>properties</code> , 发现内部存储的是一个 <code>list_array_tt</code> 类型的东西, 然后打印他的 <code>list</code>, 发现他是一个 <code>property_list_t</code> 类型的指针, 进行值打印, 又出来一个 <code>entsize_list_tt</code> , 下面是 <code>entsize_list_tt</code> 的声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 泛型</span></pre></td></tr><tr><td class="code"><pre><span class="line">template &lt;typename Element, typename List, uint32_t FlagMask&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; entsize_list_tt 的声明</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct entsize_list_tt &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint32_t entsizeAndFlags;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint32_t count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Element first;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint32_t entsize() const &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return entsizeAndFlags &amp; ~FlagMask;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint32_t flags() const &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return entsizeAndFlags &amp; FlagMask;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Element&amp; getOrEnd(uint32_t i) const &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert(i &lt;&#x3D; count);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return *(Element *)((uint8_t *)&amp;first + i*entsize()); </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Element&amp; get(uint32_t i) const &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert(i &lt; count);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return getOrEnd(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    size_t byteSize() const &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return byteSize(entsize(), count);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  	&#x2F;*</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	一些函数...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	*&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如上, 关于 <code>template</code> 好像是 <code>C++</code> 里面的东西, 用来做泛型编程的, 有兴趣的可以去查询一下。关于 <code>entsizeAndFlags</code> 和 <code>count</code> 可以直接打印出来, 重要的是 <code>first</code> , 然后发现有两个函数 <code>getOrEnd() 和 get()</code> , 尝试调用之后发现真的可以得到与我们的属性相关的东西。<strong>但是, 没有找到我们的成员变量。</strong></p>
<p><strong>2. methods</strong></p>
<p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-6.png" alt="类的结构分析(一)"></p>
<p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-7.png" alt="类的结构分析(一)"></p>
<p>打印结果如上图, 过程跟 第1步的 <code>properties</code> 一样, 这里不做描述了。可以看到我们定义的 实例方法 和 属性的 <code>getter,setter</code> 方法都可以找到, 除此之外还有一个 <code>C++</code> 的析构函数 <code>.cxx_destruct</code> 。<strong>但是, 我们的类方法没有在里面</strong></p>
<p><strong>3. 关于 ro</strong></p>
<p>为了寻找我们的 <code>类方法</code> 和 <code>成员变量</code> , 我们继续对 <code>class_rw_t</code> 的结构进行查看, 发现最有可能在的地方只有可能是 <code>ro</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ro </span></pre></td></tr><tr><td class="code"><pre><span class="line">struct class_ro_t &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint32_t flags;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint32_t instanceStart;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint32_t instanceSize;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#ifdef __LP64__</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint32_t reserved;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line">    const uint8_t * ivarLayout;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    const char * name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    method_list_t * baseMethodList;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    protocol_list_t * baseProtocols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    const ivar_list_t * ivars;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    const uint8_t * weakIvarLayout;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    property_list_t *baseProperties;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    method_list_t *baseMethods() const &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return baseMethodList;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>在其内部我们同样发现了关于方法和属性的东西 <code>baseMethodList</code>、<code>baseProperties</code> , 还有一个新的东西 <code>ivars</code> , 接下来我们来打印一下里面到底有什么吧 (过程省略, 直接上图):</p>
<p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-8.png" alt="类的结构分析(一)"></p>
<p>从打印结果可以看出, 不只是我们声明的成员变量, 属性自动生成的带 “_” 的成员变量也在其中, 所以成员变量存在于 <code>ro</code> 下面的 <code>ivars</code> 中。</p>
<p><strong>注意: 此处省略了对 <code>baseMethodList</code> 和 <code>baseProperties</code> 的打印, 有兴趣的可以去自己试一下, 你会发现这里同样存储着我们所定义的 实例方法 和 属性, 至于为什么我们留到以后解答。</strong></p>
<p> <strong>4. 总结</strong></p>
<p>经过上面的探索, 我们发现在 <code>class_rw_t</code> 里面可以找到我们在类中定义的 <strong>属性</strong> 和 <strong>实例方法</strong> , 但是无法找到 <strong>成员变量</strong>。<br>然后在 <code>ro</code> 里面可以找到我们的 <strong>成员变量</strong>, 同样也可以找到我们的 <strong>属性</strong> 和 <strong>实例方法</strong>。那么为什么这里他们两个都会存储 <strong>属性</strong> 和 <strong>实例方法</strong>, 这些我们放到下一期来讨论。 <a href>正在补作业中…敬请期待…</a></p>
<h3 id="3-类方法的存储位置"><a href="#3-类方法的存储位置" class="headerlink" title="3. 类方法的存储位置"></a>3. 类方法的存储位置</h3><p>前面我们一起找到了 <strong>属性</strong> 、<strong>实例方法</strong> 和 <strong>成员变量</strong> , 那么 <strong>类方法</strong> 到底存储在哪里呢? 接下来我们借助 <code>runtime</code> 的 API 来一起测试一下。</p>
<h4 id="1-作为实例方法"><a href="#1-作为实例方法" class="headerlink" title="1. 作为实例方法"></a>1. 作为实例方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; + (void)person_sayHello;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; - (void)person_study;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">const char *className &#x3D; object_getClassName(pClass);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Class metaClass &#x3D; objc_getMetaClass(className);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Method method1 &#x3D; class_getInstanceMethod(pClass, @selector(person_sayHello));</span></pre></td></tr><tr><td class="code"><pre><span class="line">Method method2 &#x3D; class_getInstanceMethod(metaClass, @selector(person_sayHello));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Method method3 &#x3D; class_getInstanceMethod(pClass, @selector(person_study));</span></pre></td></tr><tr><td class="code"><pre><span class="line">Method method4 &#x3D; class_getInstanceMethod(metaClass, @selector(person_study));</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%p-%p-%p-%p&quot;,method1,method2,method3,method4);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">打印结果:</span></pre></td></tr><tr><td class="code"><pre><span class="line">0x0-0x100001108-0x100001170-0x0</span></pre></td></tr></table></figure>

<p>根据上面打印结果可以总结如下:</p>
<ul>
<li><code>person_sayHello</code> 是 <strong>元类对象</strong>的实例方法, 所以存在于<strong>元类</strong>当中, 不存在<strong>类</strong></li>
<li><code>person_study</code> 是<strong>类对象</strong>的实例方法, 所以存在于<strong>类</strong>当中, 不存在<strong>元类</strong></li>
</ul>
<h4 id="2-作为类方法"><a href="#2-作为类方法" class="headerlink" title="2. 作为类方法"></a>2. 作为类方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; + (void)person_sayHello;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; - (void)person_study;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">const char *className &#x3D; object_getClassName(pClass);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Class metaClass &#x3D; objc_getMetaClass(className);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Method method1 &#x3D; class_getClassMethod(pClass, @selector(person_sayHello));</span></pre></td></tr><tr><td class="code"><pre><span class="line">Method method2 &#x3D; class_getClassMethod(metaClass, @selector(person_sayHello));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Method method3 &#x3D; class_getClassMethod(pClass, @selector(person_study));</span></pre></td></tr><tr><td class="code"><pre><span class="line">Method method4 &#x3D; class_getClassMethod(metaClass, @selector(person_study));</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%p-%p-%p-%p&quot;,method1,method2,method3,method4);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">打印结果:</span></pre></td></tr><tr><td class="code"><pre><span class="line">0x100001108-0x100001108-0x0-0x0</span></pre></td></tr></table></figure>

<p>根据结果可以看出, 不管是类还是元类, 作为类方法去查找 <code>person_study</code> 方法时都无法获取到, 而去查找 <code>person_sayHello</code> 方法时又都找到了, 这里就有问题了, 那么我们进入到 <code>class_getClassMethod</code> 方法内部实现里去找一下答案:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Method class_getClassMethod(Class cls, SEL sel) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (!cls  ||  !sel) return nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return class_getInstanceMethod(cls-&gt;getMeta(), sel);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Class getMeta() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  if (isMetaClass()) return (Class)this;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  else return this-&gt;ISA();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">inline Class </span></pre></td></tr><tr><td class="code"><pre><span class="line">objc_object::ISA() </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert(!isTaggedPointer()); </span></pre></td></tr><tr><td class="code"><pre><span class="line">#if SUPPORT_INDEXED_ISA</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (isa.nonpointer) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        uintptr_t slot &#x3D; isa.indexcls;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return classForIndex((unsigned)slot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return (Class)isa.bits;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return (Class)(isa.bits &amp; ISA_MASK);</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到 <code>class_getClassMethod</code> 方法的内部其实也是在调用 <code>class_getInstanceMethod</code> 方法, 不同点在于 <code>getMeta()</code> 方法, 可以看到如果是<strong>元类</strong>调用会直接返回; 如果是<strong>类</strong>调用的话, 会返回 <code>ISA()</code> , 也就是<strong>元类</strong>, 所以不管是在<strong>类</strong>中查找 <code>person_sayHello</code> 方法, 还是在<strong>元类</strong>中查找, 其结果是一样的。</p>
<blockquote>
<p><strong>所以, 我们的类方法是存储在元类中的, 实例方法是存储在类中的</strong></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次探索对类进行了一系列的研究, 总结如下:</p>
<ol>
<li>我们发现类其实也是一个对象, 并且类和元类是在编译时就创建的。</li>
<li>对类的结构进行了分析, 并且在 <code>class_rw_t</code> 和 <code>ro</code> 里面找到了我们的 <code>属性</code> 和 <code>实例方法</code>, 仅在 <code>ro</code> 中找到了我们的 <code>成员变量</code>。</li>
<li>然后后面又对 <code>类方法</code> 的存储位置进行了探索, 发现类方法是存在元类中的。</li>
</ol>
<p>最后希望本次的探索对你有所启发, 如果有不对的地方还请各位指出, 谢谢大家。</p>
]]></content>
      <categories>
        <category>iOS底层学习</category>
      </categories>
      <tags>
        <tag>iOS探索</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS探索之--isa 的初始化和指向分析</title>
    <url>/2020-03-12-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--isa%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%8C%87%E5%90%91%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的研究中我们大概知道了对象创建和分配内存的过程, 但是在这中间有一个东西还没有去注意。那就是对象的 <code>isa</code> 属性, 我们只是知道在过程中有伴随着它的一系列初始化操作, 但是这个过程中为什么要创建 <code>isa</code> 呢 ? 这就是此次我们要研究的目的。</p>
<h2 id="isa-的初始化-和-结构分析"><a href="#isa-的初始化-和-结构分析" class="headerlink" title="isa 的初始化 和 结构分析"></a>isa 的初始化 和 结构分析</h2><h3 id="1-isa-初始化"><a href="#1-isa-初始化" class="headerlink" title="1. isa 初始化"></a>1. isa 初始化</h3><p>在之前的 <a href="https://juejin.im/post/5e0220c3f265da339f7d025f" target="_blank" rel="noopener">alloc流程分析</a> 中我们从 <code>objc</code> 源码中看到过对 <code>isa</code> 的初始化过程, 下面我们回过去重新看一下当时的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; callAlloc 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj-&gt;initInstanceIsa(cls, dtor);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; </span></pre></td></tr><tr><td class="code"><pre><span class="line">inline void </span></pre></td></tr><tr><td class="code"><pre><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert(!cls-&gt;instancesRequireRawIsa());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert(hasCxxDtor &#x3D;&#x3D; cls-&gt;hasCxxDtor());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    initIsa(cls, true, hasCxxDtor);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化具体实现</span></pre></td></tr><tr><td class="code"><pre><span class="line">inline void </span></pre></td></tr><tr><td class="code"><pre><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert(!isTaggedPointer()); </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (!nonpointer) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        isa.cls &#x3D; cls;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert(!DisableNonpointerIsa);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert(!cls-&gt;instancesRequireRawIsa());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        isa_t newisa(0);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#if SUPPORT_INDEXED_ISA</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assert(cls-&gt;classArrayIndex() &gt; 0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        newisa.bits &#x3D; ISA_INDEX_MAGIC_VALUE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span></pre></td></tr><tr><td class="code"><pre><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        newisa.indexcls &#x3D; (uintptr_t)cls-&gt;classArrayIndex();</span></pre></td></tr><tr><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="code"><pre><span class="line">        newisa.bits &#x3D; ISA_MAGIC_VALUE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span></pre></td></tr><tr><td class="code"><pre><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        newisa.shiftcls &#x3D; (uintptr_t)cls &gt;&gt; 3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; This write must be performed in a single store in some cases</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; (for example when realizing a class because other threads</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; may simultaneously try to use the class).</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; fixme use atomics here to guarantee single-store and to</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; guarantee memory order w.r.t. the class index table</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; ...but not too atomic because we don&#39;t want to hurt instantiation</span></pre></td></tr><tr><td class="code"><pre><span class="line">        isa &#x3D; newisa;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从对象创建过程中方法的调用我们不难发现, <code>nonpointer</code> 被默认传的 <code>true</code> 。然后下面的一些判断操作可以理解为对 <code>isa</code> 的一系列的赋值操作。还有重要的一点, 我们可以看到 <code>isa</code> 的类型为 <code>isa_t</code> 类型, 下面我们来看一看这个类型到底是什么。</p>
<blockquote>
<p><strong>补充: 关于Tagged Pointer</strong></p>
<p>我们可以在 WWDC2013 的《Session 404 Advanced in Objective-C》视频中，看到苹果对于Tagged Pointer特点的介绍：</p>
<ol>
<li>Tagged Pointer 专门用来存储小的对象，例如 NSNumber, NSDate, NSString。</li>
<li>Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free 。</li>
<li>在内存读取上有着 3 倍的效率，创建时比以前快 106 倍。</li>
</ol>
<p>有兴趣的可以去看看这两篇文章 <a href="https://www.jianshu.com/p/e354f9137ba8" target="_blank" rel="noopener">iOS Tagged Pointer</a> , <a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/" target="_blank" rel="noopener">深入理解 Tagged Pointer</a> 。</p>
</blockquote>
<h3 id="2-isa-的结构分析"><a href="#2-isa-的结构分析" class="headerlink" title="2. isa 的结构分析"></a>2. isa 的结构分析</h3><p>在分析结构之前, 我们首先了解两个概念, <code>联合体</code> 和 <code>位域</code>。</p>
<ol>
<li>联合体 (<code>union</code>)</li>
</ol>
<p>在进行某些算法的C语言编程的时候，需要使几种不同类型的变量存放到同一段<a href="https://baike.baidu.com/item/内存单元/7914266" target="_blank" rel="noopener">内存单元</a>中。也就是使用覆盖技术，几个变量互相覆盖。这种几个不同的变量共同占用一段内存的结构，在C语言中，被称作“<a href="https://baike.baidu.com/item/共用体/3874970" target="_blank" rel="noopener">共用体</a>”类型结构，简称共用体，也叫联合体。<a href="https://baike.baidu.com/item/联合体" target="_blank" rel="noopener">(出自百度百科联合体)</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 联合体是一个结构</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. 它的所有成员相对于首地址的偏移量都为 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. 长度取决于各成员中最长的长度</span></pre></td></tr><tr><td class="code"><pre><span class="line">4. 各变量是“互斥”的——共用一个内存首地址，联合变量可被赋予任一成员值,但每次只能赋一种值, 赋入新值则冲去旧值</span></pre></td></tr></table></figure>

<ol start="2">
<li>位域</li>
</ol>
<p>位域是指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。 (选自:<a href="https://baike.baidu.com/item/位段?fromtitle=位域&fromid=9215688" target="_blank" rel="noopener">百度百科</a>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 联合体</span></pre></td></tr><tr><td class="code"><pre><span class="line">union isa_t &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    isa_t() &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class cls;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uintptr_t bits;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#if defined(ISA_BITFIELD)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    struct &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ISA_BITFIELD;  &#x2F;&#x2F; defined in isa.h  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  ISA_BITFIELD 的定义</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  位域</span></pre></td></tr><tr><td class="code"><pre><span class="line"># if __arm64__</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   define ISA_BITFIELD                                                      \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t nonpointer        : 1;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t has_assoc         : 1;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t has_cxx_dtor      : 1;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t shiftcls          : 33; &#x2F;*MACH_VM_MAX_ADDRESS 0x1000000000*&#x2F; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t magic             : 6;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t weakly_referenced : 1;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t deallocating      : 1;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t has_sidetable_rc  : 1;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t extra_rc          : 19</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   define RC_ONE   (1ULL&lt;&lt;45)</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   define RC_HALF  (1ULL&lt;&lt;18)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># elif __x86_64__</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   define ISA_BITFIELD                                                      \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t nonpointer        : 1;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t has_assoc         : 1;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t has_cxx_dtor      : 1;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t shiftcls          : 44; &#x2F;*MACH_VM_MAX_ADDRESS 0x7fffffe00000*&#x2F; \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t magic             : 6;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t weakly_referenced : 1;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t deallocating      : 1;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t has_sidetable_rc  : 1;                                       \</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uintptr_t extra_rc          : 8</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   define RC_ONE   (1ULL&lt;&lt;56)</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   define RC_HALF  (1ULL&lt;&lt;7)</span></pre></td></tr></table></figure>

<p>可以发现, <code>isa_t</code> 就是一个 <code>联合体</code> 类型, 至于 <code>ISA_BITFIELD</code> 从后面的宏定义可以看出是一个 <code>位域</code>, 所以 <code>isa</code> 的实际类型是一个 <code>联合体</code>, 并且在联合体内部包含一个 <code>位域</code>, 用来存储不同的信息。</p>
<p>下面我们来展开分析一下:</p>
<ol>
<li><p>首先是两个构造函数 <code>isa_t(), isa_t(unitptr_value)</code> 。</p>
</li>
<li><p>然后是三个数据成员 <code>Class cls</code>, <code>unitptr_t bits</code>, <code>struct</code> 。其中 <code>unitptr_t</code> 被定义为 <code>typedef unsigned long uintptr_t</code> , 占64位。 </p>
<p>关于 <code>uintptr_t bits</code> 和 <code>struct</code> , 这两个其实可以看出一个成员, 首先他们都占据 64 位内存空间, 并且联合里面的空间是重叠的, 所以他们两个的内存空间是完全重叠的。即 <code>uintptr_t bits</code> 和 <code>struct</code> 是一个东西的两种表现形式。</p>
<p>实际上在 <code>runtime</code> 中，任何对 <code>struct</code>  的操作和获取某些值，如 <code>extra_rc</code>，实际上都是通过对 <code>uintptr_t bits</code>  做位操作实现的。<code>uintptr_t bits</code> 和 <code>struct</code> 的关系可以看做，<code>uintptr_t bits</code> 向外提供了操作 <code>struct</code>  的接口，而 <code>struct</code> 本身则说明了 <code>uintptr_t bits</code>  中各个二进制位的定义。</p>
<p>所以 <code>isa_t</code> 其实可以看做有两个可能的值, <code>Class cls</code> 或者 <code>struct</code> 。</p>
<p><a href="https://blog.csdn.net/u013378438/article/details/80733391" target="_blank" rel="noopener">内容出处:(Objective-C runtime机制(5)——iOS 内存管理)</a></p>
</li>
<li><p>当作为 <code>Class cls</code> 使用时, 就符合了我们一惯的认知, <code>isa</code> 是一个指向对象所属类的指针。但是一个 64位 的指针很显然不划算。所以大多数情况下苹果采用的是优化的 <code>isa</code> 策略, 即 <code>struct</code> 。</p>
</li>
<li><p>下面来看一下 <code>struct</code> 里面各个成员所起到的作用</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">成员</th>
<th align="center">位</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nonpointer</td>
<td align="center">1bit</td>
<td align="left">表示是否对 <strong>isa</strong> 指针开启指针优化 <strong>0</strong>:纯<strong>isa</strong>指针，<strong>1</strong>:不止是类对象地址<strong>,isa</strong> 中包含了类信息、对象的引用计数等</td>
</tr>
<tr>
<td align="center">has_assoc</td>
<td align="center">1bit</td>
<td align="left">关联对象标志位，<strong>0</strong>没有，<strong>1</strong>存在</td>
</tr>
<tr>
<td align="center">has_cxx_dtor</td>
<td align="center">1bit</td>
<td align="left">该对象是否有 <strong>C++</strong> 或者 <strong>Objc</strong> 的析构器<strong>,</strong>如果有析构函数<strong>,</strong>则需要做析构逻辑<strong>,</strong> 如果没有<strong>,</strong>则可以更快的释放对象</td>
</tr>
<tr>
<td align="center">shiftcls</td>
<td align="center">33bit</td>
<td align="left">存储类指针的值。开启指针优化的情况下，在 <strong>arm64</strong> 架构中有 <strong>33</strong> 位用来存储类指针。</td>
</tr>
<tr>
<td align="center">magic</td>
<td align="center">6bit</td>
<td align="left">固定为  0x1a, 用于调试器判断当前对象是真的对象还是没有初始化的空间</td>
</tr>
<tr>
<td align="center">weakly_referenced</td>
<td align="center">1bit</td>
<td align="left">指对象是否被指向或者曾经指向一个 <strong>ARC</strong> 的弱变量, 没有弱引用的对象可以更快释放。</td>
</tr>
<tr>
<td align="center">deallocating</td>
<td align="center">1bit</td>
<td align="left">标志对象是否正在释放内存</td>
</tr>
<tr>
<td align="center">has_sidetable_rc</td>
<td align="center">1bit</td>
<td align="left">当对象引用计数大于 <strong>19</strong> 位时，则需要借用该变量存储进位</td>
</tr>
<tr>
<td align="center">extra_rc</td>
<td align="center">19bit</td>
<td align="left">当表示该对象的引用计数值，实际上是引用计数值减 <strong>1</strong>， 例如，如果对象的引用计数为 10，那么 <strong>extra_rc</strong> 为 9。如果引用计数大于 <strong>19</strong> 位， 则需要使用到上面的 <strong>has_sidetable_rc</strong>。</td>
</tr>
</tbody></table>
<p>以上就是对 <code>isa</code> 结构的分析, 具体的 <code>struct</code> 内部成员分析可以去看一下上面分享的链接。</p>
<h2 id="isa-的指向分析"><a href="#isa-的指向分析" class="headerlink" title="isa 的指向分析"></a>isa 的指向分析</h2><h3 id="1-class-objc-getClass-与-object-getclass-的区别"><a href="#1-class-objc-getClass-与-object-getclass-的区别" class="headerlink" title="1. class , objc_getClass () 与 object_getclass () 的区别 ?"></a>1. class , objc_getClass () 与 object_getclass () 的区别 ?</h3><p>开始分析 <code>isa</code> 指向之前, 我们首先了解一下上面这三个方法的区别是什么, 下面我们从 <code>objc</code> 源码里直接找到了上面方法的实现 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; class ()</span></pre></td></tr><tr><td class="code"><pre><span class="line">+ (Class)class &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return self;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (Class)class &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return object_getClass(self);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_getClass ()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span></pre></td></tr><tr><td class="code"><pre><span class="line">* objc_getClass.  Return the id of the named class.  If the class does</span></pre></td></tr><tr><td class="code"><pre><span class="line">* not exist, call _objc_classLoader and then objc_classHandler, either of </span></pre></td></tr><tr><td class="code"><pre><span class="line">* which may create a new class.</span></pre></td></tr><tr><td class="code"><pre><span class="line">* Warning: doesn&#39;t work if aClassName is the name of a posed-for class&#39;s isa!</span></pre></td></tr><tr><td class="code"><pre><span class="line">**********************************************************************&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Class objc_getClass(const char *aClassName)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (!aClassName) return Nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; NO unconnected, YES class handler</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return look_up_class(aClassName, NO, YES);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; object_getclass () </span></pre></td></tr><tr><td class="code"><pre><span class="line">Class object_getClass(id obj)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (obj) return obj-&gt;getIsa();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    else return Nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">inline Class </span></pre></td></tr><tr><td class="code"><pre><span class="line">objc_object::getIsa() </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (!isTaggedPointer()) return ISA();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uintptr_t ptr &#x3D; (uintptr_t)this;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (isExtTaggedPointer()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        uintptr_t slot &#x3D; </span></pre></td></tr><tr><td class="code"><pre><span class="line">            (ptr &gt;&gt; _OBJC_TAG_EXT_SLOT_SHIFT) &amp; _OBJC_TAG_EXT_SLOT_MASK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return objc_tag_ext_classes[slot];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        uintptr_t slot &#x3D; </span></pre></td></tr><tr><td class="code"><pre><span class="line">            (ptr &gt;&gt; _OBJC_TAG_SLOT_SHIFT) &amp; _OBJC_TAG_SLOT_MASK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return objc_tag_classes[slot];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">inline Class </span></pre></td></tr><tr><td class="code"><pre><span class="line">objc_object::ISA() </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert(!isTaggedPointer()); </span></pre></td></tr><tr><td class="code"><pre><span class="line">#if SUPPORT_INDEXED_ISA</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (isa.nonpointer) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        uintptr_t slot &#x3D; isa.indexcls;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return classForIndex((unsigned)slot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return (Class)isa.bits;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; ISA_MASK 掩码, 通过 &amp; 运算来获取到 isa 的指向信息</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; #   define ISA_MASK        0x00007ffffffffff8ULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return (Class)(isa.bits &amp; ISA_MASK); </span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从以上的源码实现我们可以总结如下:</p>
<ol>
<li>class 方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 当为实例方法时, 其返回与 object_getClass () 一致, 即当前对象的 isa 指向的类对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 2. 当为类方法时, 返回该类对象本身</span></pre></td></tr></table></figure>

<ol start="2">
<li>objc_getClass ( ) 方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 该方法的参数是一个字符串, 当我们传进去一个类名的字符串, 就会返回这个类的类对象</span></pre></td></tr></table></figure>

<ol start="3">
<li>object_getclass ( ) 方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据传入的参数获取 isa 指向, 需要说明的一点在于</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 当传入的是一个实例对象时, 获取到的是 类对象; 当传入的是一个类对象时, 获取到的是 元类</span></pre></td></tr></table></figure>





<h3 id="2-isa-指向分析"><a href="#2-isa-指向分析" class="headerlink" title="2. isa 指向分析"></a>2. isa 指向分析</h3><p>首先放上来自官方的指向图:</p>
<p><img src="/images/isa-1.png" alt="isa 的指向流程"></p>
<p>从标注可以看出, <code>实线箭头表示继承关系, 虚线箭头表示 isa 指向关系</code> , 然后从上图我们可以得出 <code>isa</code> 的指向顺序依次为: <strong>对象 –&gt; 类 –&gt; 元类 –&gt; 根元类 –&gt; 根元类</strong> 。下面我们来一起验证一下这个过程 (注: 此过程需要用到 lldb 相关打印命令, 有兴趣的可以去自己查询一下。) :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义两个类</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父类 : YJPerson</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子类 : YJTeacher</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; YJPerson类</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class class &#x3D; object_getClass(person);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; YJPerson元类</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class metaClass &#x3D; object_getClass(class);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; YJPerson根元类</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class rootMetaClass &#x3D; object_getClass(metaClass);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; YJPerson根根元类</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Class rootRootMetaClass &#x3D; object_getClass(rootMetaClass);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;\n%p 实例对象 %@\n%p 类 %@\n%p 元类 %@\n%p 根元类 %@\n%p 根根元类 %@&quot;,person,person,class,class,metaClass,metaClass,rootMetaClass,rootMetaClass,rootRootMetaClass,rootRootMetaClass);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意: 模拟器情况下是不会对 isa 进行优化的, 所以我们这里选择真机调试</span></pre></td></tr></table></figure>



<p>说明: 通过上面的 object_getclass ( ) 方法的内部实现, 我们可以了解到 可以直接通过 <code>isa &amp; ISA_MASK(掩码)</code> 来获取所指向的类, 所以我们下面的验证是通过采用这种方式进行的。 </p>
<p><img src="/images/isa-2.png" alt="isa 指向验证"></p>
<ol>
<li>首先通过上面介绍的方法一次获取到 <code>person</code> 对象的 类, 元类, 根元类和根根元类并将结果打印出来</li>
<li>然后通过 <code>lldb</code> 命令去读取 <code>person</code> 对象的内存情况, 我们知道内存中前 <code>8</code> 位存储的就是我们的 <code>isa</code>, 所以通过 <code>isa &amp; ISA_MASK</code> 方式来获取到 <code>isa</code> 指向的地址并将其打印</li>
<li>最后得出的结果如上图所示, 通过内存读取的结果与第1步打印的结果完全一致</li>
<li>还有最重要的一点, 可以发现我们的 <code>根元类</code> 与 <code>根根元类</code> 的地址其实是完全一样的, 然后查看流程图右上角的箭头指向得出结论: <strong>根元类以后的 isa 都是指向根元类本身</strong> 。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过此篇文章, 主要研究了 <code>isa</code> 相关的一些内容, 包括 <code>isa</code> 的结构组成和指向关系等, 期间也包含了一些内容的补充, 比如: Tagged Pointer、联合体、位域等。这次文章的内容到这里就结束了, 希望内容能对你有所帮助和启发, 如有不对的地方也请大佬们指正, 我们一起探讨共同进步。</p>
]]></content>
      <categories>
        <category>iOS底层学习</category>
      </categories>
      <tags>
        <tag>iOS探索</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS探索之--内存对齐原理分析</title>
    <url>/2020-02-19-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在探索 <a href="https://juejin.im/post/5e0220c3f265da339f7d025f#heading-7" target="_blank" rel="noopener">alloc流程</a> 的时候有关<code>内存对齐</code> 方面的内容没有去详细分析, 接下来在本文中着重对内存对齐方面的内容进行补充和继续探索。</p>
<h2 id="内存对齐的概念"><a href="#内存对齐的概念" class="headerlink" title="内存对齐的概念"></a>内存对齐的概念</h2><blockquote>
<p>首先我们要搞清楚什么是内存对齐 ?</p>
</blockquote>
<p><code>内存对齐 (Memory alignment)</code> , 也叫做字节对齐。计算机中的内存空间都是按照 byte 划分的, 从理论上讲对任何类型的变量的访问可以从任何地址开始, 但是实际情况下在访问特定类型变量的时候经常在特定的内存地址访问, 这就需要各类型数据按照一定的规则在空间上排列, 而不是按顺序的一个一个排放, 这就是内存对齐。<a href="https://baike.baidu.com/item/对齐" target="_blank" rel="noopener">参考自百度百科</a></p>
<blockquote>
<p>为什么要进行内存对齐 ?</p>
</blockquote>
<p>为了减少CPU访问内存的次数, 提高计算机性能, 一些计算机硬件平台要求存储在内存中的变量需要按照自然边界对齐。</p>
<ol>
<li>性能提升</li>
</ol>
<p>从内存占用的角度讲, 对齐以后比未对齐时有些情况反而增加了内存分配的开支, 是为了什么?</p>
<p>数据结构 (尤其是栈) 应该尽可能地在自然边界上对齐, 为了访问未对齐的内存, 处理器就需要做两次内存访问, 而对齐的内存访问只需要一次访问。重要的是提高内存系统的性能。</p>
<ol start="2">
<li>跨平台</li>
</ol>
<p>有些硬件平台并不能访问任意地址上的任意数据的，只能处理特定类型的数据，否则会导致硬件层级的错误。</p>
<p>有些CPU（如基于 Alpha，IA-64，MIPS，和 SuperH 体系的）拒绝读取未对齐数据。当一个程序要求这些 CPU 读取未对齐数据时，这时 CPU 会进入异常处理状态并且通知程序不能继续执行。</p>
<p>举个例子，在 ARM，MIPS，和 SH 硬件平台上，当操作系统被要求存取一个未对齐数据时会默认给应用程序抛出硬件异常。所以，如果编译器不进行内存对齐，那在很多平台的上的开发将难以进行。</p>
<h2 id="获取对象内存大小的方法"><a href="#获取对象内存大小的方法" class="headerlink" title="获取对象内存大小的方法"></a>获取对象内存大小的方法</h2><p>在研究内存对齐之前, 首先我们需要了解一下下面这三个方法的具体作用:</p>
<ul>
<li><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3></li>
</ul>
<p>他是一个操作符, 不是函数, 作用对象是数据类型, 主要作用于编译时。因此, 它作用于变量时, 同样是对其类型进行操作, 得到的结果是该数据类型占用空间的大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct test</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  int a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  double b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; MyTest;</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%zd&quot;, sizeof(MyTest));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 上面的结果得到 16, 需要考虑内存对齐问题, 关于内存对齐规则后面提到</span></pre></td></tr></table></figure>

<p>sizeof 只会计算类型所占用的内存大小, 不会关心具体的内存布局。(例如, 64位结构下, 我们自定义一个 NSObject 对象, 里面无论有多少个成员变量, 最后的结果都是 8)</p>
<ul>
<li><h3 id="class-getInstanceSize"><a href="#class-getInstanceSize" class="headerlink" title="class_getInstanceSize"></a>class_getInstanceSize</h3></li>
</ul>
<p>这是 <code>runtime</code> 提供的一个API, 用于获取类的实例对象所占用的内存大小, 返回具体的字节数。</p>
<p>我们通过在之前获取到的 objc4 源码中搜索该方法, 在 objc-class.mm 中找到了该方法的实现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_t class_getInstanceSize(Class cls)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (!cls) return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return cls-&gt;alignedInstanceSize();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Class&#39;s ivar size rounded up to a pointer-size boundary.</span></pre></td></tr><tr><td class="code"><pre><span class="line">uint32_t alignedInstanceSize() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return word_align(unalignedInstanceSize());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return (x + WORD_MASK) &amp; ~WORD_MASK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define WORD_MASK 7UL</span></pre></td></tr></table></figure>

<p>可以看出, 该方法会返回实例对象中成员变量的内存大小, 所以, <code>class_getInstanceSize</code> 就是获取实例对象中成员变量的内存大小。</p>
<ul>
<li><h3 id="malloc-size"><a href="#malloc-size" class="headerlink" title="malloc_size"></a>malloc_size</h3></li>
</ul>
<p>这个函数主要获取系统实际分配的内存大小, 具体的实现可以在libmalloc源码中找到。代码如下, 这里不做分析:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_t malloc_size(const void *ptr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	size_t size &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (!ptr) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		return size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	(void)find_registered_zone(ptr, &amp;size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">static inline malloc_zone_t *</span></pre></td></tr><tr><td class="code"><pre><span class="line">find_registered_zone(const void *ptr, size_t *returned_size)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; Returns a zone which contains ptr, else NULL</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (0 &#x3D;&#x3D; malloc_num_zones) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (returned_size) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			*returned_size &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		return NULL;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; first look in the lite zone</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (lite_zone) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		malloc_zone_t *zone &#x3D; lite_zone;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		size_t size &#x3D; zone-&gt;size(zone, ptr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (size) &#123; &#x2F;&#x2F; Claimed by this zone?</span></pre></td></tr><tr><td class="code"><pre><span class="line">			if (returned_size) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				*returned_size &#x3D; size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#x2F;&#x2F; Return the virtual default zone instead of the lite zone - see &lt;rdar:&#x2F;&#x2F;problem&#x2F;24994311&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			return default_zone;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; The default zone is registered in malloc_zones[0]. There&#39;s no danger that it will ever be unregistered.</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; So don&#39;t advance the FRZ counter yet.</span></pre></td></tr><tr><td class="code"><pre><span class="line">	malloc_zone_t *zone &#x3D; malloc_zones[0];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	size_t size &#x3D; zone-&gt;size(zone, ptr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (size) &#123; &#x2F;&#x2F; Claimed by this zone?</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (returned_size) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			*returned_size &#x3D; size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#x2F;&#x2F; Asan and others replace the zone at position 0 with their own zone.</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#x2F;&#x2F; In that case just return that zone as they need this information.</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#x2F;&#x2F; Otherwise return the virtual default zone, not the actual zone in position 0.</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (!has_default_zone0()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			return zone;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			return default_zone;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int32_t volatile *pFRZCounter &#x3D; pFRZCounterLive;   &#x2F;&#x2F; Capture pointer to the counter of the moment</span></pre></td></tr><tr><td class="code"><pre><span class="line">	OSAtomicIncrement32Barrier(pFRZCounter); &#x2F;&#x2F; Advance this counter -- our thread is in FRZ</span></pre></td></tr><tr><td class="code"><pre><span class="line">	unsigned index;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int32_t limit &#x3D; *(int32_t volatile *)&amp;malloc_num_zones;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	malloc_zone_t **zones &#x3D; &amp;malloc_zones[1];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; From this point on, FRZ is accessing the malloc_zones[] array without locking</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; in order to avoid contention on common operations (such as non-default-zone free()).</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; In order to ensure that this is actually safe to do, register&#x2F;unregister take care</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; to:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;   1. Register ensures that newly inserted pointers in malloc_zones[] are visible</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;      when malloc_num_zones is incremented. At the moment, we&#39;re relying on that store</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;      ordering to work without taking additional steps here to ensure load memory</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;      ordering.</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;   2. Unregister waits for all readers in FRZ to complete their iteration before it</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;      returns from the unregister call (during which, even unregistered zone pointers</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;      are still valid). It also ensures that all the pointers in the zones array are</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;      valid until it returns, so that a stale value in limit is not dangerous.</span></pre></td></tr><tr><td class="code"><pre><span class="line">	for (index &#x3D; 1; index &lt; limit; ++index, ++zones) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		zone &#x3D; *zones;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		size &#x3D; zone-&gt;size(zone, ptr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (size) &#123; &#x2F;&#x2F; Claimed by this zone?</span></pre></td></tr><tr><td class="code"><pre><span class="line">			goto out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; Unclaimed by any zone.</span></pre></td></tr><tr><td class="code"><pre><span class="line">	zone &#x3D; NULL;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	size &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">out:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (returned_size) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		*returned_size &#x3D; size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	OSAtomicDecrement32Barrier(pFRZCounter); &#x2F;&#x2F; our thread is leaving FRZ</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return zone;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="内存对齐的原则"><a href="#内存对齐的原则" class="headerlink" title="内存对齐的原则"></a>内存对齐的原则</h2><ul>
<li><h3 id="数据成员对齐规则"><a href="#数据成员对齐规则" class="headerlink" title="数据成员对齐规则"></a>数据成员对齐规则</h3><p>结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始 (比如int在32位机为４字节,则要从４的整数倍地址开始存储。)  举例如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct MyStruct &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int a;			&#x2F;&#x2F; 0-3  补位 4,5,6,7</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double b;		&#x2F;&#x2F; 8-15</span></pre></td></tr><tr><td class="code"><pre><span class="line">    char c;			&#x2F;&#x2F; 16		部位 17,18,19</span></pre></td></tr><tr><td class="code"><pre><span class="line">    short d;		&#x2F;&#x2F; 20-24</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; struct1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%lu&quot;,sizeof(struct1));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-18 20:41:12.974406+0800 LGTest[36584:2131553] 24</span></pre></td></tr></table></figure>

<p><em>注意: 测试环境均为 64位 环境, 32位环境下感兴趣的同学可以自行测试。</em></p>
<p>分析上面的结果, 首先 <code>a</code> 为 int 类型占4位, 所以 <code>a</code> 所在的区域为0-3位。接下来的 <code>b</code> 为 double 类型占8位, 因为内存对齐原则起始位置应该为8的整数倍, 所以起始位置应该为8, 前面的4位补齐。然后 <code>c</code> 的起始位置就是16, 因为 <code>c</code> 只需要1位, 那么 <code>d</code> 的起始位置就是17, 17如果需要是 4 的倍数需要变成 20, 所以前面补齐3位, <code>d</code> 的起始位置为20, 20加上 <code>d</code> 的4位就得出最终的结果24。</p>
<p>还可以用下面的方式去理解:</p>
<blockquote>
<p>我们把内存对齐原则理解为 <code>min(m, n)</code> 的公式, 其中 m表示当前成员的开始位置, n表示当前成员所需要的位数。如果满足条件 m 整除 n 的话, 就让 n 从 m 位置开始存储, 否则继续检查 m+1 能否整除 n, 直到可以整除, 从而就确定了当前成员的开始位置。</p>
<p>上面结构体中的 <code>b</code> 就可以看做, <code>min(4, 8)</code> , 直到 <code>min(8, 8)</code> 时满足条件, 所以 <code>b</code> 的存储区域为 <code>8-15</code> 这8位</p>
<p>然后 <code>c</code> 就是 <code>min(16, 1)</code> , 可以直接整除, <code>c</code> 的区域就是 16, 占1位</p>
<p>最后 <code>d</code> 为 <code>min(17, 4)</code> , 直到 <code>min(20, 4)</code> 时满足条件, 可以得出, <code>d</code> 所在的区域为 20-23 </p>
</blockquote>
</li>
<li><h3 id="结构体作为成员对齐规则"><a href="#结构体作为成员对齐规则" class="headerlink" title="结构体作为成员对齐规则"></a>结构体作为成员对齐规则</h3><p>如果一个结构里有某些结构体成员, 则结构体成员要从其内部最大元素大小的整数倍地址开始存储。(struct a 里存有 struct b, b 里有 char, int , double等元素, 那 b 应该从8的整数倍开始存储。) 可以看一下下面的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct MyStruct4</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  double a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  short b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    struct MyStruct5 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        int c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        double d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; struct5;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; struct4;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%lu&quot;, sizeof(struct4));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-18 21:45:20.741445+0800 LGTest[38755:2172577] 32</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照原则1								&#x2F;&#x2F; 遵循原则2</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 0-7										&#x2F;&#x2F;	0-7</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 8-11										&#x2F;&#x2F;  8-11</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 12-15	min(12, 4)			&#x2F;&#x2F;  16-19   min(12, 8)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 16-23	min(16, 8)			&#x2F;&#x2F;  24-31		min(20, 8)</span></pre></td></tr></table></figure>

<p>可以看到, 如果我们继续按照上面的方式去存储的话, 得到的结果应该是 24。根据结构体作为成员的规则要求, <code>struct5</code> 的最大元素大小为 8 位, 所以 <code>struct5</code> 的第一个数据成员的起始位置应该是 8 的整数倍, 也就是 <code>min(12, 8)</code> , 然后再继续往下存储, 最后得出结果为32。</p>
</li>
<li><h3 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h3><p>结构体的总大小, 也就是 <code>sizeof</code> 的结果, 必须是其内部最大成员的整数倍, 不足的话需要补齐。实例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct MyStruct2</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  int a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  char b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; struct2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct MyStruct3</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  double a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  char b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; struct3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%lu&quot;, sizeof(struct2));</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%lu&quot;, sizeof(struct3));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-18 21:25:22.008413+0800 LGTest[38015:2158667] 8</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-18 21:25:22.008605+0800 LGTest[38015:2158667] 16</span></pre></td></tr></table></figure>

<p>假如仅凭第一条的规则, 我们可以得出, <code>struct2</code> 的打印结果应该为 5, <code>struct3</code> 的结果应该为 9。但是我们的打印结果是 8 和 16, 这就验证了我们这一条的原则, <code>struct2</code> 的结果必须是 4 的倍数, 所以结果是 8; <code>struct3</code> 的结果应该是 8 的倍数, 所以结果是 16。</p>
</li>
</ul>
<h2 id="对象的内存对齐"><a href="#对象的内存对齐" class="headerlink" title="对象的内存对齐"></a>对象的内存对齐</h2><h3 id="1-属性的内存对齐"><a href="#1-属性的内存对齐" class="headerlink" title="1. 属性的内存对齐"></a>1. 属性的内存对齐</h3><p>了解了内存对齐的原则, 下面我们再来看一下对象的内存对齐是在什么时候进行的。通过之前的 <a href="https://juejin.im/post/5e0220c3f265da339f7d025f#heading-7" target="_blank" rel="noopener">alloc流程探索</a> 过程中我们知道了对象的创建是在 <code>callAlloc</code> 方法中完成的, </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span></pre></td></tr><tr><td class="code"><pre><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#if __OBJC2__</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; No alloc&#x2F;allocWithZone implementation. Go straight to the allocator.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; fixme store hasCustomAWZ in the non-meta class and </span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; add it to canAllocFast&#39;s summary</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (fastpath(cls-&gt;canAllocFast())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F; No ctors, raw isa, etc. Go straight to the metal.</span></pre></td></tr><tr><td class="code"><pre><span class="line">            bool dtor &#x3D; cls-&gt;hasCxxDtor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            id obj &#x3D; (id)calloc(1, cls-&gt;bits.fastInstanceSize());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if (slowpath(!obj)) return callBadAllocHandler(cls);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return obj;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F; Has ctor or raw isa or something. Use the slower path.</span></pre></td></tr><tr><td class="code"><pre><span class="line">            id obj &#x3D; class_createInstance(cls, 0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if (slowpath(!obj)) return callBadAllocHandler(cls);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return obj;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; No shortcuts available.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (allocWithZone) return [cls allocWithZone:nil];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return [cls alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>根据方法名我们就不难发现 <code>id obj = class_createInstance(cls, 0);</code> 这一行代码应该就是创建对象的方法, 下面我们在往里逐一探索:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id class_createInstance(Class cls, size_t extraBytes)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return _class_createInstanceFromZone(cls, extraBytes, nil);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">static __attribute__((always_inline)) </span></pre></td></tr><tr><td class="code"><pre><span class="line">id</span></pre></td></tr><tr><td class="code"><pre><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </span></pre></td></tr><tr><td class="code"><pre><span class="line">                              bool cxxConstruct &#x3D; true, </span></pre></td></tr><tr><td class="code"><pre><span class="line">                              size_t *outAllocatedSize &#x3D; nil)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (!cls) return nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert(cls-&gt;isRealized());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bool hasCxxCtor &#x3D; cls-&gt;hasCxxCtor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bool fast &#x3D; cls-&gt;canAllocNonpointer();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    size_t size &#x3D; cls-&gt;instanceSize(extraBytes);	&#x2F;&#x2F; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    id obj;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (!zone  &amp;&amp;  fast) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        obj &#x3D; (id)calloc(1, size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (!obj) return nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (zone) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            obj &#x3D; (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            obj &#x3D; (id)calloc(1, size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (!obj) return nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be </span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; doing something weird with the zone or RR.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        obj-&gt;initIsa(cls);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        obj &#x3D; _objc_constructOrFree(obj, cls);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return obj;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>来到这里, 发现这一行代码 <code>size_t size = cls-&gt;instanceSize(extraBytes);</code> , 继续往下走:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  size_t size &#x3D; alignedInstanceSize() + extraBytes;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  if (size &lt; 16) size &#x3D; 16;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Class&#39;s ivar size rounded up to a pointer-size boundary.</span></pre></td></tr><tr><td class="code"><pre><span class="line">uint32_t alignedInstanceSize() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return word_align(unalignedInstanceSize());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return (x + WORD_MASK) &amp; ~WORD_MASK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define WORD_MASK 7UL</span></pre></td></tr></table></figure>

<p>这里当我们看到 <code>alignedInstanceSize()</code> 方法时发现此方法就是上面提到过的 <code>class_getInstanceSize</code> 方法的内部实现, 此方法的作用就是用来获取实例对象所占用的内存的大小, 此时就明了了。下面我们来着重看一下这个方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return (x + WORD_MASK) &amp; ~WORD_MASK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define WORD_MASK 7UL</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设 x 为 9, 转换为二进制为  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; x + WORD_MASK (7) &#x3D; 16 转换为二进制</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 0001 0000   (即 16)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; &amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1111 1000   (&amp; 上 -7的二进制)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 0001 0000	 (16)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实际为 (x + 7) &gt;&gt; 3 &lt;&lt; 3</span></pre></td></tr></table></figure>

<p>根据方法名字可以看出, 该方法主要做的工作就是 <code>字节对齐</code> , 这正是我们要找的东西。通过上面对算法的模拟, 我们可以看出, 在这里系统对实例对象所占用的内存 (<strong>也就是对象属性所需要占用的内存大小</strong>) 进行了 <code>8字节对齐</code> 。然后回过头来通过 <code>instanceSize(size_t extraBytes)</code> 该方法的实现得知, 对象的内存大小至少为 16 字节。</p>
<h3 id="2-对象的内存对齐"><a href="#2-对象的内存对齐" class="headerlink" title="2. 对象的内存对齐"></a>2. 对象的内存对齐</h3><p>通过上面的探索我们知道了对象属性的 <code>8字节对齐</code> , 并且对象在申请内存空间时至少为16字节。下面来继续验证一下我们的结论是否正确:</p>
<p><em>这里需要注意: 在计算对象内存大小时不要忽略 isa 的 8 字节大小。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义类</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, assign) int age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, assign) long height;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *hobby;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; </span></pre></td></tr><tr><td class="code"><pre><span class="line">MCPerson *person &#x3D; [[MCPerson alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%lu&quot;, class_getInstanceSize([MCPerson class]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)(person)));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-18 23:39:29.977673+0800 LGTest[42667:2246768] 40</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-18 23:39:29.979105+0800 LGTest[42667:2246768] 48</span></pre></td></tr></table></figure>

<p>通过打印结果可以看出, 对象需要的内存空间为 40, 但是实际开辟的内存空间确实 48。那么到底是在哪里发成了问题:</p>
<p><img src="/images/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-1.png" alt></p>
<p>从上图发现, 调用 <code>calloc</code> 方法时我们申请的内存大小是 40, 这里是没有问题的。继续往下执行, </p>
<p><img src="/images/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-2.png" alt></p>
<p>然后我们打印一下生成的对象的内存大小发现, 结果为 <code>0x0000000000000030</code> , 转换成10进制为 <code>48</code> 。那么, 问题出在 <code>calloc</code> 方法, 关于 <code>calloc</code> 的分析由于篇幅较长这里不做叙述了, 有兴趣的同学可以去看看 <a href="https://juejin.im/post/5e0894916fb9a016153dfa11" target="_blank" rel="noopener">Cooci老师的malloc分析</a>, 下面我们直接进入重点实现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static MALLOC_INLINE size_t</span></pre></td></tr><tr><td class="code"><pre><span class="line">segregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; size &#x3D; 40</span></pre></td></tr><tr><td class="code"><pre><span class="line">	size_t k, slot_bytes;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (0 &#x3D;&#x3D; size) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		size &#x3D; NANO_REGIME_QUANTA_SIZE; &#x2F;&#x2F; Historical behavior</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 40 + 16-1 &gt;&gt; 4 &lt;&lt; 4</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 40 - 16*3 &#x3D; 48</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 16</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; #define NANO_REGIME_QUANTA_SIZE	(1 &lt;&lt; SHIFT_NANO_QUANTUM)	&#x2F;&#x2F; 16</span></pre></td></tr><tr><td class="code"><pre><span class="line">	k &#x3D; (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; &#x2F;&#x2F; round up and shift for number of quanta</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slot_bytes &#x3D; k &lt;&lt; SHIFT_NANO_QUANTUM;							&#x2F;&#x2F; multiply by power of two quanta size</span></pre></td></tr><tr><td class="code"><pre><span class="line">	*pKey &#x3D; k - 1;													&#x2F;&#x2F; Zero-based!</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	return slot_bytes;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过对 <code>calloc</code> 的一连串探索操作, 最终我们找到了上面的方法, 也找到了对象申请内存大小与实际大小不一样的关键问题。可以看出我们传过来的 <code>size</code> 经过 <code>(size + 16 - 1) &gt;&gt; 16 &lt;&lt; 16</code> 之后返回, 这不类似于之前属性的 <code>8字节对齐</code> 吗, 不同点在于这里是 <code>16字节对齐</code> 。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这次内存对齐原理的全部内容, 通过以上的内容, 我们可以明白内存对齐的相关概念, 以及对象创建的过程中是怎样进行内存对齐的。首先在获取对象所需要的内存大小的时候进行了 属性的 <code>8字节对齐</code>, 然后在返回时进行了 <code>&lt;16</code> 判断, 最后就是 <code>calloc</code> 申请内存时又进行了一次对象的 <code>16字节对齐</code> 。<strong>通过这两次的字节对齐, 能有防止访问溢出, 同时也能够有效的提高寻址访问效率。</strong></p>
]]></content>
      <categories>
        <category>iOS底层学习</category>
      </categories>
      <tags>
        <tag>iOS探索</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS探索之--KVC 原理分析</title>
    <url>/2020-02-16-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--KVC%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>KVC (Key-Value Coding), 是利用 <code>NSKeyValueCoding</code> 非正式协议实现的一种机制, 对象采用这种机制来提供对其属性的间接访问。当对象采用该协议时, 可以通过简洁统一的方法来访问其属性。简单来说, 就是我们在开发中可以通过key名直接访问对象的属性, 或者对属性进行赋值操作, 而不需要去调用明确的存取方法。这样就允许我们在运行时去动态地访问和修改对象的属性, 而不是在编译时决定。</p>
</blockquote>
<h2 id="KVC-简介"><a href="#KVC-简介" class="headerlink" title="KVC 简介"></a>KVC 简介</h2><p>通过查看API我们不难发现, KVC的定义是通过对 <code>NSObject</code> 的扩展来实现的。所以对于所有集成了 <code>NSObject</code> 的类来说都可以使用 KVC, 也就是说出去少数类型 (结构体) 以外都可以使用KVC。下面是我们经常使用到的一些方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;&#x2F;&#x2F; 通过 key 设值</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;&#x2F;&#x2F; 通过 key 取值</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;&#x2F;&#x2F; 通过 keyPath 设值</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;&#x2F;&#x2F; 通过 keyPath 取值</span></pre></td></tr></table></figure>

<p>NSKeyValueCoding类别的其它方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 默认为YES。 如果返回为YES,如果没有找到 set&lt;Key&gt; 方法的话, 会按照_key, _isKey, key, isKey的顺序搜索成员变量, 返回NO则不会搜索</span></pre></td></tr><tr><td class="code"><pre><span class="line">+ (BOOL)accessInstanceVariablesDirectly;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 键值验证, 可以通过该方法检验键值的正确性, 然后做出相应的处理</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果key不存在, 并且没有搜索到和key有关的字段, 会调用此方法, 默认抛出异常。两个方法分别对应 get 和 set 的情况</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; setValue方法传 nil 时调用的方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意文档说明: 当且仅当 NSNumber 和 NSValue 类型时才会调用此方法 </span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)setNilValueForKey:(NSString *)key;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 一组 key对应的value, 将其转成字典返回, 可用于将 Model 转成字典</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;</span></pre></td></tr></table></figure>



<h2 id="KVC-原理分析"><a href="#KVC-原理分析" class="headerlink" title="KVC 原理分析"></a>KVC 原理分析</h2><h3 id="1-KVC-设值过程"><a href="#1-KVC-设值过程" class="headerlink" title="1. KVC 设值过程"></a>1. KVC 设值过程</h3><p>当我们去调用 <code>setValue:值 forKey:名字</code> 设值方法时, 底层的执行机制大致如下:</p>
<ol>
<li><p>程序会去优先调用, <code>set&lt;Key&gt;: 或者 _set&lt;Key&gt;, setIs&lt;Key&gt;</code> 方法, 如果存在这些命名规则的方法, 会直接调用该方法进行赋值。<strong>调用优先顺序按照上面书写的顺序。</strong></p>
<p><strong>说明: 这里的 “key” 指成员变量名字, 书写格式需要符合 KVC 的命名规则。</strong></p>
</li>
<li><p>如果没有找到步骤1的方法, 程序会回去判断 <code>+ (BOOL)accessInstanceVariablesDirectly;</code> 方法的返回值, 如果该方法返回值为NO (默认为 YES, 在我们重写该方法时有可能返回NO, 一般不会返回NO), 则会执行 <code>setValue: forUndefinedKey:</code> 方法报错。</p>
</li>
<li><p>如果上一步方法的返回值为YES, 程序会去查找命名方式为 <code>_&lt;key&gt;, _&lt;isKey&gt;, &lt;key&gt;, &lt;isKey&gt;</code> 形式的实例变量, 加入存在该形式的实例变量, 则会直接将我们调用方法的值赋值给该实例变量。<strong>这里的查找优先顺序也会按照书写顺序去查找。</strong></p>
</li>
<li><p>如果第三步没有查找到符合规则的实例变量, 程序就会去执行 <code>setValue: forUndefinedKey:</code> 方法进行报错。</p>
</li>
</ol>
<p>下面是一段验证代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明实例变量</span></pre></td></tr><tr><td class="code"><pre><span class="line">@interface MCPerson : NSObject &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @public</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSString *_name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSString *name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSString *_isName;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSString *isName;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@end</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .m文件实现上面提到的方法进行监听</span></pre></td></tr><tr><td class="code"><pre><span class="line">+ (BOOL)accessInstanceVariablesDirectly &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return YES;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)setValue:(id)value forUndefinedKey:(nonnull NSString *)key &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;设置出现异常!!!&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)setName:(NSString *)value &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;%s - %@&quot;, __func__, value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)setIsName:(NSString *)value &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;%s - %@&quot;, __func__, value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)_setName:(NSString *)value &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;%s - %@&quot;, __func__, value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 测试代码</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MCPerson *person &#x3D; [[MCPerson alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [person setValue:@&quot;person&quot; forKey:@&quot;name&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;%@ - %@ - %@ - %@&quot;, person-&gt;_name, person-&gt;_isName, person-&gt;name, person-&gt;isName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;%@ - %@ - %@&quot;, person-&gt;_isName, person-&gt;name, person-&gt;isName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;%@ - %@&quot;, person-&gt;name, person-&gt;isName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;%@&quot;, person-&gt;isName);</span></pre></td></tr></table></figure>

<ol>
<li>执行上面的代码, 查看打印信息如下:</li>
</ol>
<p><img src="/images/kvc-1.png" alt><br>可以看到程序执行了 <code>setName</code> 方法, 验证了上面步骤1的内容。而且我们发现三个方法中执行完第一个方法以后后面的就不会去执行了, 如果我们注释掉 <code>setName</code> 的话, 得到的结果是执行<code>_setName</code> , 由此就能得出方法的查找和执行优先顺序。</p>
<ol start="2">
<li>将上面的set方法注释掉, 然后 <code>accessInstanceVariablesDirectly</code> 方法的返回值改为 NO</li>
</ol>
<p><img src="/images/kvc-2.png" alt><br>根据打印信息发现调用了 <code>setValue: forUndefinedKey:</code> 方法抛出了异常, 下面再把返回值改为 YES。</p>
<p><img src="/images/kvc-3.png" alt><br>可以发现我们的值被赋值给了 <code>_name</code> ,其余的三个实例变量仍然是空值, 然后试着把 <code>_name</code>注释掉就可以去一一验证实例变量的查找优先顺序了有兴趣的可以自己去验证一下。</p>
<h3 id="2-KVC-取值过程"><a href="#2-KVC-取值过程" class="headerlink" title="2. KVC 取值过程"></a>2. KVC 取值过程</h3><ol>
<li><p>首先按照 <code>get&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;, _&lt;key&gt;</code> 的顺序查找方法, 如果找到方法, 执行找到的方法得到返回值, 返回值的判断跳到第5步; 如果没有查找到方法, 进行下一步</p>
</li>
<li><p>如果没有找到上面的方法, KVC 就会去继续查找 <code>countOf&lt;Key&gt;, objectIn&lt;Key&gt;AtIndex: (对应NSArray的方法), &lt;key&gt;AtIndexes: (对应NSArray 的 objectsAtIndexes: 方法)</code> 格式的方法, 如果找到 <code>countOf&lt;Key&gt;</code> 和 另外两个方法中的一个, 就会返回一个可以响应所有NSArray方法的代理集合对象。当该代理集合对象接收到 NSArray 的方法调用时, 会去转换为对 <code>countOf&lt;Key&gt;, objectIn&lt;Key&gt;AtIndex 或 &lt;Key&gt;AtIndexes</code> 这几个方法的调用 (此外还有一个可选方法格式为 <code>get&lt;Key&gt;:range</code> )。(<strong>注意: 该类为<code>NSKeyValueArray</code> , 是NSArray的子类</strong>)</p>
</li>
<li><p>如果第2步仍然没有找到, 就会继续去查找 <code>countOf&lt;Key&gt;, enumeratorOf&lt;Key&gt;, 和 memberOf&lt;Key&gt;: (对应NSSet的方法)</code> 格式的方法, 如果这三种格式的方法都找到, 就会返回一个响应所有NSSet方法的代理集合对象, 反之则进行第4步。该集合对象会将接收到的NSSet方法调用转换为对 <code>countOf&lt;Key&gt;, enumeratorOf&lt;Key&gt;, 和 memberOf&lt;Key&gt;:</code> 方法的调用。</p>
</li>
<li><p>如果没有找到任何符合要求的方法, 然后 <code>accessInstanceVariablesDirectly</code> 的返回值为YES, 会像上面的设值过程一样去查询实例变量 <code>_&lt;key&gt;, _&lt;isKey&gt;, &lt;key&gt;,</code> , 如果查询到符合条件的实例变量, 会直接取出实例变量的值, 然后进行第5步。反之, 直接到第6步。</p>
</li>
<li><p>如果第4步获取到的属性值是一个对象指针, 直接返回结果; 如果该值是 NSNumber 支持的标量类型, 将其存储为 NSNumber类型的实例然后返回; 如果该值不是 NSNumber 支持的标量类型, 将其转换为 NSValue对象然后返回。</p>
</li>
<li><p>调用 <code>valueForUndefinedKey:</code> 方法进行报错。</p>
</li>
</ol>
<p>下面是关于取值过程的代码验证:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; </span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic,strong) NSArray *array;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic,strong) NSSet *set;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic,strong) NSMutableString *arrayM;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic,strong) NSMutableSet *setM;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic,strong) NSMutableOrderedSet *orderSetM;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (id)valueForUndefinedKey:(NSString *)key &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;取值出现异常!!!&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return key;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (NSString *)getName &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return NSStringFromSelector(_cmd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (NSString *)name &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return NSStringFromSelector(_cmd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (NSString *)isName &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return NSStringFromSelector(_cmd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (NSString *)_name &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return NSStringFromSelector(_cmd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#pragma - NSArray -</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (NSUInteger)countOfPens &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;- %s -&quot;, __func__);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return [self.array count];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (id)objectInPensAtIndex:(NSUInteger)index &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;- %s -&quot;, __func__);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return self.array[index];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#pragma - NSSet -</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (NSUInteger)countOfBooks &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;- %s -&quot;, __func__);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return [self.set count];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (NSEnumerator *)enumeratorOfBooks &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;- %s -&quot;, __func__);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return [self.set objectEnumerator];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (NSString *)memberOfBooks:(NSString *)object &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;- %s -&quot;, __func__);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return [self.set containsObject:object] ? object : nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 验证代码</span></pre></td></tr><tr><td class="code"><pre><span class="line">    person-&gt;_name &#x3D; @&quot;我是 _name&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    person-&gt;name &#x3D; @&quot;我是 name&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    person-&gt;isName &#x3D; @&quot;我是 isName&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    person-&gt;_isName &#x3D; @&quot;我是 _isName&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;***** %@&quot;, [person valueForKey:@&quot;name&quot;]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    person.array &#x3D; @[@&quot;pen0&quot;, @&quot;pen1&quot;, @&quot;pen2&quot;, @&quot;pen3&quot;, @&quot;pen4&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSArray *array &#x3D; [person valueForKey:@&quot;pens&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;%@&quot;, [array objectAtIndex:1]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;数量 %ld&quot;, [array count]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;是否存在该值 %d&quot;, [array containsObject:@&quot;pen2&quot;]);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    person.set &#x3D; [NSSet setWithArray:person.array];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSSet *set &#x3D; [person valueForKey:@&quot;books&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [set enumerateObjectsUsingBlock:^(id  _Nonnull obj, BOOL * _Nonnull stop)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        NSLog(@&quot;遍历set: %@&quot;, obj);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;是否存在该值 %d&quot;, [set containsObject:@&quot;pen2&quot;]);</span></pre></td></tr></table></figure>


<p>打印结果:<br><img src="/images/kvc-4.png" alt><br>通过上面的代码可以去检索KVC在 <code>valueForKey:@&quot;name&quot;</code> 是的查询机制, 这里不再一一列出, 有兴趣的可以自己去一一验证。</p>
<h3 id="3-KVC-与-容器类"><a href="#3-KVC-与-容器类" class="headerlink" title="3. KVC 与 容器类"></a>3. KVC 与 容器类</h3><p>我们知道对象的属性既可以是一对一的, 也可以是一对多的。可以是有序的数组, 也可以是无序的集合。当对象属性是可变容器时, 苹果给我们提供了下面的方法:</p>
<h4 id="1-有序的"><a href="#1-有序的" class="headerlink" title="1. 有序的"></a>1. 有序的</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;</span></pre></td></tr></table></figure>

<p>该方法返回一个可变的有序数组, 当调用该方法时KVC的搜索顺序是这样的:</p>
<ul>
<li><p>首先搜索 <code>insertObject:in&lt;Key&gt;AtIndex: 和 removeObjectFrom&lt;Key&gt;AtIndex:</code> 方法 (对应<code>NSMutableArray</code> 的 <code>insertObject:atIndex: 和 removeObjectAtIndex:</code> 方法), 或者<code>insert&lt;Key&gt;:atIndexes: 和 remove&lt;Key&gt;AtIndexes:</code> (对应<code>NSMutableArray</code>的<code>insertObjects:atIndexes: 和 removeObjectsAtIndexes:</code> 方法)。如果至少找到一个 insert方法和一个remove方法,就会返回一个可以相应NSMutableArray所有方法的代理集合, 当该代理集合对象接收到 NSMutableArray 的方法调用时, 会去转换为对 <code>insertObject:inAtIndex:</code> , <code>removeObjectFromAtIndex:</code> 或者 <code>insertAdIndexes</code> , <code>removeAtIndexes</code>组合的形式调用 (此外还有两个可选的方法<code>replaceOnjectAtIndex:withObject:, replaceAtIndexes:with:</code>) 。</p>
</li>
<li><p>如果上面的条件没有成立, 会继续搜索格式为 <code>set&lt;Key&gt;</code> 的方法, 如果找到, 那么代理集合对象接收到的NSMutableArray方法调用都会去调用<code>set&lt;Key&gt;</code>方法。就是说, 取出的代理集合如果被修改后, 都会通过调用 <code>set&lt;Key&gt;</code> 方法重新赋值回去, 这样做的话大大降低了效率。(所以尽量实现上面的方法)</p>
</li>
<li><p>如果上一步的方法还是没有找到, 会去检查 <code>accessInstanceVariablesDirectly</code> 的返回值, 为YES, 会按照 <code>_&lt;key&gt;, &lt;key&gt;</code> 的顺序去搜索实例变量, 如果找到的话, 代理集合接收到的NSMutableArray消息直接交给这个实例变量处理。</p>
</li>
<li><p>如果仍然没有结果, 调用 <code>valueForUndefinedKey:</code>。</p>
</li>
<li><p>关于 <code>mutableArrayValueForKey</code> 的用法, 网上只找到了关于<code>NSMutableArray</code> 添加观察者时。如果对象的属性是 <code>NSMutableArray、NSMutableSet、NSMutableDictionary</code> 等集合类型时, 如果我们对其添加KVO, 会发现当添加或者移除元素时并不能接收到变化。因为KVO是在系统检测到某个属性的内存地址或者常量发生改变时, 才会去发送通知。一种方法是我们去手动调用方法通知对象的改变, 但是并不推荐, 因为我们无法像系统一样准确的知道其改变。另外一种就是利用 <code>mutableArrayValueForKey</code> :</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MCStudent ()</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic,strong) NSMutableArray *arr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@end</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">- (instancetype)init &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (self &#x3D; [super init]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _arr &#x3D; [NSMutableArray array];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [self addObserver:self forKeyPath:@&quot;arr&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return self;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;change: %@&quot;, change);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)dealloc &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [self removeObserver:self forKeyPath:@&quot;arr&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)addItem&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [_arr addObject:@&quot;1&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)addItemObserver&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [[self mutableArrayValueForKey:@&quot;arr&quot;] addObject:@&quot;1&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)removeItemObserver&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [[self mutableArrayValueForKey:@&quot;arr&quot;] removeLastObject];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 测试代码</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [student addItem];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [student addItemObserver];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [student removeItemObserver];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果如下</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-16 16:16:21.315056+0800 002-KVC取值&amp;赋值过程[2281:1547198] change: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    indexes &#x3D; &quot;&lt;_NSCachedIndexSet: 0x60000107edc0&gt;[number of indexes: 1 (in 1 ranges), indexes: (1)]&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kind &#x3D; 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    new &#x3D;     (</span></pre></td></tr><tr><td class="code"><pre><span class="line">        1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-16 16:16:21.315270+0800 002-KVC取值&amp;赋值过程[2281:1547198] change: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    indexes &#x3D; &quot;&lt;_NSCachedIndexSet: 0x60000107edc0&gt;[number of indexes: 1 (in 1 ranges), indexes: (1)]&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kind &#x3D; 3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    old &#x3D;     (</span></pre></td></tr><tr><td class="code"><pre><span class="line">        1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从上面的代码可以看出, 当我们按照通常的方式去给数组添加对象时, 并没有触发KVO的监听方法, 只有通过 <code>mutableArrayValueForKey</code> 方法拿到数组然后再去进行添加/移除时才会触发KVO。</p>
<h4 id="2-无序的"><a href="#2-无序的" class="headerlink" title="2. 无序的"></a>2. 无序的</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;</span></pre></td></tr></table></figure>

<p>该方法返回一个可变的无序数组, KVC搜索顺序如下:</p>
<ul>
<li>首先会去查询 <code>addObject&lt;Key&gt;Object: , remove&lt;Key&gt;Object: 或者 add&lt;Key&gt;: , remove&lt;Key&gt;:</code>, 如果至少找到一个 insert和一个remove方法, 就会返回一个可以响应NSMutableSet所有方法的代理集合, 当该代理集合对象接收到 NSMutableSet 的方法调用时, 会去转换为对 <code>addObject&lt;Key&gt;Object: , remove&lt;Key&gt;Object: 或者 add&lt;Key&gt;:, remove&lt;Key&gt;:</code>组合的形式调用 (此外还有两个可选的方法<code>replaceOnjectAtIndex:withObject:, replaceAtIndexes:with:</code>) 。</li>
<li>如果 receiver 是 managed object, 那么就不会继续搜索 (See Managed Object Accessor Methods in <em><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_blank" rel="noopener">Core Data Programming Guide</a></em> for more information) 。</li>
<li>如果上一步的方法没有找到，则搜索<code>set&lt;Key&gt;:</code> 格式的方法，如果找到，那么发送给代理集合的 <code>NSMutableSet</code> 方法最终都会调用<code>set&lt;Key&gt;:</code>方法。 也就是说，<code>mutableSetValueForKey</code> 取出的代理集合修改后，用<code>set&lt;Key&gt;:</code> 重新赋值回去。这样做效率会低很多。所以推荐实现上面的方法。</li>
<li>如果上一步的方法还是没有找到, 会去检查 <code>accessInstanceVariablesDirectly</code> 的返回值, 为YES, 会按照 <code>_&lt;key&gt;, &lt;key&gt;</code> 的顺序去搜索实例变量, 如果找到的话, 代理集合接收到的NSMutableSet 消息直接交给这个实例变量处理。</li>
<li>如果仍然没有结果, 调用 <code>valueForUndefinedKey:</code>。</li>
</ul>
<h3 id="4-KVC-与-字典"><a href="#4-KVC-与-字典" class="headerlink" title="4. KVC 与 字典"></a>4. KVC 与 字典</h3><p>当对字典对象使用KVC时, KVC给我们提供了下面两个方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;</span></pre></td></tr></table></figure>

<p><code>dictionaryWithValuesForKeys:</code> 该方法接收一组key, 然后将该组key对应的属性封装成一个字典返回。</p>
<p><code>setValuesForKeysWithDictionary:</code> 通过一个字典来修改对应key的值。</p>
<h2 id="KVC-的使用注意事项"><a href="#KVC-的使用注意事项" class="headerlink" title="KVC 的使用注意事项"></a>KVC 的使用注意事项</h2><h3 id="1-在KVC中使用-keyPath"><a href="#1-在KVC中使用-keyPath" class="headerlink" title="1. 在KVC中使用 keyPath"></a>1. 在KVC中使用 keyPath</h3><p>在实际过程中, 一个类的成员变量有可能是自定义的类或者其他的复杂类型, 这时候如果想要使用KVC获取到自定义类的属性就会比较麻烦。这时KVC给我们提供了一个解决方案, 键路径 <code>keyPath</code>。方法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;  &#x2F;&#x2F;通过KeyPath来取值</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  &#x2F;&#x2F;通过KeyPath来设值</span></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; </span></pre></td></tr><tr><td class="code"><pre><span class="line">MCStudent *student &#x3D; [[MCStudent alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">student.classNumber &#x3D; @&quot;num1&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">student.number &#x3D; @&quot;007&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">person.student &#x3D; student;</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;classNum: %@&quot;, [personvalueForKeyPath:@&quot;student.classNumber&quot;]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-16 13:27:08.482381+0800 002-KVC取值&amp;赋值过程[96366:1435734] classNum: num1</span></pre></td></tr></table></figure>

<p>上面展示<code>keyPath</code>的简单用法, 此时如果我们调用的方法是 <code>valueForKey:</code> 的话, 一般情况下系统会去调用<code>undefinedKey</code>方法, 因为没有找到这个属性及其相关的方法和实例变量。KVC在此方法中的搜索机制首先根据 “ . “ 来分割key, 然后在去按照上面的顺序去搜索下去。</p>
<h3 id="2-KVC-的自动转换"><a href="#2-KVC-的自动转换" class="headerlink" title="2. KVC 的自动转换"></a>2. KVC 的自动转换</h3><p>我们进行设值或者取值的时候, 不是每次都是对象类型, 但是在 <code>valueForKey: 和 setValue: forKey:</code> 时总是需要或者返回一个id对象类型。看一下下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float x, y, z;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; ThreeFloats;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, assign) int  age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, assign) BOOL sex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic) ThreeFloats  threeFloats;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [person setValue:@18 forKey:@&quot;age&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 上面那个表达 大家应该都会! 但是下面这样操作可以?</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [person setValue:@&quot;20&quot; forKey:@&quot;age&quot;]; &#x2F;&#x2F; int - string</span></pre></td></tr><tr><td class="code"><pre><span class="line">  NSLog(@&quot;%@-%@&quot;,[person valueForKey:@&quot;age&quot;],[[person valueForKey:@&quot;age&quot;] class]);&#x2F;&#x2F;__NSCFNumber</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [person setValue:@&quot;20&quot; forKey:@&quot;sex&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  NSLog(@&quot;%@-%@&quot;,[person valueForKey:@&quot;sex&quot;],[[person valueForKey:@&quot;sex&quot;] class]);&#x2F;&#x2F;__NSCFNumber</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-16 14:40:31.263662+0800 004-KVC异常小技巧[98873:1483589] 20-__NSCFNumber</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-16 14:40:33.829650+0800 004-KVC异常小技巧[98873:1483589] 1-__NSCFBoolean</span></pre></td></tr></table></figure>

<p>如果原本的变量类型是值类型或者布尔类型, 我们直接以字符串进行赋值以后, 得出的结果为 <code>__NSCFNumber 和__NSCFBoolean</code> 类型, 说明在我们进行setValue 和 getValue操作时, 系统帮我们进行了自动转换。那么当变量类型是结构体类型的时候呢, 此时我们是无法再去直接使用字符串赋值的, 需要我们将其转换为 <code>NSValue</code>类型:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 赋值操作</span></pre></td></tr><tr><td class="code"><pre><span class="line">ThreeFloats floats &#x3D; &#123;1., 2., 3.&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSValue *value  &#x3D; [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[person setValue:value forKey:@&quot;threeFloats&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSValue *reslut &#x3D; [person valueForKey:@&quot;threeFloats&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%@&quot;,reslut);</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%@-%@&quot;,[person valueForKey:@&quot;threeFloats&quot;],[[person valueForKey:@&quot;threeFloats&quot;] class]);&#x2F;&#x2F;NSConcreteValue</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 取值操作</span></pre></td></tr><tr><td class="code"><pre><span class="line">ThreeFloats th;</span></pre></td></tr><tr><td class="code"><pre><span class="line">[reslut getValue:&amp;th] ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%f - %f - %f&quot;,th.x,th.y,th.z);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-16 15:05:00.494832+0800 004-KVC异常小技巧[99701:1501772] &#123;length &#x3D; 12, bytes &#x3D; 0x0000803f0000004000004040&#125;-NSConcreteValue</span></pre></td></tr></table></figure>

<p>通过打印结果可以看出, 转换成 NSValue 类型以后赋值成功了, 然后如果我们需要使用 <code>valueForKey</code> 取值时, 同样取出的也是 NSValue 类型的值, 此时需要进行如上面样将其转换为结构体然后进行使用。所以当我们进行KVC设值和取值操作时, 因为我们传递进去和取出来的都是id类型的值, 有时候需要我们自己去保证类型的正确性。</p>
<h3 id="3-KVC-异常处理"><a href="#3-KVC-异常处理" class="headerlink" title="3. KVC 异常处理"></a>3. KVC 异常处理</h3><p>这一点需要结合上面的第2点进行说明, 我们知道KVC有时候会帮我们去自动转换我们所传的值, 但是当我们传 nil 的时候KVC是怎么处理的呢。下面看一段代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setNilValueForKey:(NSString *)key;</span></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setNilValueForKey:(NSString *)key&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;你傻不傻: 设置 %@ 是空值&quot;,key);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *subject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, assign) int  age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, assign) BOOL sex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic) ThreeFloats  threeFloats;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 测试代码</span></pre></td></tr><tr><td class="code"><pre><span class="line">  NSLog(@&quot;******2: 设置空值******&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [person setValue:nil forKey:@&quot;age&quot;]; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  [person setValue:nil forKey:@&quot;subject&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [person setValue:nil forKey:@&quot;sex&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [person setValue:nil forKey:@&quot;threeFloats&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-16 16:58:44.538117+0800 004-KVC异常小技巧[3703:1577245] ******2: 设置空值******</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-16 16:58:44.538200+0800 004-KVC异常小技巧[3703:1577245] 你傻不傻: 设置 age 是空值</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-16 16:58:44.538293+0800 004-KVC异常小技巧[3703:1577245] 你傻不傻: 设置 sex 是空值</span></pre></td></tr><tr><td class="code"><pre><span class="line">2020-02-16 16:58:44.538487+0800 004-KVC异常小技巧[3703:1577245] 你傻不傻: 设置 threeFloats 是空值</span></pre></td></tr></table></figure>

<p>可以看出给subject设置空值时, 不会走该方法, 其余三个进行 nil 赋值时都会调用该方法抛出异常。官方文档上面说明的是针对需要转换为 <code>NSNumber 和 NSValue</code> 类型的数据赋值 nil 时会抛出异常, 所以 当我们给 <code>NSString</code> 类型的subject进行赋值时并没有报错。</p>
<h3 id="4-KVC-正确性验证"><a href="#4-KVC-正确性验证" class="headerlink" title="4. KVC 正确性验证"></a>4. KVC 正确性验证</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span></pre></td></tr></table></figure>

<p>该方法默认返回YES, 如果类中实现了该方法, 那么就会去调用新实现的方法来返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)validateValue:(inout id  _Nullable __autoreleasing *)ioValue forKey:(NSString *)inKey error:(out NSError *__autoreleasing  _Nullable *)outError&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if([inKey isEqualToString:@&quot;name&quot;])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [self setValue:[NSString stringWithFormat:@&quot;里面修改一下: %@&quot;,*ioValue] forKey:inKey];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return YES;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *outError &#x3D; [[NSError alloc]initWithDomain:[NSString stringWithFormat:@&quot;%@ 不是 %@ 的属性&quot;,inKey,self] code:10088 userInfo:nil];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return NO;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如上所示, 我们可以在该方法里面去验证某个key是否允许通过KVC去设定, 然后进行相关处理和返回。(注意: KVC是不会去主动验证的, 需要我们在该方法里面去实现验证。)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是KVC的一些原理和一些需要注意的点, 所有的东西都是通过阅读官方的文档和自己结合官方文档的一些理解。希望读者在看完后能对KVC有更进一步的理解, 同时推荐你们去看一下官方文档上的详细说明。如果有不对的地方或者不合理的地方欢迎大佬们提出, 我们一起学习, 一起进步。</p>
]]></content>
      <categories>
        <category>iOS底层学习</category>
      </categories>
      <tags>
        <tag>iOS探索</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS探索之--alloc、init 与 new</title>
    <url>/2019-12-24-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--alloc%E3%80%81init%20%E4%B8%8E%20new/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote>
<p>最近这段时间在跟 <a href="https://juejin.im/user/5c3f3c415188252b7d0ea40c/likes" target="_blank" rel="noopener">Cooci 老师</a> 学习 iOS 底层原理的探究, 然后准备在接下来的时间里把所学内容一步步整理下来。方便以后的回顾和查看, 也为自己定个目标和督促自己。如果文章中出现什么问题或错误, 希望各位大佬能多多指正和提出, 谢谢大家。一起努力, 共同进步😺!!!</p>
</blockquote>
<h3 id="一-源码跟踪"><a href="#一-源码跟踪" class="headerlink" title="一. 源码跟踪"></a>一. 源码跟踪</h3><p>一般情况下, 当我们想要去了解某个方法的实现的时候, 我们可以在工程里面 <code>command + Ctrl</code> 然后点击我们想要查看的方法。但是在系统方法上却不能找到我们想要的答案, 因为苹果公司并没有把所有方法的实现开源出来, 下面介绍几种寻找源码实现的方法:</p>
<h4 id="方法断点"><a href="#方法断点" class="headerlink" title="方法断点:"></a>方法断点:</h4><p>第一种方法就是我们通常使用通过给当前方法下断点, 然后逐步往后运行的方法。需要注意的地方如下图:</p>
<p><img src="/images/alloc,init,new-1.png" alt></p>
<center>图 1</center>
需要按住 ``` Ctrl``` 然后一步步往下执行, 才能找到我们需要的东西。还有就是需要在真机上进行调试, 模拟器会在 'pushq' 和 'jmp' 之间一直循环。


<p><img src="/images/alloc,init,new-2.png" alt></p>
<center>图 2</center>
最后得到的结果如上图2, ```libobjc.A.dylib``` 就是我们所要找的东西。

<h4 id="符号断点"><a href="#符号断点" class="headerlink" title="符号断点:"></a>符号断点:</h4><p>通过在程序运行中加入 <code>符号断点</code> 来拦截当前正在执行的方法, 如下图:</p>
<p><img src="/images/alloc,init,new-3.png" alt></p>
<center>图 3</center>
不过需要注意的是, 在开始打符号断点之前, 首先要先等程序走到我们之前打过的方法断点。因为比如上图的 ``` alloc``` 方法, 系统有太多的类会去调用该方法, 如果不先定位到方法断点, 就会一直走到符号断点, 无法确认当前 ```alloc``` 方法到底是哪个类调用的。

<h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编:"></a>汇编:</h4><p>使用这个方法首先需要设置 <code>xcode-&gt;Debug-&gt;Debug workflow-&gt;勾选 always Show Disassembly</code> , 然后重新启动程序。 在程序运行到我们的断点的时候就会直接进入汇编界面, 如下图:</p>
<p><img src="/images/alloc,init,new-4.png" alt></p>
<center>图 4</center>
找到我们想要了解的方法, 上图中红框内的 ```objc_alloc```, 就是我想要去找的方法。然后继续断点, 按住 ``` Ctrl``` , 一步步执行, 一直到如下页面:


<p><img src="/images/alloc,init,new-5.png" alt></p>
<center>图 5</center>
最后的结果如上图。(ps: 如果你发现最后的结果跟上面不一样, 不要慌, 修好车, 我们从头再来 !!!)



<h3 id="二-alloc-amp-init-amp-new-探究"><a href="#二-alloc-amp-init-amp-new-探究" class="headerlink" title="二. alloc &amp; init &amp; new 探究"></a>二. alloc &amp; init &amp; new 探究</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备:"></a>准备:</h4><p>通过上面的方法, 我们找到了我们的方法所在的位置。然后下一步就去展开对源码的探究吧, 具体准备如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc4-750源码 + Xcode 11 + MacOS 10.15</span></pre></td></tr></table></figure>

<p><a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">官方源码地址</a></p>
<p>官方的源码下载下来是不能直接编译的, 我们还需要做一下后面的处理, 具体处理步骤在这里 😝 :<a href="https://juejin.im/post/5d9c829df265da5ba46f49c9" target="_blank" rel="noopener">iOS_objc4-756.2 最新源码编译调试</a> , 当然你也可以直接下载下来。</p>
<h4 id="1-alloc-原理"><a href="#1-alloc-原理" class="headerlink" title="1. alloc 原理:"></a>1. alloc 原理:</h4><p>环境配置好之后, 在 <code>alloc</code> 方法打上断点, 然后一步步往下层查看。</p>
<p><img src="/images/alloc,init,new-6.png" alt></p>
<center>图6 准备代码</center>
##### alloc 流程图:

<p>废话少说, 先放上我根据调试流程画的 alloc 流程图:</p>
<hr>
<p><img src="/images/alloc,init,new-7.png" alt></p>
<hr>
<center>图7 alloc 流程图</center>
从流程图上可以看出, 在 ``` callAlloc()``` 方法执行以后, 程序开始出现分叉, 下面是方法源码:

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span></pre></td></tr><tr><td class="code"><pre><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;*** 此处不需要了 ***&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    #if __OBJC2__</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (fastpath(cls-&gt;canAllocFast())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F; No ctors, raw isa, etc. Go straight to the metal.</span></pre></td></tr><tr><td class="code"><pre><span class="line">            bool dtor &#x3D; cls-&gt;hasCxxDtor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            id obj &#x3D; (id)calloc(1, cls-&gt;bits.fastInstanceSize());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if (slowpath(!obj)) return callBadAllocHandler(cls);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return obj;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F; Has ctor or raw isa or something. Use the slower path.</span></pre></td></tr><tr><td class="code"><pre><span class="line">          	&#x2F;&#x2F; 重点在这里</span></pre></td></tr><tr><td class="code"><pre><span class="line">            id obj &#x3D; class_createInstance(cls, 0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if (slowpath(!obj)) return callBadAllocHandler(cls);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return obj;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    #endif</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#x2F;*** 此处也不要了 ***&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>接下来我们首先一起看一下 <code>fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())</code> 这个条件是否成立, </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; hasCustomAWZ()的实现</span></pre></td></tr><tr><td class="code"><pre><span class="line">bool hasCustomAWZ() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return ! bits.hasDefaultAWZ();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; hasDefaultAWZ()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 出现宏定义, FAST_HAS_DEFAULT_AWZ 和 RW_HAS_DEFAULT_AWZ</span></pre></td></tr><tr><td class="code"><pre><span class="line">#if FAST_HAS_DEFAULT_AWZ</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bool hasDefaultAWZ() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return data()-&gt;flags &amp; RW_HAS_DEFAULT_AWZ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void setHasDefaultAWZ() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        data()-&gt;setFlags(RW_HAS_DEFAULT_AWZ);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void setHasCustomAWZ() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        data()-&gt;clearFlags(RW_HAS_DEFAULT_AWZ);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr></table></figure>

<p>下面是我根据宏定义的名字搜索到的具体定义, 由于内容较多进行了删减</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if !__LP64__ &#x2F;&#x2F; 如果是 32位的话</span></pre></td></tr><tr><td class="code"><pre><span class="line">	...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; class or superclass has default alloc&#x2F;allocWithZone: implementation</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Note this is is stored in the metaclass.</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define RW_HAS_DEFAULT_AWZ    (1&lt;&lt;16)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#elif 1	&#x2F;&#x2F; if (1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; class or superclass has default alloc&#x2F;allocWithZone: implementation</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Note this is is stored in the metaclass.</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define RW_HAS_DEFAULT_AWZ    (1&lt;&lt;16)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;* 在这里, FAST_ALLOC 和 FAST_HAS_DEFAULT_AWZ 根本没有被编译 *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#else &#x2F;&#x2F; 好像走不到这里😹</span></pre></td></tr><tr><td class="code"><pre><span class="line">	...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; summary bit for fast alloc path: !hasCxxCtor and </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;   !instancesRequireRawIsa and instanceSize fits into shiftedSize</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define FAST_ALLOC              (1UL&lt;&lt;2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; class or superclass has default alloc&#x2F;allocWithZone: implementation</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Note this is is stored in the metaclass.</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define FAST_HAS_DEFAULT_AWZ    (1UL&lt;&lt;48)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据上面的宏定义我发现</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ()) 结果为 true, 因为 cls-&gt;ISA()-&gt;hasCustomAWZ() 结果为false</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; fastpath(cls-&gt;canAllocFast()) 结果为 false, 因为 canAllocFast() 结果为 false</span></pre></td></tr></table></figure>

<p>经过上面的分析, 我们最后来到了 <code>id obj = class_createInstance(cls, 0);</code> 该方法里面, 从方法名字就可以得出 “创建对象”, 我们继续查看该方法的内部实现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id class_createInstance(Class cls, size_t extraBytes) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return _class_createInstanceFromZone(cls, extraBytes, nil);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">static __attribute__((always_inline)) </span></pre></td></tr><tr><td class="code"><pre><span class="line">id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </span></pre></td></tr><tr><td class="code"><pre><span class="line">                              bool cxxConstruct &#x3D; true, </span></pre></td></tr><tr><td class="code"><pre><span class="line">                              size_t *outAllocatedSize &#x3D; nil) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (!cls) return nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#x2F;&#x2F; Locking: To prevent concurrent realization, hold runtimeLock.</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	&#x2F;&#x2F; 加锁, 防止该步骤的并发实现, 保持运行时锁定</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert(cls-&gt;isRealized());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bool hasCxxCtor &#x3D; cls-&gt;hasCxxCtor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bool fast &#x3D; cls-&gt;canAllocNonpointer(); &#x2F;&#x2F; 是否需要初始化 isa 指针</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    size_t size &#x3D; cls-&gt;instanceSize(extraBytes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    id obj;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (!zone  &amp;&amp;  fast) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        obj &#x3D; (id)calloc(1, size); &#x2F;&#x2F; 内存申请</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (!obj) return nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor); &#x2F;&#x2F; 初始化 isa</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (zone) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            obj &#x3D; (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            obj &#x3D; (id)calloc(1, size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (!obj) return nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be </span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; doing something weird with the zone or RR.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        obj-&gt;initIsa(cls);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        obj &#x3D; _objc_constructOrFree(obj, cls);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return obj;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在对上面代码的分析中, 我们找到了 <code>内存申请 (id)calloc(1, size);</code> 和 <code>初始化 isa指针 obj-&gt;initInstanceIsa(cls, hasCxxDtor);</code> 的方法, 那么在这之前还有一行代码需要我们去注意:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_t size &#x3D; cls-&gt;instanceSize(extraBytes); &#x2F;&#x2F; 获取需要开辟的内存大小</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        size_t size &#x3D; alignedInstanceSize() + extraBytes;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (size &lt; 16) size &#x3D; 16;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Class&#39;s ivar size rounded up to a pointer-size boundary.</span></pre></td></tr><tr><td class="code"><pre><span class="line">uint32_t alignedInstanceSize() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	return word_align(unalignedInstanceSize());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 7+8 &#x3D; 15</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 0000 1111</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 0000 1000</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 1111 1000 ~7</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 0000 1000 8</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 0000 0111</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; x + 7</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 8</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 8 二阶</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; (x + 7) &gt;&gt; 3 &lt;&lt; 3</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里可以看出, 我们的系统通过一系列的算法操作, 最后帮我们算出了所需开辟的内存大小。那么这个结果是具体怎么来的, 这就关系到了 <u>内存对齐</u> 方面的内容, 我们放到下一期里面讨论吧😝。</p>
<h4 id="2-init-原理"><a href="#2-init-原理" class="headerlink" title="2. init 原理:"></a>2. init 原理:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)init &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return _objc_rootInit(self);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">id _objc_rootInit(id obj) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; In practice, it will be hard to rely on this function.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; Many classes do not properly chain -init calls.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return obj;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>至于 <code>init</code> 方法就相对简单了, 因为他什么都没有做, 只是 返回了 self。<code>init</code> 方法之所以这样实现其实是为了提供 <strong>工厂设计模式</strong> 下的接口方法, 给子类去自定义重写该方法。</p>
<p>谈到 <code>init</code> , 我们会想起在日常写代码中用到的 <code>self = [super init]</code> , 那么我们为什么要这样写呢 ? 结合自己的想法 和 网上找到的意见我总结出一下几点:</p>
<blockquote>
<ol>
<li>想要确定父类在初始化中是否失败或者直接返回 nil</li>
<li>父类有可能不是去返回self, 而是去返回另外一个不同的对象。这种情况我们可能很少见, 在苹果的 <code>Foundation</code> 框架中存在一种设计模式 <strong><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html#//apple_ref/doc/uid/TP40010810-CH4-SW1" target="_blank" rel="noopener">类集群(类簇)</a></strong> , 该模式下就存在这种情况。(扩展: <a href="http://blog.sunnyxx.com/2014/12/18/class-cluster/" target="_blank" rel="noopener">有关类簇的探讨</a>)</li>
<li>单例对象, 假如父类是单例的话这里的返回同样会出问题</li>
</ol>
</blockquote>
<h4 id="3-New-方法"><a href="#3-New-方法" class="headerlink" title="3. New 方法:"></a>3. New 方法:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (id)new &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return [callAlloc(self, false&#x2F;*checkNil*&#x2F;) init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过查看 <code>new</code> 方法的源码, 我们发现该方法总共做了两件事。首先通过 <code>callAlloc</code> 方法申请内存, 然后再去调用 <code>init</code> 方法, 其实就是对上面两个方法的整合。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语:"></a>结语:</h2><p>以上就是本人这段时间结合所学的东西进行的一些总结, 如果有错误和不足的地方欢迎大佬们纠正。 大家一起探讨, 共同进步 !!!</p>
<p><u><em>45°仰望天空, 做更好的自己~</em></u></p>
]]></content>
      <categories>
        <category>iOS底层学习</category>
      </categories>
      <tags>
        <tag>iOS探索</tag>
      </tags>
  </entry>
  <entry>
    <title>GitLab 学习</title>
    <url>/2018-12-20-GitLab-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>最近公司的新项目部署到了gitlab上面, 鉴于之前一直在使用svn, 这里写篇文章记录下自己最近对于gitlab的相关学习。</p>
<h4 id="一-什么是Git"><a href="#一-什么是Git" class="headerlink" title="一. 什么是Git"></a>一. 什么是Git</h4><p>git就是一种 <strong>版本控制</strong> 工具, 说到版本控制, 我们可能想到了另外一个工具 svn。但是两者在本质上又有着区别。</p>
<p>首先, svn 是集中化的版本控制系统, 即只有一个单一的集中管理服务器, 用来保存所有文件的修订版本。 所有协同工作的人员都通过客户端连接到这台服务器, 进行最新文件的更新或者所修改文件的提交。</p>
<p>git 是分布式的版本控制系统, 没一个终端都是一个仓库。客户端不只是去提取最新版本文件的快照, 而是把原始的代码仓库完整的克隆到本地; 每一次的提取操作, 实际上都是一次对代码仓库的完整备份。</p>
<p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-1.png" alt></p>
<center>图1 集中式版本控制</center>



<p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-2.png" alt></p>
<center>图2 分布式管理控制</center>






<h4 id="二-GitLab基本使用"><a href="#二-GitLab基本使用" class="headerlink" title="二. GitLab基本使用"></a>二. GitLab基本使用</h4><h5 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h5><ul>
<li><p><strong>登录</strong></p>
<p>先说一下, 这个一般是布在内网服务器的, 就是去联系管理员去要账号。昨天同事问我gitlab有没有账号, 我敲了个gitlab的网址, 然后就傻乎乎的去注册了😂。 一顿操作猛如虎后领导给我了个内网的地址, 然后给了我一个账号(🙅‍♀️)… </p>
<p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-3.png" alt></p>
<center>图3 登录页面</center>




</li>
</ul>
<p>  登录页面如图三, 有两种不同的登录方式, 具体看公司给你的账号吧。最后一个tab是注册的, 我这里没有用到, 具体情况应该会有人告诉你的。</p>
<ul>
<li><p><strong>设置</strong></p>
<p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-4.png" alt></p>
</li>
</ul>
<center>图4 账号设置页面</center>




<p>​        账号设置页面, 可以补充一下自己的个人信息, 同时在  ‘Preferred language’ 项里面也可以设置自己的偏好语言(支持中文)。</p>
<h5 id="2-项目创建-和-用户管理"><a href="#2-项目创建-和-用户管理" class="headerlink" title="2. 项目创建 和 用户管理"></a>2. 项目创建 和 用户管理</h5><ul>
<li>项目管理<ol>
<li>新建项目</li>
<li>编辑或删除项目</li>
</ol>
</li>
<li>用户管理<ol>
<li>新建用户</li>
<li>编辑或删除用户</li>
<li>组管理</li>
<li>权限说明</li>
</ol>
</li>
</ul>
<p>*<em>注意: *</em>以上内容均为管理员操作内容, 由于本人没有权限, 也没有亲自操作过, 所以不做介绍。可以通过下面的链接进行了解(<a href="https://blog.csdn.net/Adelly/article/details/79099772#_Toc480656596" target="_blank" rel="noopener">GitLab使用教程</a>)。</p>
<h4 id="三-GitLab-使用配置"><a href="#三-GitLab-使用配置" class="headerlink" title="三. GitLab 使用配置"></a>三. GitLab 使用配置</h4><h5 id="1-配置SSH-key"><a href="#1-配置SSH-key" class="headerlink" title="1. 配置SSH-key"></a>1. 配置SSH-key</h5><p>git仓库之间代码的传输协议主要使用 ssh 协议。而一般搭建 gitlab 的时候使用的git用户是没有密码的, 因此直接 ssh 是不能登录的, 需要使用 ssh-key 上传公钥, 使用非对称加密传输。</p>
<ol>
<li>查看之前是否生成个 id_rsa.pub 文件</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ls (列举目录文件名, 查看目录是否有 id_rsa.pub 文件)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 如果存在, 查看公钥: cat id_rsa.pub 或者 vim id_rsa.pub</span></pre></td></tr></table></figure>

<p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-5.png" alt></p>
<center>图5</center>


<p>效果如上图, 因为我之前已经生成过, 所以会有结果。如果你之前生成过, 执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span></pre></td></tr></table></figure>

<p>对你的 ssh-key 进行拷贝操作</p>
<ol start="2">
<li>终端未出现id_rsa.pub 或 id_dsa.pub文件，表示该电脑还没有配置SSH Key, 继续输入以下命令:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#  -t 为指定加密方式为RSA， -C 为指定邮箱。命令完成后目录下会生成id_rsa(私钥)和id_rsa.pub（公钥）</span></pre></td></tr><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span></pre></td></tr></table></figure>

<p>注意, 这里的 email 就用自己常用的邮箱即可。执行完以后不出意外文件就生成出来了, 中间可能会要求输入开机密码, 其余一直回车即可。生成的文件可以前往 ‘~/.ssh’ 该路径下面去找, 如果不确定, 可以回到第一步去验证一下。</p>
<ol start="3">
<li>生成以后通过在步骤1对你的ssh-key进行过拷贝操作, 然后在gitlab网页上面依次点击 “头像-&gt; Settings -&gt; SSH Keys”</li>
</ol>
<p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-6.png" alt></p>
<center>图6</center>


<p>如图, 将步骤1拷贝的key直接粘贴到 ‘key’ 里面, 然后设置 ‘title’, 点击 Add Key 即可。</p>
<h4 id="四-GitLab使用"><a href="#四-GitLab使用" class="headerlink" title="四. GitLab使用"></a>四. GitLab使用</h4><h5 id="1-使用命令行工具"><a href="#1-使用命令行工具" class="headerlink" title="1. 使用命令行工具"></a>1. 使用命令行工具</h5><p>GitLab使用命令行工具通git, 这里不再描述了, 如果想要熟悉命令可以通过 <code>git --help</code> 指令查看。</p>
<h5 id="2-通过-SourceTree-图形化管理工具"><a href="#2-通过-SourceTree-图形化管理工具" class="headerlink" title="2. 通过 SourceTree 图形化管理工具"></a>2. 通过 SourceTree 图形化管理工具</h5><p>如果你不喜欢命令行的使用方式, 也可以使用 git 的图形化管理工具 SourceTree 进行统一管理, </p>
<p>界面如下图, 界面简洁, 使用也很方便。<a href="https://www.sourcetreeapp.com" target="_blank" rel="noopener">SourceTree官网</a></p>
<p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-7.png" alt></p>
<center>图 7</center>




<h5 id="3-使用-Xcode-进行git管理"><a href="#3-使用-Xcode-进行git管理" class="headerlink" title="3. 使用 Xcode 进行git管理"></a>3. 使用 Xcode 进行git管理</h5><p>如果你使用的是Mac, 并且开发使用xcode的话, 也可以通过xcode来对git进行统一管理。</p>
<p>具体步骤如下:</p>
<ol>
<li>打开Xcode, 选择 <code>Clone an existing project</code> :</li>
</ol>
<p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-8.png" alt></p>
<center>图 8</center>


<p>​    </p>
<ol start="2">
<li>接下来弹出的窗口需要你输入所要 clone 的项目的 URL, 将自己的项目地址 copy 进去即可:</li>
</ol>
<p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-9.png" alt></p>
<center>图 9</center>


<p>点击 <code>Clone</code> 按钮进行克隆, 弹出选择你需要克隆的分支, 这个根据需要自行选择就好, 然后一直点下去会出现让你登录用户名的对话框。输入登录名和密码, 成功。</p>
<ol start="3">
<li>接下来就是通过 <code>xcode</code> 对自己的代码进行 更新和提交操作。可以通过 xcode 工具栏上方的 </li>
</ol>
<p><code>Source Control -&gt; Commit/Pull/Push</code> 来进行, 需要注意的是, 在进行 pull 和 push 操作时一定要注意当前分支, 然后在 push 的时候最好对自己的提交内容进行详细说明, 这也是团队合作所必要的。</p>
<p>*<em>结语: *</em>上面这些就是我今天所学习的 GitLab 相关的内容, 可能不是很全面, 在后续的使用过程中有可能会遇到更多的问题需要补充。仅此以记录自己的学习情况, 不喜勿喷😀<del>~</del></p>
<p><em>Be a better yourself !!!</em></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理之内存管理方式(二)</title>
    <url>/2017-06-10-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F(%E4%BA%8C)/</url>
    <content><![CDATA[<p>之前一篇文章介绍了一下内存区域的划分以及平时我们程序中涉及到的一些变量常量等的存储方式, 下面主要是去整理一下有关内存的管理方式(手动内存管理 和 自动内存管理)和 property 参数方面的知识。提到管理方式, 首先不得不去说一下 引用计数的概念:</p>
<h4 id="1-引用计数的概念-Reference-Count"><a href="#1-引用计数的概念-Reference-Count" class="headerlink" title="1. 引用计数的概念 (Reference Count)"></a>1. 引用计数的概念 (Reference Count)</h4><p><code>引用计数</code> 即 Objective-C 管理对象生命周期的方式, 当我们创建一个对象时, 初始的引用计数为1, 为了保证对象一直存在, 每当引用该对象时, 会通过向其发送 retain 消息使引用计数 +1, 当不再需要该对象时会去发送 release 消息使其引用计数 -1, 当对象的引用计数为 0 时, 系统会通过给对象发送 dealloc 消息销毁对象并回收内存。</p>
<p>*<em>注意: *</em>在MRC下, 这里当我们使用完一个对象没有进行release操作时, 此时对象的引用计数会永远大于1, 该对象就会一直占有内存空间无法释放, 从而造成<code>内存泄漏</code>。当<code>内存泄漏</code>到一定程度的话就有可能<code>内存溢出</code>, 进而导致程序崩溃。</p>
<table>
<thead>
<tr>
<th align="center">对象操作</th>
<th align="center">Objective-C方法</th>
<th align="center">对应操作结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">生成并持有对象</td>
<td align="center">alloc, new, copy, mutableCopy 等方法</td>
<td align="center">生成对象并设置引用计数为1</td>
</tr>
<tr>
<td align="center">持有对象</td>
<td align="center">retain</td>
<td align="center">使对象的引用计数 +1</td>
</tr>
<tr>
<td align="center">释放对象</td>
<td align="center">release</td>
<td align="center">使对象的引用计数 -1</td>
</tr>
<tr>
<td align="center">销毁对象</td>
<td align="center">dealloc方法 — 系统调用</td>
<td align="center">对象的引用计数为 0 时调用</td>
</tr>
</tbody></table>
<h4 id="2-手动引用计数-MRC-Manual-Reference-Count"><a href="#2-手动引用计数-MRC-Manual-Reference-Count" class="headerlink" title="2. 手动引用计数(MRC / Manual Reference Count)"></a>2. 手动引用计数(MRC / Manual Reference Count)</h4><p><code>手动引用计数</code> 即引用计数的管理是由我们自己通过对对象的 retain / release 等操作去完成的, 需要我们自己去跟踪对象来明确的管理内存。</p>
<h5 id="2-1-alloc-new-copy-mutableCopy"><a href="#2-1-alloc-new-copy-mutableCopy" class="headerlink" title="2.1 alloc / new / copy / mutableCopy"></a>2.1 alloc / new / copy / mutableCopy</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *array &#x3D; [[NSMutableArray alloc] init]; &#x2F;&#x2F; 创建对象 array</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%p&quot;, array);</span></pre></td></tr><tr><td class="code"><pre><span class="line">[array release];&#x2F;&#x2F; 释放 array</span></pre></td></tr></table></figure>

<p>以上第一行我们通过 alloc 去创建数组对象 array, 此时对象的引用计数为1, 然后我们对其指针进行打印。打印完成以后我们不需要此对象了, 就去调用 release 方法使其引用计数 -1, 此时对象的引用计数为 0, 会触发 dealloc 方法对其进行回收操作。然后如果我们再去访问 array对象, 就可能发生崩溃。</p>
<h5 id="2-2-retain-操作"><a href="#2-2-retain-操作" class="headerlink" title="2.2 retain 操作"></a>2.2 retain 操作</h5><h6 id="2-2-1-retain-与-属性"><a href="#2-2-1-retain-与-属性" class="headerlink" title="2.2.1 retain 与 属性"></a>2.2.1 retain 与 属性</h6><p>我们可以通过属性来保存一个对象, 我们可以通过属性的实例变量和存取方法来对某个对象进行操作, 例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setPerson:(Person *)person &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [person retain];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [_person release];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _person &#x3D; person;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上方法中, 我们通过先 retain 新值, 然后 release 旧值的操作, 打到给我们的属性更新值的目的。需要注意的是: 需要首先去 retain 新值, 因为如果新值 和 旧值是同一个对象的话, 如果我们先调用 release 方法就有可能导致对象被释放掉, 那样再去调用 retain 就没有意义了。再如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@interface ViewController ()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, retain)Person *person;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@end</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">@implementation ViewController</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	[super viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 实力变量持有 Person 类对象, 这样赋值不会调用 set 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    self.person &#x3D; _person;&#x2F;&#x2F; 调用 set 方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)setPerson:(Person *)person &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; release 释放对象, _person对象的引用计数值为0, 对象会被系统回收</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [_person release];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 由于对象已经被回收, 再去 retain 就容易出问题</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _person &#x3D; person;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@end</span></pre></td></tr></table></figure>

<p>由于对象对应的内存已经被系统回收, 如果该块内存还没有被覆盖, 那么 该对象会可以使用, 如果内存已经被覆盖, 那么就会指向一个被覆盖了的位置对象, 此实例变量就会变成一个<code>悬挂指针</code>。</p>
<h6 id="2-2-2-retain-与-数组"><a href="#2-2-2-retain-与-数组" class="headerlink" title="2.2.2 retain 与 数组"></a>2.2.2 retain 与 数组</h6><p>如果我们将一个对象加入到一个数组中去, 该数组的 addObject 方法同样会对该对象做 retain 操作, 比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先创建对象 person</span></pre></td></tr><tr><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建数组 array</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSMutableArray *array &#x3D; [[NSMutableArray alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将person对象添加到array数组当中</span></pre></td></tr><tr><td class="code"><pre><span class="line">[array addObject:person];&#x2F;&#x2F; 此时 person 的引用计数为2</span></pre></td></tr></table></figure>

<h5 id="2-3-release-操作"><a href="#2-3-release-操作" class="headerlink" title="2.3 release 操作"></a>2.3 release 操作</h5><h6 id="2-3-1-释放自己持有的对象"><a href="#2-3-1-释放自己持有的对象" class="headerlink" title="2.3.1 释放自己持有的对象"></a>2.3.1 释放自己持有的对象</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建 array 对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSArray *array &#x3D; [[NSArray alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 释放</span></pre></td></tr><tr><td class="code"><pre><span class="line">[array release];</span></pre></td></tr></table></figure>

<h6 id="2-3-2-过度释放对象问题"><a href="#2-3-2-过度释放对象问题" class="headerlink" title="2.3.2 过度释放对象问题"></a>2.3.2 过度释放对象问题</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建 array 对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSArray *array &#x3D; [[NSArray alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 释放</span></pre></td></tr><tr><td class="code"><pre><span class="line">[array release];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 再释放</span></pre></td></tr><tr><td class="code"><pre><span class="line">[array release];&#x2F;&#x2F; 过度释放</span></pre></td></tr></table></figure>

<h5 id="2-4-autorelease"><a href="#2-4-autorelease" class="headerlink" title="2.4. autorelease"></a>2.4. autorelease</h5><p><code>autorelease</code> 指的是自动释放操作, 当一个对象收到 autorelease 消息的时候, 该对象就会被注册到当前处于栈顶的自动释放池(autorelease pool)。如果没有主动生成自动释放池, 则当前自动释放池对应的是主运行循环的自动释放池。当前线程的RunLoop进入休眠之前, 就回对被注册到该自动释放池的所有对象进行一次 release 操作。</p>
<p>autorelease 和 release 的主要区别就是: release 会立马对对象发送消息, autorelease则是延迟发送。</p>
<p>autorelease 通常运用在当调用某个方法需要返回对象的情况下, 例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (id)person &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 初始化需要返回的person对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person *person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; [person release];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [person autorelease];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    return person;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>很显然这里是不能进行<code>release</code>操作的, 因为如果对象还没有返回就被 release 的话就没有意义了。通过使用 autorelease方法, 将对象的释放注册到自动释放池中区, 可以延长对象的生命周期, 使其在 autorelease pool 结束前一直能够使用。</p>
<p>另外, 因为我们已经将该对象放入了自动释放池中, 就不需要再次对其release操作了, 如果有别的对象需要持有该对象, 只需要再次对其 retain 操作就好了, 使用完以后注意 release。</p>
<h5 id="2-5-autorelea-pool-自动释放池"><a href="#2-5-autorelea-pool-自动释放池" class="headerlink" title="2.5. autorelea pool(自动释放池)"></a>2.5. autorelea pool(自动释放池)</h5><h6 id="2-5-1-autorelease-pool-和-RunLoop"><a href="#2-5-1-autorelease-pool-和-RunLoop" class="headerlink" title="2.5.1 autorelease pool 和 RunLoop"></a>2.5.1 autorelease pool 和 RunLoop</h6><p>每条线程都包含一个与其对应的自动释放池, 当某条线程被终止的时候, 对应线程的自动释放池也会被销毁。同时, 处于该自动释放池中的对象也会做一次 release 操作。</p>
<p>当应用程序启动时, 系统会默认开启一条线程(主线程), 主线程也有一个与之对应的自动释放池, 例如: ARC 下 main 文件中的 autoreleasepool。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@autoreleasepool &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return UIApplication(argc, argv, nil, NSStringFromClass([APPDelegate class]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>该自动释放池用来释放在主线程下注册到该自动释放池的对象。需要注意的是, 当我们开启一条子线程, 并且在该线程开启 RunLoop 的时候, 需要为其增加一个 autoreleasepool, 这样有助于保证内存的安全。</p>
<h6 id="2-5-2-autorelease-pool-和-降低内存峰值"><a href="#2-5-2-autorelease-pool-和-降低内存峰值" class="headerlink" title="2.5.2 autorelease pool 和 降低内存峰值"></a>2.5.2 autorelease pool 和 降低内存峰值</h6><p>当我们执行一些复杂操作的时候, 特别是如果这些复杂的操作要被循环执行, 那么中间免不了会产生一些临时的变量。当被加到主线程自动释放池的对象越来越多, 却没有及时释放时, 就会导致内存溢出。这个时候, 我们可以通过手动添加自动释放池来解决这个问题。如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 创建自动释放池</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSAutoreleasePool *pool &#x3D; [[NSAutoreleasePool alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 生成对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">    id obj &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [pool drain];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在for循环中我们会循环很多次, 每次都会去生成新的对象, 因为生成的对象会在for循环结束以后才回去释放, 这样会有可能生成过多的对象。我们通过手动生成一个自动释放池, 每次在循环结束前就把对象释放掉, 这样就可以有效的降低内存的峰值。</p>
<h4 id="3-自动引用计数-ARC-Automatic-Reference-Counting"><a href="#3-自动引用计数-ARC-Automatic-Reference-Counting" class="headerlink" title="3. 自动引用计数 (ARC / Automatic Reference Counting)"></a>3. 自动引用计数 (ARC / Automatic Reference Counting)</h4><p><code>自动引用计数</code> 即一般情况下, 引用计数的管理是系统帮我们去做的, 所以在ARC下要比MRC下更方便的管理内存。</p>
<h5 id="3-1-strong"><a href="#3-1-strong" class="headerlink" title="3.1. __strong"></a>3.1. __strong</h5><p>在 ARC 模式下, id类型 和 OC 对象的所有权修饰符默认是 __strong修饰的, 当该变量超出其作用域以后就会被释放掉, 同时对应的值也会被释放掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 创建对象 person </span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person *person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 超出作用域, person对象将会被释放掉</span></pre></td></tr></table></figure>

<p>由此可以看出, 在ARC下, 我们不需要去管理对象的引用计数(进行 retain 或者 release操作), 系统会帮我们去处理对象的生命周期。</p>
<h6 id="3-1-1-stong声明属性"><a href="#3-1-1-stong声明属性" class="headerlink" title="3.1.1 stong声明属性"></a>3.1.1 stong声明属性</h6><p>如果一个属性的修饰符是 strong 类型, 编译器会在类的 dealloc 方法中添加释放对象的方法, 不需要我们手动的去处理了, 但是如果有如 CoreFoundation 等非OC对象, 则需要我们去手动的回收对象, 如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    CFRelease(_cfObject);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">在ARC下, dealloc方法一般用来执行两个任务。一个是用来 手动的释放掉非OC对象(类似上面), 另一个就是去解除监听。另外, 我们不能在ARC下去主动调用 dealloc 方法, 因为 dealloc 的对象就不再有效, 该方法是由系统在 运行时 根据何时的时机去调用的。</span></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理之内存区域划分(一)</title>
    <url>/2017-05-17-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86(%E4%B8%80)/</url>
    <content><![CDATA[<p>最近在重新回过头去看内存管理方面的知识, 一方面去试着总结一下相关的东西吧, 另一方面也是想通过去试着自己去写一下然后使自己的知识掌握更加牢固, 下面是我将内存管理整个的层次划分, 以后的内容会相继的一一补上去:</p>
<p><img src="/.com//yujialei/Documents/%E4%B8%B4%E6%97%B6%E6%88%AA%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%92%E5%88%86.png" alt="内存管理划分"></p>
<h4 id="1-区域划分"><a href="#1-区域划分" class="headerlink" title="1.区域划分"></a>1.区域划分</h4><ul>
<li><p>栈区(stack): 由编译器自动分配和释放, 存放函数的参数值和局部变量的值等。 栈为系统数据机构, 对于的 线程/进程 是唯一的。</p>
<p>优点是快速高效, 缺点为数据不够灵活(先进后出原则)</p>
</li>
<li><p>堆区(heap): 由程序员分配和释放, 如果程序员不释放, 在程序结束时, 可能会被系统回收, 比如在 iOS 中 alloc 都是存放在堆中的。</p>
<p>优点是灵活方便, 数据适应面广, 但是效率有一定降低。</p>
<p>堆是向高地址扩展的数据结构, 不连续的内存区域。系统用链表存储空闲地址, 链表遍历由低向高, 堆的大小直接受设备有效虚拟内存影响。</p>
</li>
</ul>
<ul>
<li><p>全局区(静态区)(static): 静态变量和全局变量是存储在意起的, 初始化的全局变量和静态变量存储的一块区域 (初始化全局区: BSS段), 未初始化的全局变量和静态变量在相邻的另一块区域存储(未初始化全局区: Data段), 程序结束后会系统释放。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a; &#x2F;&#x2F; 未初始化的静态区</span></pre></td></tr><tr><td class="code"><pre><span class="line">int b &#x3D; 1; &#x2F;&#x2F; 初始化的静态区</span></pre></td></tr></table></figure>
</li>
<li><p>文字常量区: 存放常量字符串, 程序结束后由系统释放</p>
</li>
<li><p>代码区: 存放函数的二进制代码</p>
</li>
</ul>
<h4 id="2-申请后的响应"><a href="#2-申请后的响应" class="headerlink" title="2.申请后的响应"></a>2.申请后的响应</h4><ul>
<li><p>栈</p>
<blockquote>
<p>存储每一个函数的时候都会向操作系统索要资源, 栈区就是函数运行时的内存, 栈区中的变量由编译器负责分配和释放, 内存随着函数的运行进行分配, 随着函数的结束而释放, 由系统自动完成。</p>
<p>注意: 如果栈的剩余空间大于所申请空间, 系统将为程序提供内存, 否则将会报异常提示栈溢出。</p>
</blockquote>
</li>
<li><p>堆</p>
<blockquote>
<ol>
<li>首先应该知道操作系统有一个记录空闲内存地址的链表。</li>
<li>当系统收到程序的申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆结点, 然后将该结点从空闲结点链表中删除</li>
<li>由于找到的堆结点的大小不一定刚好等于申请的大小, 系统会自动的将多余的部分重新放入到空闲链表中</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="3-申请大小的限制"><a href="#3-申请大小的限制" class="headerlink" title="3.申请大小的限制"></a>3.申请大小的限制</h4><ol>
<li><p>栈: 栈是向低地址扩展的数据结构, 是一块连续的内存区域。栈顶的地址和栈的最大容量是由系统预先规定好的, 栈的大小为2M (有的说1M, 总之是一个编译时就确定的常数), 如果申请的空间超过栈的剩余空间, 会提示 overFlow。因此, 能从栈获得的空间较小。</p>
</li>
<li><p>堆: 堆是向高地址扩展的数据结构, 是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的, 自然是不连续的, 而链表的遍历方向是由低到高的。堆的大小受限于系统中的有效虚拟内存。由此可见, 堆获得的空间比较灵活, 也相对较大。</p>
</li>
<li><p>栈: 由系统自动分配, 速度较快, 不会产生内存碎片</p>
</li>
<li><p>堆: alloc 分配, 速度较慢, 容易产生内存碎片, 使用方便</p>
</li>
</ol>
<h4 id="4-下面通过对字符串的初始化-来分析内存分布情况"><a href="#4-下面通过对字符串的初始化-来分析内存分布情况" class="headerlink" title="4.下面通过对字符串的初始化, 来分析内存分布情况"></a>4.下面通过对字符串的初始化, 来分析内存分布情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *str0 &#x3D; @&quot;123&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSLog(@&quot;str0 &#x3D; %p, str0 &#x3D; %@&quot;, str0, str0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSString *str1 &#x3D; @&quot;123&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSLog(@&quot;str1 &#x3D; %p, str1 &#x3D; %@&quot;, str1, str1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSString *str2 &#x3D; @&quot;456&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSLog(@&quot;str2 &#x3D; %p, str2 &#x3D; %@&quot;, str2, str2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSLog(@&quot;-----------------------------------&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSString *str3 &#x3D; [[NSString alloc] initWithFormat:@&quot;123&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSLog(@&quot;str3 &#x3D; %p, str3 &#x3D; %@&quot;, str3, str3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSString *str4 &#x3D; [[NSString alloc] initWithFormat:@&quot;123&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSLog(@&quot;str4 &#x3D; %p, str4 &#x3D; %@&quot;, str4, str4);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSString *str5 &#x3D; [[NSString alloc] initWithFormat:@&quot;456&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSLog(@&quot;str5 &#x3D; %p, str5 &#x3D; %@&quot;, str5, str5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSLog(@&quot;-----------------------------------&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSString *str6 &#x3D; [[NSString alloc] initWithString:str3];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSLog(@&quot;str6 &#x3D; %p, str6 &#x3D; %@&quot;, str6, str6);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSString *str7 &#x3D; [[NSString alloc] initWithString:str3];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSLog(@&quot;str7 &#x3D; %p, str7 &#x3D; %@&quot;, str7, str7);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSString *str8 &#x3D; [[NSString alloc] initWithString:str4];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSLog(@&quot;str8 &#x3D; %p, str8 &#x3D; %@&quot;, str8, str8);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSString *str9 &#x3D; [[NSString alloc] initWithString:str5];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   NSLog(@&quot;str9 &#x3D; %p, str9 &#x3D; %@&quot;, str9, str9);</span></pre></td></tr></table></figure>

<p>打印结果如下图:</p>
<p> <img src="http://p9y1zwo62.bkt.clouddn.com/%E5%8F%98%E9%87%8F%E5%9C%B0%E5%9D%80%E6%8E%A2%E7%A9%B6.png" alt="内存地址打印结果"></p>
<p>根据打印的结果可以看出:</p>
<ol>
<li>首先 @”123” 和 @”456” 为字符串常量, 被分配到了常量区, 然后 str0 和 str1 同时指向了常量 @”123”, 所以 str0 和 str1 的指针是一样的。至于 str0 和 str2 所指向的是2个不同的常量, 所以指针地址是不一样的。</li>
<li>str3 所指向的是一个 alloc 出来的对象, 这个对象是被分配在堆内存中的, 所以 str3 与上面的 str0 和 str1 所对应的指针是不一样的。str4 也指向了一个 alloc 出来的对象, 这个对象也是分配在堆内存的, 由于 iOS 系统对字符串内存的优化 (如果一个字符串是通过字符串常量初始化而来, 那么这个字符串里面的值可以直接从常量区拿, 这样就不需要为每一个堆上面的字符串分配新的内存。) </li>
<li>Str6 和 str7 都是指向堆上面的内存, 并且是通过变量初始化来的, 和 str3, str4 同理。</li>
</ol>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS面试知识总结_功能区分</title>
    <url>/2017-05-11-iOS%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93(2)_%E5%8A%9F%E8%83%BD%E5%8C%BA%E5%88%86/</url>
    <content><![CDATA[<p>本次内容主要是为了区分一些相似的内容或者功能的概念, 加深一下自己对这些内容的理解, 避免混淆:</p>
<h4 id="1-面向过程-和-面向对象"><a href="#1-面向过程-和-面向对象" class="headerlink" title="1. 面向过程 和 面向对象"></a>1. 面向过程 和 面向对象</h4><p><code>面向过程</code>: 以事件为核心, 各功能的实现是按照事件的先后顺序或者因果关系展开的。</p>
<p><code>面向对象</code>: 以对象为核心, 以事件为驱动, 将个功能模块化, 彼此之间相互独立互不影响。</p>
<h4 id="2-MVC-和-MVVM"><a href="#2-MVC-和-MVVM" class="headerlink" title="2. MVC 和 MVVM"></a>2. MVC 和 MVVM</h4><p><code>MVC弊端:</code> Controller 去负责 Model 与 View 的关联, 造成 View 与 Model 的耦合度较高, 而且 Controller 会比较的庞大复杂。</p>
<p><code>MVVM有点</code>: (需要后续…)</p>
<ol>
<li>低耦合, View 可以独立于 Model 变化和修改, ViewModel可以绑定到不同的View上, 当View变化的时候Model可以不变, 当 Model变化的时候View也可以不变</li>
<li>可重用性, 可以把一些视图的逻辑放在 ViewModel 里面, 让很多 View 重用这段视图逻辑</li>
<li>独立开发, 开发人员可以专注于业务逻辑和数据的开发(ViewModel), 设计人员可以专注于界面(View)的设计。</li>
<li>可测试性, 可以针对 ViewModel 来对界面(View)进行测试</li>
</ol>
<h4 id="3-MRC-和-ARC-内存管理"><a href="#3-MRC-和-ARC-内存管理" class="headerlink" title="3. MRC 和 ARC 内存管理"></a>3. MRC 和 ARC 内存管理</h4><p>iOS 5.0 以后ARC(Automatic Reference Counting)出现, 减少了代码, 省去了对象释放的麻烦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARC中加入MRC</span></pre></td></tr><tr><td class="code"><pre><span class="line">target-&gt;build phase-&gt;compbile source, 添加 -fon-objc-arc</span></pre></td></tr><tr><td class="code"><pre><span class="line">MRC中加入ARC</span></pre></td></tr><tr><td class="code"><pre><span class="line">target-&gt;build phase-&gt;compbile source, 添加 -fobjc-arc</span></pre></td></tr></table></figure>

<p>iOS 通过引用计数来记录对象的引用, 每次 runloop 完成一次循环的时候, 都会检查对象的retainCount, 如果说对象的retainCount为0, 说明该对象没有地方需要引用了, 就可以释放掉了。</p>
<h4 id="4-深拷贝-和-浅拷贝"><a href="#4-深拷贝-和-浅拷贝" class="headerlink" title="4. 深拷贝 和 浅拷贝"></a>4. 深拷贝 和 浅拷贝</h4><p><code>浅拷贝:</code> 指针拷贝, 不会增加新的内存, 只是增加一个指针指向原对象的内存区域。</p>
<p><code>深拷贝:</code> 内容拷贝, 同时拷贝指针和内存, 会同时增加指针和内存。</p>
<p><code>拷贝的条件:</code> 并非所有的对象都支持 copy 和 mutableCopy, 只有遵循了 NSCopy 协议或者NSMutableCopy 协议的类才行。如果遵循这两个协议就必须分别实现 copyWithZone 和 mutableCopyWithZone 方法。</p>
<p><code>拷贝原则:</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 非容器类: 像NSString、NSNumber这些系统类的不可变对象调用copy的话是浅拷贝, 调用mutableCopy是深拷贝并且拷贝的对象为可变对象; 可变对象的话无论调用 copy 或者 mutableCopy 都为深拷贝, 区别在于copy返回的是不可变对象而mutableCopy返回的是可变对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. 容器类: 像NSArray、NSMutableArray等不可变对象调用copy属于浅拷贝, 调用mutableCopy为深拷贝得到可变对象, 可变对象调用copy或者mutableCopy的情况与非容器类相同。</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. 自定义类: 我们自定义一个类并且实现NSCopy协议, 根据我们实现的拷贝协议的不同, 拷贝的结果也是不同的。如果在协议方法中直接返回对象的 self 就相当于浅拷贝, 如果返回的是一个创建的对象的话就属于深拷贝。</span></pre></td></tr></table></figure>

<h4 id="5-关于-strong-和-weak"><a href="#5-关于-strong-和-weak" class="headerlink" title="5. 关于 strong 和 weak"></a>5. 关于 strong 和 weak</h4><ol>
<li>strong: 强引用, strong类型的指针指向的对象不会被释放</li>
<li>weak: 弱引用, 无法阻止对象的释放, 如果一个对象没有被强引用指针指向, 不管有多少weak指向都无法阻止该对象被释放。</li>
</ol>
<h4 id="6-区分-include、-import-和-class"><a href="#6-区分-include、-import-和-class" class="headerlink" title="6. 区分 #include、#import 和 @class"></a>6. 区分 #include、#import 和 @class</h4><ul>
<li><code>#include</code> </li>
</ul>
<p>一般在导入 C / C++ 头文件时用 #include, include相当于拷贝文件中的内容, 多次使用的话会提示重复定义的错误。比如, classA 和 classB 都引入了 classC, 如果 classD 同时引用 classA 和 classB 的话, 就会有重复引用的错误。</p>
<ul>
<li><code>#import</code> </li>
</ul>
<p>我们在导入 Objective-C 的头文件时用到的, 不会产生重复定义的错误提示, 因为它只会做一次判断, 如果已经导入过的话就不会再去做导入了。</p>
<ul>
<li><code>@class</code></li>
</ul>
<p>@class 仅仅是对类的一个声明, 只是用来告诉编译器有这么一个类, 至于类的具体实现是不知道的,</p>
<p>另外@class的由于不会关注其实现, 编译速度相对来说比较快</p>
<p>此外@class还可以解决循环依赖的问题, 例如 A导入了B, B又导入了A, 但是每一个头文件的编译都需要让对方先编译成功才行, 这样就产生了循环依赖问题。所以一般在头文件里面我们使用 @class 来声明类的名称, 然后在实现类里面用 #import 来包含这个被引用的类的头文件, 这样就可以获取到类的内部变量和方法了。</p>
<p>*<em>注意: *</em> #impor&lt; &gt; 和 #import” “ 的区别, 前者用来包含 iOS 框架类库里面的类, 后者用来包含自定义的类。</p>
<h4 id="7-区分UDID与UUID"><a href="#7-区分UDID与UUID" class="headerlink" title="7.区分UDID与UUID"></a>7.区分UDID与UUID</h4><p><strong>UDID (Unique Device Identifier)</strong> 用户设备唯一编码</p>
<p>UDID是一串由40位16进制组成的字符串, 用以标识唯一的设备。苹果从iOS5开始就移除了通过代码访问UDID的权限, 所以我们无法从代码中获取用户设备的UDID。如果我们想查看自己设备的UDID, 可以通过 iTunes 来查看。通常我们在增加 Provisioning Profile 文件时会用到。</p>
<p><strong>UUID (Universally Unique IDentifier)</strong> 通用唯一识别符</p>
<p>UUID 是一个32位的十六进制序列, 使用小横线来连接: 8-4-4-4-12。它是一种应用加设备绑定产生的标识符。当在设备上安装来自同一个供应商的不同App时, 此值保持不变。如果你删除了来自某个供应商的所有app, 再重新安装时, 此值会改变。获取UUID:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *uuidString &#x3D; [[[UIDevice currentDevice] identifierForVendor] UUIDString];</span></pre></td></tr></table></figure>

<h4 id="8-区分nil、Nil、NULL、NSNUll"><a href="#8-区分nil、Nil、NULL、NSNUll" class="headerlink" title="8.区分nil、Nil、NULL、NSNUll"></a>8.区分nil、Nil、NULL、NSNUll</h4><ol>
<li><p>nil</p>
<p>nil一般是指把一个对象置空, 既完全是一个空对象, 完全从内存中释放。</p>
</li>
<li><p>Nil</p>
<p>Nil 与 nil 基本没有任何区别, 也可以说只要是可以使用 nil 的地方都可以使用Nil, 反之亦然。但是我们应该更加严谨一些, nil 标识置空一个对象, 而 Nil 表示置空一个类。</p>
</li>
<li><p>NULL</p>
<p>NULL 源于 C语言, 表示一个空指针, 即: int *p = NULL</p>
</li>
<li><p>NSNull</p>
<p>NSNull是继承于 NSObject 的对象, 它和nil的区别在于, nil 是把对象完全释放掉了, 完全从内存中释放。当我们想要把对象置空又想要一个容器的时候, 我们可以使用NSNull。</p>
</li>
</ol>
<h4 id="9-区分类目与扩展"><a href="#9-区分类目与扩展" class="headerlink" title="9.区分类目与扩展"></a>9.区分类目与扩展</h4><p>类目: category 为已知的类增加新的方法</p>
<p>1.类目中扩展的方法会被子类继承</p>
<p>2.增加原有类的方法, 而且是可以增加多个类目将大的功能划分为小功能</p>
<p>3.类目中的方法会比原有类中的方法具有更高的优先级。所以不能和原有类方法重名, 不然就会覆盖原有方法。</p>
<p>4.类目只能添加方法, 不能添加变量</p>
<p>扩展: 即延展, 一般是在类的实现文件中, 给当前类添加私有变量和私有方法, 添加的方法是必须实现的。</p>
<h4 id="10-区分-TCP-和-UDP"><a href="#10-区分-TCP-和-UDP" class="headerlink" title="10.区分 TCP 和 UDP"></a>10.区分 TCP 和 UDP</h4><p>TCP: 面向连接、传输可靠(保证数据正确性, 保证数据顺序传输)、用于传输大量数据(流模式)、速度慢, 建立连接需要开销较多(时间, 系统资源)。</p>
<p>UDP: 面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快, 传输的是报文。</p>
<h4 id="11-区分HTTP与Socket"><a href="#11-区分HTTP与Socket" class="headerlink" title="11.区分HTTP与Socket"></a>11.区分HTTP与Socket</h4><p>HTTP请求: 客户端主动发起请求, 服务器才能给与响应, 一次请求完毕后断开连接, 节省资源。</p>
<p>Socket: 客户端与服务的直接使用socket套接字连接, 双方保持连接通道, 都可以主动发送数据, 适合游戏或者股票等即时性很强的要求。主要使用的类是CFSocketRef。</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS面试知识总结_基本概念</title>
    <url>/2017-05-04-iOS%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93_%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h3 id="iOS面试知识总结-基本概念"><a href="#iOS面试知识总结-基本概念" class="headerlink" title="iOS面试知识总结_基本概念"></a><center>iOS面试知识总结_基本概念</center></h3><p><strong>前言:</strong> 经过这几天的面试发现, 虽然在实际的开发中做过许多的项目, 但是也会被一个自己认为很普通的问题问住。因此意识到虽然在平时能够做到会用这些知识去开发, 但是却很难将我们平时用到的知识很好的表述出来, 所以我决定将一些比较常用的知识点总结出来。一方面有助于面试, 同时也有助于闲暇之余对知识点的回顾。</p>
<h4 id="1-iOS开发者账号类型"><a href="#1-iOS开发者账号类型" class="headerlink" title="1.iOS开发者账号类型"></a>1.iOS开发者账号类型</h4><table>
<thead>
<tr>
<th>账号类型</th>
<th>协作人数</th>
<th>其它</th>
</tr>
</thead>
<tbody><tr>
<td>个人账号(individual)</td>
<td>1人</td>
<td>99美元一年, 允许上架 App Store, 最多支持 100个 UUID</td>
</tr>
<tr>
<td>公司账号(company)</td>
<td>多人协作</td>
<td>99美元一年, 允许上架 App Store, 最多支持 100个 UUID</td>
</tr>
<tr>
<td>企业账号(enterprise)</td>
<td>多人</td>
<td>299美元一年, 不允许上架 App Store, UUID 无限制</td>
</tr>
</tbody></table>
<ol>
<li>个人开发者账号可以申请升级为 公司账号, 可以通过拨打苹果公司客服电话 (400 6701 855) 来咨询办理</li>
<li>公司账号允许多个开发者进行写作开发, 比个人多一些账号管理设置, 可以设置多个 apple ID, 分4种管理级别权限。申请公司账号需要填写公司的邓白氏编码 (DUNS)</li>
<li>需要注意的是, 企业账号不能发布到 App Store, 适合那些不希望公开发布应用的企业, 申请时也需要邓白氏编码。</li>
</ol>
<h4 id="2-了解沙盒的目录结构"><a href="#2-了解沙盒的目录结构" class="headerlink" title="2.了解沙盒的目录结构"></a>2.了解沙盒的目录结构</h4><p><img src="/.com//yujialei/Documents/%E4%B8%B4%E6%97%B6%E6%88%AA%E5%9B%BE/%E6%B2%99%E7%9B%92%E7%9B%AE%E5%BD%95.png" alt="沙盒目录"></p>
<h4 id="3-理解-OC-是一门动态运行时语言"><a href="#3-理解-OC-是一门动态运行时语言" class="headerlink" title="3.理解 OC 是一门动态运行时语言"></a>3.理解 OC 是一门动态运行时语言</h4><p>OC将数据、对象类型的确定从编译阶段推迟到了运行时阶段。实现这一操作的基础是面向对象语言的 多态特性。</p>
<p>运行时: 运行时机制使程序在运行的时候才会去确定一个对象的类型、以及调用该类对象的指定方法。</p>
<p>多态: 不同的对象以自己的方式来响应相同的消息, 子类的指针可以赋值给父类。</p>
<h4 id="4-常见的-HTTP-状态码"><a href="#4-常见的-HTTP-状态码" class="headerlink" title="4.常见的 HTTP 状态码"></a>4.常见的 HTTP 状态码</h4><p>302: 请求重定向</p>
<p>500以及500以上是服务器错误, 如果 503 表示服务器找不到, 3840表示服务器返回无效的 JSON 数据。</p>
<p>400以及400以上是请求链接错误或者找不到服务器, 比如常见的403错误。</p>
<p>200以及200以上是正确的, 比如200表示请求正常。</p>
<h4 id="5-理解内存中的区域划分"><a href="#5-理解内存中的区域划分" class="headerlink" title="5.理解内存中的区域划分"></a>5.理解内存中的区域划分</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">栈区(stack): 由系统自动分配和释放, 存放局部变量的值, 容量小速度快, 有序</span></pre></td></tr><tr><td class="code"><pre><span class="line">堆区: 一般由程序员去分配和释放, 如果不去释放, 则出现内存泄漏问题。程序会回收内存(容量大, 速度慢, 无序)</span></pre></td></tr><tr><td class="code"><pre><span class="line">静态存储区: 全局变量 (外部变量) 和 静态变量都存储在静态区域。当程序结束时, 系统回收</span></pre></td></tr><tr><td class="code"><pre><span class="line">常量区: 存放常量的内存区域, 程序结束时系统回收</span></pre></td></tr><tr><td class="code"><pre><span class="line">代码区: 存放程序二进制代码的区域</span></pre></td></tr></table></figure>

<h4 id="6-内存管理的基本原则"><a href="#6-内存管理的基本原则" class="headerlink" title="6.内存管理的基本原则"></a>6.内存管理的基本原则</h4><ul>
<li>iOS 5.0 之前: OC内存管理遵循”谁创建, 谁释放, 谁引用, 谁管理”的原则, 当创建或者引用一个对象时, 需要发送 alloc、copy、retain消息, 当释放一个对象时需要向该对象发送 release 消息, 当对象的引用计数为 0 时, 系统将会释放该对象, 这是 OC 的手动管理对象机制 (MRC)。</li>
<li>iOS 5.0 以后: 使用自动管理机制–自动引用计数(ARC), 管理机制与手动机制一样, 只是不再需要调用 retain、release、autorelease;  自动引用计数同样也是基于引用计数的机制来管理内存的, 不同点在于, MRC 需要我们自己去跟踪和管理对象, ARC通常情况下都是系统去帮助我们处理的(注:有些还是需要我们去处理)。</li>
</ul>
<p>当使用 alloc、copy(mutableCopy) 或者 retain 创建一个对象时, 必须有对应的 release 或者 autorelease 消息。向一个对象发送一条 autorelease 消息时, 对象并不会立即销毁, 而是将这个对象放入自动释放池中, 等待自动释放池释放时, 它会向池中的每一个对象发送一条 release 消息, 以此来释放对象。</p>
<p>向一个对象发送 release 消息时, 并不意味着对象就被销毁了, 而是当这个对象的引用计数 为 0 时, 系统才会去调用 dealloc 方法, 释放该对象 和 对象本身的实例。</p>
<h4 id="7-属性相关"><a href="#7-属性相关" class="headerlink" title="7.属性相关"></a>7.属性相关</h4><ol>
<li>原子性: atomic, nonatomic</li>
<li>读写: readwrite, readonly</li>
<li>方法名: getter=&lt;name<del>&gt;, setter=&lt;name</del>&gt;</li>
<li>内存: strong, retain, copy, weak, assign, unsafe_unretain</li>
</ol>
<p>atomic(默认情况): 表示原子性, 使用该属性可以保护属性的存取方法, 如果当前线程进行到一半有其它线程来访问当前资源, 可以保证必须优先进行完当前线程。原子性与对象的线程安全性是不同的, 并不能保证线程安全, 如果有多个线程同时访问一个实例变量, 其中一个调用了release的话就会造成程序的崩溃。同时, atomic 生成的互斥锁代码也会很消耗资源, 导致程序变慢。</p>
<p>nonatomic: 非原子属性, 与atomic相反, 系统不会去使用互斥锁保护属性的存取方法, 当多个线程同时访问一个属性时有可能出现无法预计的结果。 但是与 atomic 相比, 效率会更高。</p>
<p>readwrite(默认情况): 表示同时拥有 getter 和 setter 方法</p>
<p>readonly: 只读操作, 只有 getter 方法</p>
<p>注: 如果某个实例只允许外部读取, 但是在类的实现文件可以写操作的话, 可以在头文件什么为只读, 在实现文件设置为读写, 如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 头文件声明</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property(nonatomic, readonly, copy) NSString *string;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现文件声明</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property(nonatomic, readwrite, copy) NSString *string;</span></pre></td></tr></table></figure>



<p>retain: 表示属性的保留操作, 用于获取对象的所有权, 会使对象引用计数 +1, 主要用作MRC, ARC下用 strong 替代。</p>
<p>assign(默认情况): 一般 int, float, double 和 NSInteger, CGFloat, BOOL 等值类型属性默认使用 assign, 用于赋值操作, 不存在所有权关系。</p>
<p>copy: 对对象的拷贝(分为浅拷贝 和 深拷贝), 并且属于强引用, 设置 copy 属性的任何对象都必须遵循 NSCopying 协议。</p>
<p>strong(默认情况): 声明为强引用, 需要注意的是 两个强引用的对象相互指向对方的时候有可能造成循环引用的问题。</p>
<p>weak: 声明弱引用, 与 strong相反, 当对象被释放以后, 实力变量会自动变为nil。所以, 我们通常可以使用 __weak 将强引用对象替换为弱引用, 用来解决循环引用的问题。</p>
<p>unsafe_unretain: 表示不安全引用, 当所引用对象被释放以后, 实例变量不会自动变为nil, 就会留下一个悬挂指针, 指向被释放的对象所占用的内存, 会导致程序崩溃。</p>
<h4 id="8-关于Block"><a href="#8-关于Block" class="headerlink" title="8.关于Block"></a>8.关于Block</h4><p>1.block为什么需要用 copy 修饰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a. block 在创建的时候默认是被分配在 栈 上的, 这样的话其本身的作用域是属于栈内存的, 一旦在作用域之外去调用就回导致程序崩溃, 所以需要使用copy 将其拷贝到堆内存上面。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">b. 由于 block 创建在栈区, 而 block 的代码中可能会用到本地的一些变量, 只有将其拷贝到对手, 才能使用这些变量。</span></pre></td></tr></table></figure>

<p>2.block 为什么不用 retain</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">retain 只是增加了一次计数, block的内存还是在栈上面的, 并没有存在堆上, 存储的栈上的 block 可能随时被系统回收</span></pre></td></tr></table></figure>

<p>3.为什么进入block中的对象的引用计数需要自动加1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block 执行的是回调, 因此 block 并不知道其中的对象创建以后会在什么时候被释放, 为了不在 block 使用该对象之前对象就已经被释放掉了, block 就会将该对象 retain 操作</span></pre></td></tr></table></figure>

<p>4.block 和 函数 的关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block 的使用很像 函数指针, 不过与函数最大的不同是 block 可以访问函数外、词法作用域以内的外部变量的值。</span></pre></td></tr><tr><td class="code"><pre><span class="line">换句话说, block 不仅实现函数的功能, 还能携带函数的执行环镜。</span></pre></td></tr></table></figure>

<p>5.对于block的理解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block 实际上就是 指向结构体的指针, 编译器会将 block 的内部代码生成对于的函数</span></pre></td></tr></table></figure>

<p>6.对于基本数据类型, 进入到block 中会被当做常量处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果需要在 block 中对 num 进行修改, 需要加上 __block 关键字</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; </span></pre></td></tr><tr><td class="code"><pre><span class="line">int num1 &#x3D; 10;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void (^block1)() &#x3D; ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;num1 &#x3D; %d&quot;, num1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">num1 &#x3D; 20;</span></pre></td></tr><tr><td class="code"><pre><span class="line">block1();&#x2F;&#x2F; 结果为10</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 改进: 使用 block, 使进入到 block 块中的变量不被当做常量来对待</span></pre></td></tr><tr><td class="code"><pre><span class="line">__block num2 &#x3D; 10;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void (^block2)() &#x3D; ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;num2 &#x3D; %d&quot;, num2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">num2 &#x3D; 20;</span></pre></td></tr><tr><td class="code"><pre><span class="line">block2();&#x2F;&#x2F; 结果为20</span></pre></td></tr></table></figure>

<p>7.关于 block 中 self 的循环引用问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block 默认是创建在栈上面的, 所以要对其进行 copy 操作拷贝到堆区使用。但是进行了 copy 操作以后, 在 block 中使用 self 的话对象就会被 retain 一次(注意: block在堆区上时才会起到retain的作用), 会造成循环引用。</span></pre></td></tr><tr><td class="code"><pre><span class="line">解决办法:</span></pre></td></tr><tr><td class="code"><pre><span class="line">在 MRC 下, 使用 __block 修饰</span></pre></td></tr><tr><td class="code"><pre><span class="line">在 ARC 下, 使用 __unsafe_unretain 或者 weak 修饰</span></pre></td></tr></table></figure>

<h4 id="9-关于循环引用出现的三种情况"><a href="#9-关于循环引用出现的三种情况" class="headerlink" title="9.关于循环引用出现的三种情况"></a>9.关于循环引用出现的三种情况</h4><p>1.NSTimer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NStimer 对象 timer 作为一个对象A的属性, 本意在A的dealloc中释放timer, 但是 timer 没有停止就不会触发 dealloc, 然后就是相互等待, 造成循环引用。所以我们需要去显式的调用 timer 的关闭方法 [timer invaluate], 再去释放 A对象。</span></pre></td></tr></table></figure>

<p>2.Block</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block 代码块没有配合 weak 使用</span></pre></td></tr></table></figure>

<p>3.Delegate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">声明 delegate 时请使用 assign(MRC) 或者 weak(ARC)。</span></pre></td></tr></table></figure>

<p>举例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *aArray &#x3D; [NSMutableArray array];</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSMutableArray *bArray &#x3D; [NSMutableArray array];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[aArray addObject:bArray];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[bArray addObject:aArray];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">检测方法:</span></pre></td></tr><tr><td class="code"><pre><span class="line">Xcode-&gt;Product-&gt;Profile-&gt;Leaks</span></pre></td></tr></table></figure>

<h4 id="10-理解创建对象所需要经历的步骤-和-layoutSubView何时会被调用"><a href="#10-理解创建对象所需要经历的步骤-和-layoutSubView何时会被调用" class="headerlink" title="10.理解创建对象所需要经历的步骤 和 layoutSubView何时会被调用"></a>10.理解创建对象所需要经历的步骤 和 layoutSubView何时会被调用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建对象:</span></pre></td></tr><tr><td class="code"><pre><span class="line">1.开辟内存空间</span></pre></td></tr><tr><td class="code"><pre><span class="line">2.初始化参数</span></pre></td></tr><tr><td class="code"><pre><span class="line">3.返回内存地址的值</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">layoutSubView的调用:</span></pre></td></tr><tr><td class="code"><pre><span class="line">1.初始化方法时不会调用</span></pre></td></tr><tr><td class="code"><pre><span class="line">2.滚动UIScrollView时触发该方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">3.旋转屏幕时触发</span></pre></td></tr><tr><td class="code"><pre><span class="line">4.改变View的值时触发, 前提是改变过frame</span></pre></td></tr><tr><td class="code"><pre><span class="line">5.改变View的大小时触发</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">(具体内容需要后续)</span></pre></td></tr></table></figure>

<h4 id="11-理解-iOS-的远程推送"><a href="#11-理解-iOS-的远程推送" class="headerlink" title="11.理解 iOS 的远程推送"></a>11.理解 iOS 的远程推送</h4><p><img src="/.com//yujialei/Documents/%E4%B8%B4%E6%97%B6%E6%88%AA%E5%9B%BE/%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81.png" alt="远程推送"></p>
<ol>
<li>应用程序安装以后会提示用户是否需要接收推送, 如果用户确认以后会向 APNS Server 注册消息推送。</li>
<li>注册成功以后, App 会接收到 APNS Server 所给的 推送令牌信息</li>
<li>App 将令牌信息发送到自己的服务器</li>
<li>当需要向用户推送消息时, 自己的服务器会向苹果的推送服务器(Apple Push Notification Service, 简称 APNS)发送通知</li>
<li>APNS 会向装有此 App 的 iPhone设备发送消息</li>
</ol>
<h4 id="12-理解-iOS-中的多线程"><a href="#12-理解-iOS-中的多线程" class="headerlink" title="12.理解 iOS 中的多线程"></a>12.理解 iOS 中的多线程</h4><p>1.概念</p>
<p>多线程是针对于单核的 CPU 来设计的, 目的是为了让 CPU 快速的在多个线程之间进行调度。</p>
<p><strong>多线程的优缺点:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优点: 提高程序的执行效率</span></pre></td></tr><tr><td class="code"><pre><span class="line">缺点: 开启线程需要一定的内存空间</span></pre></td></tr></table></figure>

<p><strong>同步线程 和 异步线程:</strong> 决定了可不可以开辟新的线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同步: 只在当前线程中执行任务, 不具备开辟新的线程的能力</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步: 可以在新的线程中执行任务, 具备开辟新的线程的能力</span></pre></td></tr></table></figure>

<p><strong>并行队列 和 串行队列:</strong> 决定了任务的执行方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">并行: 多个任务进行并发(同时)执行, 比如迅雷等, 可以多个任务同时进行下载</span></pre></td></tr><tr><td class="code"><pre><span class="line">串行: 必须等待一个任务执行完成以后, 才能去执行下一个任务。</span></pre></td></tr></table></figure>

<p><strong>注意:</strong> 在 iOS应用程序中都是一个主线程, 也称为 UI线程, 主线程的主要作用就是用来更新UI, 或者去显示和刷新页面。如果将耗时的任务放在主线程去执行的话, 会出现卡顿的现象。</p>
<p>2.iOS 的三种多线程技术</p>
<p><strong>NSThread</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">直接操作线程对象, 但是需要手动管理声明周期, 经常使用这种方式去查看当前线程</span></pre></td></tr></table></figure>

<p><strong>GCD (Grand Central Dispatch)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">底层使用的是 C语言, 灵活方便, 可以根据系统的负荷来增减线程, 性能效率更好</span></pre></td></tr></table></figure>

<p><strong>NSOperation</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSOperation 是对GCD的封装, 使用起来更加好理解, 将任务封装在NSOperation, 添加到NSOperationQueue对象中。</span></pre></td></tr><tr><td class="code"><pre><span class="line">子类化NSOperation的设计, 更具有面向对象(封装, 复用) 的特性, 更加适合在复杂的项目中使用。</span></pre></td></tr></table></figure>

<p>3.进程 和 线程</p>
<p>进程(progress) 和 线程(thread) 是操作系统里的基本概念。</p>
<p>线程 和 进程的区别:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程是资源分配的最小单位, 也是处理器调度的基本单位, 但是进程是资源拥有的单位, 同一个进程内的线程共享进程里面的资源。</span></pre></td></tr><tr><td class="code"><pre><span class="line">多进程: 允许多个任务同时运行</span></pre></td></tr><tr><td class="code"><pre><span class="line">多线程: 允许单个任务分为不同的部分运行</span></pre></td></tr></table></figure>

<h4 id="13-音频播放相关知识"><a href="#13-音频播放相关知识" class="headerlink" title="13. 音频播放相关知识"></a>13. 音频播放相关知识</h4><p>音频在播放形式上分为 音频播放 和 音乐播放。</p>
<p>音频播放: 通常时间较短, 不需要进度控制和循环控制, 使用 AudioToolbox.framework</p>
<p>音乐播放: 通常时间较长, 需要进行精准控制, 使用 AVFoundation.framework</p>
<p><strong>音频播放</strong></p>
<p>AudioToolbox.framework是基于C语言的框架</p>
<p>原理: 将短音频注册到系统的声音服务(System Sound Service)中, System Sound Service 是一种简单、底层的声音播放服务。</p>
<ol>
<li>音频的播放时间不能超过30秒</li>
<li>数据必须是 PCM 或者 IMA4 格式</li>
<li>音频格式必须打包成 .caf、.aif、wav中的一种 (这些都是官方的说法, 实际上一些 .MP3的格式也可以)</li>
</ol>
<p><strong>音乐播放</strong></p>
<ol>
<li>是个播放较大的音频文件</li>
<li>可以对音频进行精准的播放控制</li>
<li>使用 AVFoundation.framework 中的 AVAudioPlayer 来实现</li>
</ol>
<p>使用:</p>
<ol>
<li>初始化 AVAudioPlayer 对象, 通常是指定本地文件的路径</li>
<li>设置播放器属性, 例如重复次数, 音量大小等</li>
<li>调用 play 方法进行播放</li>
</ol>
<p>*<em>注意: *</em>AVAudioPlayer 一次只能播放一个音频文件, 所有的上一曲和下一曲都是通过创建多个 AVAudioPlayer来实现的。</p>
<h4 id="14-视频播放相关知识"><a href="#14-视频播放相关知识" class="headerlink" title="14. 视频播放相关知识"></a>14. 视频播放相关知识</h4><p>苹果已经给我们提供了很多种方法来实现视频的播放, 包括 MPMoviePlayerController, MPMoviePlayerController, AVPlayer, AVPlayerViewController等。但是 MPMoviePlayerController和MPMoviePlayerViewController 在 iOS9.0 以后被弃用了。<img src="/.com//yujialei/Documents/%E4%B8%B4%E6%97%B6%E6%88%AA%E5%9B%BE/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE.png" alt="视频播放"></p>
<h5 id><a href="#" class="headerlink" title></a></h5>]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>数据持久化方案</title>
    <url>/2017-04-05-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h4 id="数据持久化方案"><a href="#数据持久化方案" class="headerlink" title="数据持久化方案"></a><center>数据持久化方案</center></h4><p>沙盒机制是 iPhone 出于安全考虑, 对于安装在手机上的应用程序的限制。所安装的应用程序只能在为该程序创建的文件系统中读取文件, 不可以去其他地方访问, 此区域就被称为沙盒, 所有的 非代码文件都要保存在此处, 例如: 图像、声音、图标、属性列表, 文本文件等, 沙盒就是一种 独立、安全、封闭的空间。</p>
<p>特点:</p>
<ol>
<li>每个应用程序都有自己的存储空间</li>
<li>每个应用程序都不可以翻过自己的围墙去随便访问别的存储空间内容。(越狱设备除外)</li>
<li>访问别的沙盒内数据时需要访问权限</li>
</ol>
<p>沙盒目录: documents、library(包含 caches 和 preference 目录)、tmp</p>
<ol>
<li>documents: 一般保存应用程序本身产生的文件数据, 例如: 游戏进度, 绘图软件的绘图等, iTunes 备份和恢复的时候, 会包括次目录(注意: 此目录不要保存网络上下载的文件, 否则app无法上架)</li>
<li>library/caches: 此目录用来保存应用程序运行时生成的需要持久化的数据, 数据一般体积比较大, 又不是很重要, 比如网络请求等。需要用户负责删除(iTunes同步设备时不会备份该目录)</li>
<li>librar/preference: 此目录保存应用程序的所有偏好设置, iOS的settings(设置)应用会在该目录查找应用的设备信息。iTunes同步设备时会备份该目录。(在preference目录下不能直接创建偏好设置文件, 而是应该使用 nsuserdefault 类来取得和设置应用程序的偏好)</li>
<li>tmp: 保存应用程序运行时所需的临时数据, 使用完毕后会将相应的文件从该目录删除。应用没有运行时, 系统也可能会清除该目录下的文件, iTunes同步设备时不会备份该目录</li>
</ol>
<h5 id="持久化方案"><a href="#持久化方案" class="headerlink" title="持久化方案"></a>持久化方案</h5><blockquote>
<p>plist文件 (属性列表)</p>
<p>preference (nsuserdefault 偏好设置)</p>
<p>nskeyedAchiver (归档)</p>
<p>Sqlite3 (fmdb)</p>
<p>coreData</p>
</blockquote>
<h5 id="1-plist文件"><a href="#1-plist文件" class="headerlink" title="1.plist文件"></a>1.plist文件</h5><p>将某些特定的类, 通过xml文件的方式保存在目录中, 可以被序列化的类型只包括如下几种:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray, NSMutableArray, NSDictionary, NSMutableDictionary, NSData, NSMutableData, NSString, NSMutableString, NSNumber, NSData</span></pre></td></tr></table></figure>

<p>获取文件路径:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *path &#x3D; NSSearchPathForDirectoriesInDomain(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSString *fileName &#x3D; [path stringByAppendingPthComponent:@&quot;231.plist&quot;];</span></pre></td></tr></table></figure>

<p>存储:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *array &#x3D; @[@&quot;123&quot;, @&quot;321&quot;, @&quot;879&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[array writeToFile:fileName atomically:YES];</span></pre></td></tr></table></figure>

<p>读取:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *result &#x3D; [NSArray arrayWithContentsOfFile: fileName]l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%@&quot;, result);</span></pre></td></tr></table></figure>

<p>注意:</p>
<p>只有以上所列出的类型才能使用plist文件存储, 存储的时候使用 writeToFile: atomically: 方法, 其中atomically 表示是否需要先写入一个辅助文件, 再把辅助文件拷贝到目标地址。这是更安全的写入文件方法, 一般为YES, 读取时使用 arrayWithContentOfFile: 方法。</p>
<h5 id="2-Preference-NSUserdefault-偏好设置"><a href="#2-Preference-NSUserdefault-偏好设置" class="headerlink" title="2.Preference (NSUserdefault 偏好设置)"></a>2.Preference (NSUserdefault 偏好设置)</h5><p>使用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.获得NSUserdefault文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSUserdefault *userDefault &#x3D; [NSUserdefault standardUserDefaults];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 2.向文件中写入内容</span></pre></td></tr><tr><td class="code"><pre><span class="line">[userDefault setObject:@&quot;AAA&quot; forKey:@&quot;a&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[userDefault setBool:YES forKey:@&quot;sex&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[userDefault setInteger:21 forKey:@&quot;age&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 2.1立即同步</span></pre></td></tr><tr><td class="code"><pre><span class="line">[userDefault synchronize];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 3.读取文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSString *name &#x3D; [userDefaults objectForKey:@&quot;a&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">Bool sex &#x3D; [userDefaults boolForKey:@&quot;sex&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSInteger age &#x3D; [userDefaults integerForKey:@&quot;age&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">NSLog(@&quot;%@, %ld, %ld&quot;, name, sex, age);</span></pre></td></tr></table></figure>

<p>注意: </p>
<ul>
<li>偏好设置是专门用来存储应用程序的配置信息的, 一般不会在偏好设置中保存其他数据</li>
<li>如果没有 synchronize 方法, 系统会根据 I/O 情况不定时刻地保存到文件中。所以如果需要立即写入文件的话就必须调用 synchronize 方法。</li>
<li>偏好设置会将所有数据保存到同一个文件, 即 preference 目录下的一个以此应用包名来命名的 plist 文件。</li>
</ul>
<h5 id="3-NSkeyedAchiver-归档"><a href="#3-NSkeyedAchiver-归档" class="headerlink" title="3.NSkeyedAchiver (归档)"></a>3.NSkeyedAchiver (归档)</h5><p>归档在 iOS中是另一种形式的序列化, 只要遵循了 NSCoding 协议的对象都可以通过它实现序列化。 由于绝大多数支持存储数据的 Foundation 和 Cocoa Touch 类都遵循了 NSCoding 协议, 因此, 对于大多数类来说, 归档相对而言还是比较容易实现的。</p>
<ol>
<li>遵循NSCoding协议</li>
</ol>
<p>NSCoding 协议实现了两个方法, 这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中, 另一个说明如何进行接档来获取一个新对象。</p>
<p>遵循协议和设置协议:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Person : NSObject</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (strong, nonatomic) UIImage *avatar;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (copy, nonatomic) NSString *name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (assign, nonatomic) NSInteger age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@end</span></pre></td></tr></table></figure>

<p>实现协议方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 解档</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  if ([super init])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    self.avater &#x3D; [aDecoder decoderObjectForKey:@&quot;avater&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    self.name &#x3D; [aDecoder decoderObjectForKey:@&quot;name&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    self.age &#x3D; [aDecoder decoderObjectForKey:@&quot;age&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  return self;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 归档</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)endodeWithCoder:(NSCoder *)aCoder &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [aCoder encodeObject:self.avater forKey:@&quot;avater&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [aCoder encodeObject:self.name forKey:@&quot;name&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [aCoder encodeObject:self.age forKey:@&quot;age&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>注意: 如果需要归档的类是某个自定义的子类时, 就需要在归档和解档之前先实现父类的归档和解档方法。即, [super encodeWithCoder:aCoder]和[super initWithCoder:aCoder]方法。</p>
<ol start="2">
<li>使用</li>
</ol>
<p>需要把对象归档时调用 NSKeyedArchiver的工厂方法 archiveRootObject: toFile: 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *file &#x3D; [NSSearchPathForDirectoriesIndDomains(NSDocumentDictionary, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">person.avatar &#x3D; self.avatarView.image;</span></pre></td></tr><tr><td class="code"><pre><span class="line">person.name &#x3D; self.nameField.text;</span></pre></td></tr><tr><td class="code"><pre><span class="line">person.age &#x3D; self.ageField.text;</span></pre></td></tr><tr><td class="code"><pre><span class="line">[NSKeyedArchiver archiveRootObject:person toFile:file];</span></pre></td></tr></table></figure>

<p>需要从文件中解档对象就调用 NSKeyedUnarchiver 的一个工厂方法unarchiveObjectWithFile: 即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *file &#x3D; [NSSearchPathForDirectoriesIndDomains(NSDocumentDictionary, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">if (person) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  self.avatarView.image &#x3D; person.avatar;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  self.nameField.text &#x3D; person.name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  self.ageField.text &#x3D; [NSString stringWithFormat:@&quot;%ld&quot;, person.age];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ol start="3">
<li>注意</li>
</ol>
<ul>
<li>必须遵循并实现 NSCoding 协议</li>
<li>保存文件的扩展名可以任意指定</li>
<li>继承时必须先调用父类的归档解档方法</li>
</ul>
<h5 id="4-SQLite3-fmdb"><a href="#4-SQLite3-fmdb" class="headerlink" title="4.SQLite3 (fmdb)"></a>4.SQLite3 (fmdb)</h5><p>前面的存储方法, 都是覆盖存储。如果想要增加一条数据就必须把整个文件读取出来, 然后修改数据后再把整个内容写入文件, 所以他们都不适合存储大量的内容。</p>
<ol>
<li>字段类型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">integer: 整数</span></pre></td></tr><tr><td class="code"><pre><span class="line">real: 实数 (浮点数)</span></pre></td></tr><tr><td class="code"><pre><span class="line">text: 文本字符串</span></pre></td></tr><tr><td class="code"><pre><span class="line">blob: 二进制数据, 比如 文件, 图片之类的</span></pre></td></tr></table></figure>

<p>实际上 SQLite 是无类型的, 不管你在创建表时指定的字段类型是什么, 存储仍然可以存储任意类型的数据, 并且创建表时也可以不指定字段的类型。SQLite之所以什么类型就是为了良好的编程规范 和 方便开发人员的交流。</p>
<ol start="2">
<li>准备工作</li>
</ol>
<p>导入依赖库, 在iOS中要使用SQLite3, 需要添加库文件: libsqlite3.dylib 并导入主头文件, 这是一个C语言的库, 所以直接属于SQLite3还是比较麻烦的。</p>
<ol start="3">
<li>使用</li>
</ol>
<ul>
<li>创建数据库并打开(操作数据库之前必须先知道数据库文件和要操作的表, 所以使用SQLite3, 首先要打开数据库文件, 然后指定或者创建一张表)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打开数据库并创建一个表</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)openDataBase &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 1.设置文件名</span></pre></td></tr><tr><td class="code"><pre><span class="line">  NSString *fileName&#x3D; [NSSearchPathDirectoriesInDomain(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.db&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 2.打开数据库文件, 如果没有, 自动创建一个文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">  NSInteger result &#x3D; sqlite3_open(fileName.UTF8String, &amp;_sqlite3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  if (result &#x3D;&#x3D; SQLITE_OK) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;打开数据库成功!&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 创建一个数据库表</span></pre></td></tr><tr><td class="code"><pre><span class="line">    char *errmsg &#x3D; NULL;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sqlite3_exec(_sqlite3, &quot;CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)&quot;, NULL, NULL, &amp;errmsg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (errmsg) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      NSLog(@&quot;错误: %s&quot;, errmsg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;else&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      NSLog(@&quot;创建成功!&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;else&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;打开数据库失败&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>执行命令(使用sqlite3_exec() 方法可以执行任何SQL语句, 比如 创建、更新、插入和删除表操作。但是一般不用它执行查询语句, 因为它不会返回查询到的数据。)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在表中插入数据</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)insertData &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  NSString *nameStr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  NSInteger age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  for (NSInteger i &#x3D; 0; i &lt; 1000, i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    nameStr &#x3D; [NSString stringWithFormat:@&quot;Bourne:-%d&quot;, arc4random_uniform(1000)];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    age &#x3D; arc4random_uniform(80) + 20;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSString *sql &#x3D; [NSString stringWithFormat:@&quot;INSERT INTO t_person(name, age) VALUES(&#39;%@&#39;,&#39;%ld&#39;)&quot;, nameStr, age];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    char *errMsg &#x3D; NULL;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sqlite3_exec(_sqlite3, sql.UTF8String, NULL, NULL, &amp;errMsg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (errMsg) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      NSLog(@&quot;错误: %s&quot;, errMsg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  NSLog(@&quot;插入完毕!&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>查询指令(前面说过一般不使用 sqlite3_exec() 方法查询数据, 因为查询数据必须要获取查询结果, 所以查询相对比较麻烦。示例如下)</li>
</ul>
<p>Sqlite3_prepare_v2(): 检查sql的合法性。</p>
<p>Sqlite3_step(): 运行获取查询结果, 不断重复, 知道最后一条记录</p>
<p>Sqlite3_coloum_xx(): 获取对应类型的内容, iCloud对应的就是SQL语句中字段的顺序, 从0开始, 根据实际查询字段的属性, 使用  sqlite3__column_xxx 获得对应的内容即可。</p>
<p>Sqlite3_finalize(): 释放stmt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 从表中读取数据到数组中</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)readData &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  NSMutableArray *mArray &#x3D; [NSMutableArray arrayWithCapacity:1000];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  char *sql &#x3D; &quot;select name, age from t_person;&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  sqlite3_stat *stat;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  NSInteger result &#x3D; sqlite3_prepare_v2(_sqlite3, sql, -1, &amp;stat, NULL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  if(result &#x3D;&#x3D; SQLITE_OK) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    while (sqlite3_step(stat) &#x3D;&#x3D; SQLITE_ROW) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      char *name &#x3D; (char *)sqlite3_colum_text(stat, 0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      NSInteger age &#x3D; sqlite3_colum_int(stat, 1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#x2F;&#x2F; 创建对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">      Person *person &#x3D; [Person personWithName:[NSString stringWithUTF8String:name] Age:age];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      [mArray addObject:person];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    self.dataList &#x3D; mArray;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  sqlite3_finalize(stat);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>总结</p>
<p>sqlite3的使用还是比较麻烦的, 因为都是些C语言函数, 理解起来有些困难。不过在一般开发过程中, 使用的都是第三方开元库FMDB, 封装了这些基本的C语言方法, 使得我们在使用时更加容易理解, 提高开发效率。</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>基于原生JS与OC方法互相调用并传值</title>
    <url>/2017-03-10-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E7%94%9FJS%E4%B8%8EOC%E6%96%B9%E6%B3%95%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8%E5%B9%B6%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<p>最近项目里面有有个商品活动界面，要与web端传值，将用户在网页点击的商品id 传给客户端，也就是js交互，其实再说明白一点就是方法的互相调用而已。</p>
<p>本文叙述下如何进行原生的JavaScript交互</p>
<p>包括<strong>JS调用OC方法并传值，OC调用JS方法并传值</strong></p>
<h2 id="HTML代码"><a href="#HTML代码" class="headerlink" title="HTML代码"></a>HTML代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;margin-top: 20px&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;h2&gt;JS与OC交互&lt;&#x2F;h2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;唤起本地方法(call)&quot; onclick&#x3D;&quot;tianbai.call()&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;div&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;唤起getCall:(NSString *)callString传值&quot; onclick&#x3D;&quot;call()&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;script&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">var call &#x3D; function()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    var callInfo &#x3D; JSON.stringify(&#123;&quot;jianshu&quot;: &quot;http:&#x2F;&#x2F;www.jianshu.com&quot;&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tianbai.getCall(callInfo);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">var Callback &#x3D; function(str)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    alert(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">var alerCallback &#x3D; function()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    alert(&#39;成功&#39;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;script&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;html&gt;</span></pre></td></tr></table></figure>

<p>上面html的代码：建立了两个button</p>
<p>第一个button绑定了 <code>tianbai.call()</code> 方法，这里 <code>tianbai</code> 是一个对象，这个对象的作用下面OC代码中会说明， <code>tianbai.call()</code> 代表 <code>tianbai</code> 对象调用 <code>call()</code> 方法</p>
<p>第二个button绑定了 <code>call()</code> 的方法，调用的是下面JavaScript中的 <code>call()</code> 方法，在 JavaScript 的 <code>call()</code> 里面，定义一个 <code>callInfo</code> 参数，方法中 <code>tianbai.getCall(callInfo)</code> 代表 <code>tianbai</code> 对象调用 <code>getCall</code> 方法并传参数 <code>callInfo</code> ，下面两个方法是OC调用JavaScript方法，其中Callback传回str，alerCallback为OC仅调用JavaScript方法！</p>
<h2 id="OC代码"><a href="#OC代码" class="headerlink" title="OC代码"></a>OC代码</h2><p>demo采用原生的JavaScriptCore类</p>
<p>引入三个名词：</p>
<ol>
<li>JSContext：给JavaScript提供运行的上下文环境</li>
<li>JSValue：JavaScript和Objective-C数据和方法的桥梁</li>
<li>JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议</li>
</ol>
<p>ViewController.h中的代码(代码过长，方法说明都在注释里)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;导入头文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">#import &lt;JavaScriptCore&#x2F;JavaScriptCore.h&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@protocol JSObjcDelegate &lt;JSExport&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;tianbai对象调用的JavaScript方法，必须声明！！！</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)call;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (void)getCall:(NSString *)callString;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@end</span></pre></td></tr><tr><td class="code"><pre><span class="line">@interface ViewController : UIViewController&lt;UIWebViewDelegate,JSObjcDelegate&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (nonatomic, strong) JSContext *jsContext;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@property (strong, nonatomic)  UIWebView *webView;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@end</span></pre></td></tr></table></figure>


<p>ViewController.m中的代码(代码过长，方法说明都在注释里)</p>
<p>JavaScriptCore中web页面调用原生应用的方法可以用Delegate或Block两种方法，此文以按Delegate讲解。</p>
<p>设置webView</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.webView &#x3D; [[UIWebView alloc]initWithFrame:CGRectMake(0, 20, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    self.webView.delegate &#x3D; self;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;从本地加载html文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSString* path &#x3D; [[NSBundle mainBundle] pathForResource:@&quot;index&quot; ofType:@&quot;html&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSURL* url &#x3D; [NSURL fileURLWithPath:path];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSURLRequest* request &#x3D; [NSURLRequest requestWithURL:url] ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [self.webView loadRequest:request];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [self.view addSubview:self.webView];</span></pre></td></tr></table></figure>

<p>JavaScript的tianbai是一个对象，充当原生应用和web页面之间的一个桥梁。用来调用方法</p>
<p>webview加载完成调用代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	  &#x2F;&#x2F; 设置javaScriptContext上下文</span></pre></td></tr><tr><td class="code"><pre><span class="line">    self.jsContext &#x3D; [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;将tianbai对象指向自身</span></pre></td></tr><tr><td class="code"><pre><span class="line">    self.jsContext[@&quot;tianbai&quot;] &#x3D; self;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    self.jsContext.exceptionHandler &#x3D; ^(JSContext *context, JSValue *exceptionValue) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        context.exception &#x3D; exceptionValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        NSLog(@&quot;异常信息：%@&quot;, exceptionValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>将对象指向自身后，如果调用 <code>tianbai.call()</code> 会响应下面的方法，OC方法中调用js中的Callback方法，并传值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)call&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;call&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 之后在回调js的方法Callback把内容传出去</span></pre></td></tr><tr><td class="code"><pre><span class="line">    JSValue *Callback &#x3D; self.jsContext[@&quot;Callback&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;传值给web端</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [Callback callWithArguments:@[@&quot;唤起本地OC回调完成&quot;]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>将对象指向自身后，如果调用 <code>tianbai.getCall(callInfo)</code> 会响应下面的方法，OC方法中仅调用js中的alerCallback方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)getCall:(NSString *)callString&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@&quot;Get:%@&quot;, callString);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 成功回调js的方法Callback</span></pre></td></tr><tr><td class="code"><pre><span class="line">    JSValue *Callback &#x3D; self.jsContext[@&quot;alerCallback&quot;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [Callback callWithArguments:nil];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>将对象指向自身后，还可以向html注入js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)alert&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 直接添加提示框</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSString *str &#x3D; @&quot;alert(&#39;OC添加JS提示成功&#39;)&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [self.jsContext evaluateScript:str];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Git教程</title>
    <url>/2017-01-13-GitTutorial/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>　　Git是做项目的版本管理，你也可以称它们为版本管理工具。假如现在你有一个文件夹，里面可以是项目，也可以是你的个人笔记(如我这个博客)，或者是你的简历、毕业设计等等，都可以使用git来管理。</p>
<p>　　目前常用的版本控制器有Git和SVN，即使这两个你没有全用过，至少也会听过，我这里以Git为例，个人比较喜欢Git，你也可以看看这篇文章：<a href="http://www.worldhello.net/2012/04/12/why-git-is-better-than-svn.html" target="_blank" rel="noopener">为什么Git比SVN好</a>。我使用的是Mac，Mac上没自带Git环境，但是作为iOS开发者，我安装Xcode的时候，Xcode里是有自带Git的，所以我不需要考虑怎么去安装Git了。          </p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><strong>在Mac OS X上安装Git</strong>      </p>
<p>提供两种方法参考：      </p>
<blockquote>
<p>1、通过homebrew安装Git，具体方法请参考<a href="http://brew.sh/" target="_blank" rel="noopener">homebrew的文档</a><br>2、直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode。     </p>
</blockquote>
<p><strong>在Windows上安装Git</strong>      </p>
<blockquote>
<p>从<a href="https://git-for-windows.github.io" target="_blank" rel="noopener">https://git-for-windows.github.io</a> 下载，然后按默认选项安装即可，安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>
</blockquote>
<h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<blockquote>
<ul>
<li>$ git config –global user.name “Your Name”</li>
<li>$ git config –global user.email “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“</li>
</ul>
</blockquote>
<p>“Your Name”： 是每次提交时所显示的用户名，因为Git是分布式版本控制系统，当我们push到远端时，就需要区分每个提交记录具体是谁提交的，这个”Your Name”就是最好的区分。          </p>
<p>“email@example.com”： 是你远端仓库的email       </p>
<p>–global：用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然我们也可以对某个仓库指定不同的用户名和Email地址。         </p>
<h3 id="开始使用-建立仓库："><a href="#开始使用-建立仓库：" class="headerlink" title="开始使用-建立仓库："></a>开始使用-建立仓库：</h3><p>你在目标文件夹下使命令：    </p>
<blockquote>
<ul>
<li>git init  （创建.git文件）      </li>
</ul>
</blockquote>
<p>就会创建一个 <code>.git</code> 隐藏文件，相当于已经建立了一个本地仓库。</p>
<p><strong>添加到暂存区：</strong>      </p>
<blockquote>
<ul>
<li>git add .   （全部添加到暂存区）    </li>
<li>git commit -m ‘ first commit’  （提交暂存区的记录到本地仓库）     </li>
</ul>
</blockquote>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>git branc 查看时如出现</p>
<blockquote>
<ul>
<li>(HEAD detached at analytics_v2)   </li>
<li>dev</li>
<li>master</li>
</ul>
</blockquote>
<p>代表现在已经进入一个临时的HEAD，可以使用 <code>git checkout -b temp</code> 创建一个 temp branch，这样临时HEAD上修改的东西就不会被丢掉了。<br>然后切换到 dev 分支上，在使用 git branch merge temp，就可以把 temp 分支上的代码合并到 dev 上了。</p>
<br>

<p>转载请注明：<a href="https://yujialel.github.io" target="_blank" rel="noopener">M了个C的博客</a> » <a href="https://yujialel.github.io/2016/07/GitTutorial/" target="_blank" rel="noopener">点击阅读原文</a>     </p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods使用心得</title>
    <url>/2016-12-20-CocoaPod_Use/</url>
    <content><![CDATA[<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>　本章介绍什么是 <code>CocoaPods</code> ,如何使用 <code>CocoaPods</code> , 以及 <code>CocoaPods</code> 的原理,和使用 <code>CocoaPods</code> 时经常出现的一些问题。</p>
<p>　Cocoapods 是 OS X 和 iOS 下的一个第三方库管理工具。我们能使用CocoaPods添加被称作 “Pods”的依赖库,并轻松管理它们的版本,CocoaPods会帮我们配置好这些三方库的路径及开发环境,极大的提升了开发者的工作效率。</p>
<h3 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods　"></a>安装CocoaPods　</h3><p>　Mac下自带ruby,使用ruby的gem命令安装,ruby的软件源被墙了,把官方的ruby源替换成国内的淘宝源。</p>
<h3 id="更换Gem源"><a href="#更换Gem源" class="headerlink" title="更换Gem源"></a>更换Gem源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem sources --remove https://rubygems.org/</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ gem sources -a https://ruby.taobao.org/</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ gem sources -l</span></pre></td></tr></table></figure>
<ul>
<li>1.移除掉原有的源（服务器在国外，速度较慢）。</li>
<li>2.等1有反应之后再敲2命令（替换成淘宝上的ruby镜像https）。</li>
<li>3.验证是否成功。成功如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">http://ruby.taobao.org/</span></pre></td></tr></table></figure>

<h3 id="更新Gem源"><a href="#更新Gem源" class="headerlink" title="更新Gem源"></a>更新Gem源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo gem update --system</span></pre></td></tr></table></figure>

<h3 id="安装cocoapods"><a href="#安装cocoapods" class="headerlink" title="安装cocoapods"></a>安装cocoapods</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ pod setup</span></pre></td></tr></table></figure>

<p>pod setup 在执行时会比较慢，因为Cocoapods 要将它的信息下载到 ~/.cocoapods目录下, 耐心等待…</p>
<h4 id="提升cocoapods的安装速度"><a href="#提升cocoapods的安装速度" class="headerlink" title="提升cocoapods的安装速度"></a>提升cocoapods的安装速度</h4><p>所有的项目的 Podspec 文件都托管在<a href="https://github.com/CocoaPods/Specs。第一次执行" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs。第一次执行</a> pod setup 时，CocoaPods 会将这些podspec索引文件更新到本地的 ~/.cocoapods/目录下，这个索引文件比较大，有 80M 左右。<br>作者akinliu 在 gitcafe 和 oschina 上建立了 CocoaPods 索引库的镜像(在国内),我们可以使用CocoaPods国内的镜像索引，操作时会快多了,如gitcafe：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">pod repo remove master</span></pre></td></tr><tr><td class="code"><pre><span class="line">pod repo add master https://gitcafe.com/akuandev/Specs.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">pod repo update</span></pre></td></tr></table></figure>


<h3 id="使用cocoapods"><a href="#使用cocoapods" class="headerlink" title="使用cocoapods"></a>使用cocoapods</h3><p>cocoapods安装完成后，使用 pod search 命令来验证一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">pod search AFNetworking</span></pre></td></tr></table></figure>

<p>终端将会有如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">-&gt; AFNetworking (3.0.4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">A delightful iOS and OS X networking framework.</span></pre></td></tr><tr><td class="code"><pre><span class="line">pod <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 3.0.4'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">- Homepage: https://github.com/AFNetworking/AFNetworking</span></pre></td></tr><tr><td class="code"><pre><span class="line">- Source:   https://github.com/AFNetworking/AFNetworking.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">- Versions: 3.0.4, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-beta.3, 3.0.0-beta.2,</span></pre></td></tr><tr><td class="code"><pre><span class="line">3.0.0-beta.1, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.4, 2.5.3, 2.5.2, 2.5.1, 2.5.0,</span></pre></td></tr><tr><td class="code"><pre><span class="line">2.4.1, 2.4.0, 2.3.1, 2.3.0, 2.2.4, 2.2.3, 2.2.2, 2.2.1, 2.2.0, 2.1.0, 2.0.3,</span></pre></td></tr><tr><td class="code"><pre><span class="line">2.0.2, 2.0.1, 2.0.0, 2.0.0-RC3, 2.0.0-RC2, 2.0.0-RC1, 1.3.4, 1.3.3, 1.3.2,</span></pre></td></tr><tr><td class="code"><pre><span class="line">1.3.1, 1.3.0, 1.2.1, 1.2.0, 1.1.0, 1.0.1, 1.0, 1.0RC3, 1.0RC2, 1.0RC1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.10.1, 0.10.0, 0.9.2, 0.9.1, 0.9.0, 0.7.0, 0.5.1 [master repo]</span></pre></td></tr><tr><td class="code"><pre><span class="line">- Subspecs:</span></pre></td></tr><tr><td class="code"><pre><span class="line">- AFNetworking/Serialization (3.0.4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">- AFNetworking/Security (3.0.4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">- AFNetworking/Reachability (3.0.4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">- AFNetworking/NSURLSession (3.0.4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">- AFNetworking/UIKit (3.0.4)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">-&gt; AFNetworking+AutoRetry (0.0.5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Auto Retries <span class="keyword">for</span> AFNetworking requests</span></pre></td></tr><tr><td class="code"><pre><span class="line">pod <span class="string">'AFNetworking+AutoRetry'</span>, <span class="string">'~&gt; 0.0.5'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">- Homepage: https://github.com/shaioz/AFNetworking-AutoRetry</span></pre></td></tr><tr><td class="code"><pre><span class="line">- Source:   https://github.com/shaioz/AFNetworking-AutoRetry.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">- Versions: 0.0.5, 0.0.4, 0.0.3, 0.0.2, 0.0.1 [master repo]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">.........太多了，省略</span></pre></td></tr></table></figure>

<p>pod search 是CocoaPods的一个搜索命令,我们可以用来搜索任何托管在CocoaPods上的三方库。    </p>
<p>使用CocoaPods时需要新建一个 Podfile 的文件,cd 到 我的Demo项目里，Demo目录下有三个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Demo 、  Demo.xcodeproj  、 DemoTests</span></pre></td></tr></table></figure>

<p>新建 Podfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">touch Podfile</span></pre></td></tr></table></figure>

<p>vim 编辑 Podfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim Podfile</span></pre></td></tr></table></figure>
<p>由于是新建的 Podfile 里面应该是空白的。然后我们在里面添加依赖库，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">platform :ios</span></pre></td></tr><tr><td class="code"><pre><span class="line">pod <span class="string">'Reachability'</span>,  <span class="string">'~&gt; 3.0.0'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pod <span class="string">'ASIHTTPRequest'</span></span></pre></td></tr></table></figure>

<p>‘~&gt; 3.0.0’ 是 Reachability 的版本号, 设定了版本号CocoaPods就会下载对应的版本,ASIHTTPRequest没指定版本号,CocoaPods就会下载最新版本的ASIHTTPRequest。<br>退出编辑，执行 pod install 下载三方库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">pod install</span></pre></td></tr></table></figure>
<p>完成后我Demo项目下的文件多了几个:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Demo 、  Demo.xcodeproj  、 DemoTests （之前的三个）</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Demo.xcworkspace 、Podfile 、Podfile.lock 、Pods</span></pre></td></tr></table></figure>

<p>这个时候我们打开Demo项目是点击 Demo.xcworkspace 文件了，到此CocoaPods的基本使用已经讲完了，接下来的CocoaPods的原理，和让我们自己的三方库也支持CocoaPods。</p>
<p>待续…</p>
<p><a href="http://blog.jobbole.com/53365/" target="_blank" rel="noopener">深入理解 CocoaPods</a>    </p>
<br>

<p>转载请注明：<a href="https://yujialel.github.io" target="_blank" rel="noopener">M了个C的博客</a> » <a href="https://yujialel.github.io/2016/04/CocoaPod_Use/" target="_blank" rel="noopener">点击阅读原文</a>     </p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>开发常用工具</title>
    <url>/2016-12-12-Develop_Tool/</url>
    <content><![CDATA[<p>工欲善其事必先利其器，选择一些好的工具可以成吨的提高自己的工作效率。</p>
<h3 id="个人开发常用工具的收集"><a href="#个人开发常用工具的收集" class="headerlink" title="个人开发常用工具的收集"></a>个人开发常用工具的收集</h3><ul>
<li><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">cmd Markdown</a> 作业部落出版的Markdown编辑器       </li>
<li><a href="https://github.com/rest-client/rest-client" target="_blank" rel="noopener">RESTClient</a> 一个开源的客户端HTTP调试工具。    </li>
<li><a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">lantern</a> 蓝灯,一款开源的翻墙工具。    </li>
<li><a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">Charles</a> 青花瓷, 一款HTTP/HTTPS的抓包工具。<ul>
<li><a href="http://blog.devtang.com/2015/11/14/charles-introduction/" target="_blank" rel="noopener">Charles 从入门到精通</a>  </li>
</ul>
</li>
<li><a href="http://www.sublimetext.com" target="_blank" rel="noopener">Sublime</a> 一款强大的IDE,支持Python、JS、JSON格式化等等…更重要的是<code>Sublime</code>支持的插件很多。  <ul>
<li><a href="http://www.xuanfengge.com/practical-collection-of-sublime-plug-in.html" target="_blank" rel="noopener">实用的sublime插件集合</a>     </li>
</ul>
</li>
</ul>
<h3 id="文章配图网站"><a href="#文章配图网站" class="headerlink" title="文章配图网站"></a>文章配图网站</h3><p>还在为文章配图而苦恼吗？点击店面的网站吧，各种各样的图片帮你丰富你的文章。</p>
<p><a href="http://www.gratisography.com/" target="_blank" rel="noopener">Gratisography</a> gratisography 里面的图片每周都会更新，很多时尚流行的照片在里面，并且适合用在设计项目上。</p>
<p><a href="http://www.ssyer.com/home-index.html" target="_blank" rel="noopener">ssyer</a>国内的网站，不需要翻墙，速度很快，图片最全。完全免费的图片库。</p>
<p><a href="https://pixabay.com/" target="_blank" rel="noopener">Pixabay</a> 不同类型的高清摄影照片。</p>
<h3 id="UI设计网站"><a href="#UI设计网站" class="headerlink" title="UI设计网站"></a>UI设计网站</h3><p>作为一个开发者，自己写些小程序的时候经常会为没有UI而烦恼，下面就是一些UI设计网站，有新颖的UI界面设计，也有单独的UI元素，icon等。</p>
<p><a href="http://www.ui.cn/" target="_blank" rel="noopener">UI中国</a> 国内潮流的UI设计作品。</p>
<p><a href="http://www.webdesigndev.com/" target="_blank" rel="noopener">webdesigndev</a> 国外网站设计文章，各种各样的资料看到你眼花缭乱。</p>
<p><a href="https://dribbble.com/" target="_blank" rel="noopener">dribbble</a> 接触过设计的应该都知道，一个很好的UI设计平台。</p>
<p><a href="http://www.flaticon.com/" target="_blank" rel="noopener">flaticon</a> 各种icon的设计，一定有你想想要的。</p>
<br>

<p>转载请注明：<a href="https://yujialel.github.io" target="_blank" rel="noopener">M了个C的博客</a> » <a href="https://yujialel.github.io/2016/04/Develop_Tool/" target="_blank" rel="noopener">点击阅读原文</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown工具集</title>
    <url>/2016-11-20-MarkdownTool/</url>
    <content><![CDATA[<p>最近发现群里面的大佬们都有自己的博客, 用来记录一下自己每隔一段时间的收获。然后自己本着向大佬看齐同时也觉得这确实是一个可以记录自己收获的好工具, 就去研究了一下。下面就是记录的一些 markdown 平时用到的一些语法, 方便自己查看吧。同时也仅此记录一下, 从此也有属于自己的博客了, 向大佬更近了一步😈。</p>
<h3 id="一、快捷键"><a href="#一、快捷键" class="headerlink" title="一、快捷键"></a>一、快捷键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加粗 Ctrl + B   </span></pre></td></tr><tr><td class="code"><pre><span class="line">斜体 Ctrl + I</span></pre></td></tr><tr><td class="code"><pre><span class="line">引用 Ctrl + Q</span></pre></td></tr><tr><td class="code"><pre><span class="line">插入链接 Ctrl + L</span></pre></td></tr><tr><td class="code"><pre><span class="line">插入代码 Ctrl + K</span></pre></td></tr><tr><td class="code"><pre><span class="line">插入图片 Ctrl + G</span></pre></td></tr><tr><td class="code"><pre><span class="line">提升标题 Ctrl + H</span></pre></td></tr><tr><td class="code"><pre><span class="line">有序列表 Ctrl + O</span></pre></td></tr><tr><td class="code"><pre><span class="line">无需列表 Ctrl + U</span></pre></td></tr><tr><td class="code"><pre><span class="line">横线 Ctrl + R</span></pre></td></tr><tr><td class="code"><pre><span class="line">撤销 Ctrl + Z</span></pre></td></tr><tr><td class="code"><pre><span class="line">重做 Ctrl + Y</span></pre></td></tr></table></figure>

<h3 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h3><blockquote>
<p>####(一) 对字体设置斜体、粗体、删除线   </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**粗体文本**</span></pre></td></tr><tr><td class="code"><pre><span class="line">*斜体文本*      </span></pre></td></tr><tr><td class="code"><pre><span class="line">*文字*</span></pre></td></tr><tr><td class="code"><pre><span class="line">_文字_</span></pre></td></tr><tr><td class="code"><pre><span class="line">~~文字~~</span></pre></td></tr></table></figure>
<p>效果如下:<br><strong>粗体</strong><br><em>斜体</em><br><em>斜体</em><br><del>删除线</del></p>
<blockquote>
<p>####(二) 分级标题, 两种写法 </p>
</blockquote>
<p>写法1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span></pre></td></tr><tr><td class="code"><pre><span class="line">## 二级标题</span></pre></td></tr><tr><td class="code"><pre><span class="line">### 三级标题</span></pre></td></tr><tr><td class="code"><pre><span class="line">#### 四级标题 </span></pre></td></tr><tr><td class="code"><pre><span class="line">##### 五级标题</span></pre></td></tr><tr><td class="code"><pre><span class="line">###### 六级标题  (这个写法 和 **普通文字** 的效果是一样的)</span></pre></td></tr></table></figure>

<p>写法2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个一级标题</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">或者</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">二级标题</span></pre></td></tr><tr><td class="code"><pre><span class="line">-------------------</span></pre></td></tr></table></figure>


<blockquote>
<p>####(三) 链接</p>
</blockquote>
<p>(1) 插入本地图片链接, 语法规则, 有两种写法: </p>
<pre><code>![图片描述](图片路径&quot;title&quot;)
![图片描述](图片路径)
注意: 这个图片描述可以不写</code></pre><p>(2) 插入互联网图片, 语法规则: </p>
<pre><code>![图片描述](图片网络路径)
注意: 这个图片描述也可以不写</code></pre><p><img src="http://pic31.nipic.com/20130731/13313355_145329022000_2.jpg" alt="网络图片"></p>
<p>(3) 自动链接<br>Markdown 支持以比较简短的自动形式来处理网址和电子邮件信箱, 只需要用 ‘&lt; &gt;’ 包起来, Markdown 就会自动把它转成链接, 也可以直接写, 也是可以显示成链接形式的。例如: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;https:&#x2F;&#x2F;www.baidu.com&gt;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.baidu.com</span></pre></td></tr></table></figure>

<blockquote>
<p>####(四) 分割线</p>
</blockquote>
<p>你可以再一行中用三个以上的星号(*)、减号(-)、下划线(_)来建立一个分隔线, 注意行内不能有其他东西。你也可以在星号或者减号中间插入空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span></pre></td></tr><tr><td class="code"><pre><span class="line">___   </span></pre></td></tr><tr><td class="code"><pre><span class="line">---</span></pre></td></tr></table></figure>
<p>效果</p>
<hr>
<hr>
<hr>
<blockquote>
<p>####(五) 代码块</p>
</blockquote>
<p>对于程序员来说这个功能是必不可少的, 插入程序代码的方式有两种, 一种是利用缩进(tab), 另一种是利用英文”`”符号 (一般在ESC的下方, 和~是同一个按键) 包裹代码。</p>
<p>(1) 代码块: 缩进4个空格或是1个制表符。</p>
<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;hello world\n&quot;);
}</code></pre><p>(2) 行内式: 如果在一个行内需要引用代码, 只要用单反引号`引起来就好了。</p>
<p>这是一个示例<code>示例效果</code></p>
<p>(3) 多行代码块与语法高亮: 在需要高亮的代码块的前一行和后一行使用三个单反引号包裹, 就可以了(块内的 ‘&#39; 请忽略)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\</span></pre></td></tr></table></figure>
<p>class Demo{<br>    public static void test () {<br>    }<br>}<br>```</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">效果</span></pre></td></tr></table></figure>
<p>class Demo{<br>    public static void test () {<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">(4) 代码块里面包含html代码</span></pre></td></tr><tr><td class="code"><pre><span class="line">在代码块里面, &amp;、&lt; 和 &gt; 会自动转存 HTML 实体, 这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码, 只需要复制粘贴上去, 剩下的 Markdown 都会帮你处理。(注意: 简书的代码块里不支持HTML)</span></pre></td></tr></table></figure>
<table>
    <tr>
        <th rowpan="2">值班人员</th>
        <th>星期一</th>
        <th>星期二</th>
        <th>星期三</th>
    </tr>
    <tr>
        <td>小强</td>
        <td>小明</td>
        <td>小瓶</td>
    </tr>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span></pre></td></tr></table></figure>
<tr>
    <th rowpan="2">值班人员</th>
    <th>星期一</th>
    <th>星期二</th>
    <th>星期三</th>
</tr>
<tr>
    <td>小强</td>
    <td>小明</td>
    <td>小瓶</td>
</tr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;table&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; ####(六) 引用</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">在被引用的文本前加上 &gt; 符号, 以及一个空格就可以了, 如果只输入一个 &gt; 符号会产生空白的引用。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">(1) 基本使用</span></pre></td></tr></table></figure>
> 文字
>
> 文字
>
>
> 文字
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(2) 引用的嵌套使用</span></pre></td></tr></table></figure>
>>> 引用1
>> 引用2
> 引用3
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(3) 引用其它要素</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">引用的区块也可以使用其他 Markdown 语法， 包括标题、列表、代码区块等。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; ####(七) 列表</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">(1) 无序列表</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">使用 *, +, - 表示无序列表。</span></pre></td></tr><tr><td class="code"><pre><span class="line">**注意: 符号后面一定要有空格, 起到缩进的作用**</span></pre></td></tr></table></figure>
- 列表文字
- 列表文字
- 列表文字

<ul>
<li>列表文字</li>
<li>列表文字</li>
<li>列表文字</li>
</ul>
<ul>
<li>列表文字</li>
<li>列表文字</li>
<li>列表文字<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 列表文字</span></pre></td></tr><tr><td class="code"><pre><span class="line">- 列表文字</span></pre></td></tr><tr><td class="code"><pre><span class="line">- 列表文字</span></pre></td></tr><tr><td class="code"><pre><span class="line">* 列表文字</span></pre></td></tr><tr><td class="code"><pre><span class="line">* 列表文字</span></pre></td></tr><tr><td class="code"><pre><span class="line">* 列表文字</span></pre></td></tr><tr><td class="code"><pre><span class="line">+ 列表文字</span></pre></td></tr><tr><td class="code"><pre><span class="line">+ 列表文字</span></pre></td></tr><tr><td class="code"><pre><span class="line">+ 列表文字</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">(2) 有序列表</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">使用数字和一个英文句点表示有序列表。</span></pre></td></tr><tr><td class="code"><pre><span class="line">**注意: 英文句点后面一定要有一个空格, 起到缩进的作用。**</span></pre></td></tr></table></figure>
不加空格</li>
</ul>
<p>1.有序错误<br>2.有序错误<br>3.有序错误</p>
<p>加空格</p>
<ol>
<li>有序示范</li>
<li>有序示范</li>
<li>有序示范<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">不加空格</span></pre></td></tr><tr><td class="code"><pre><span class="line">1.有序错误</span></pre></td></tr><tr><td class="code"><pre><span class="line">2.有序错误</span></pre></td></tr><tr><td class="code"><pre><span class="line">3.有序错误</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">加空格</span></pre></td></tr><tr><td class="code"><pre><span class="line">1. 有序示范</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. 有序示范</span></pre></td></tr><tr><td class="code"><pre><span class="line">3. 有序示范</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">(3) 有序列表和无序列表同时使用</span></pre></td></tr></table></figure>
无序</li>
</ol>
<ul>
<li>文字1</li>
<li>文字2<br>有序</li>
</ul>
<ol>
<li>文字1</li>
<li>文字2<br>混合使用</li>
</ol>
<p>*1. 文字1<br>*2. 文字2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无序</span></pre></td></tr><tr><td class="code"><pre><span class="line">* 文字1</span></pre></td></tr><tr><td class="code"><pre><span class="line">* 文字2</span></pre></td></tr><tr><td class="code"><pre><span class="line">  有序</span></pre></td></tr><tr><td class="code"><pre><span class="line">1. 文字1</span></pre></td></tr><tr><td class="code"><pre><span class="line">2. 文字2</span></pre></td></tr><tr><td class="code"><pre><span class="line">   混合使用</span></pre></td></tr><tr><td class="code"><pre><span class="line">   *1. 文字1</span></pre></td></tr><tr><td class="code"><pre><span class="line">   *2. 文字2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">(4) 列表和其他要素混合使用</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">列表不光可以单独使用, 也可以使用其他的 Markdown 语法, 包括标题、引用、代码区块等。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">**注意事项:</span></pre></td></tr><tr><td class="code"><pre><span class="line">(1) 加粗效果不能直接用于列表标题里面, 但是可以嵌套在列表里面混合使用</span></pre></td></tr><tr><td class="code"><pre><span class="line">(2) 列表中包含代码块 (前面加2个tab或者8个空格, 并且需要空一行, 否则不显示)。**</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">(5) 注意事项</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">在使用列表时, 只要是数字后面加上英文的点, 就会无意间产生列表, 比如2017.12.20这时候想表达的是日期, 有些软件把它误认为是列表。解决方式: 在每个点前面加上 \ 就可以了。</span></pre></td></tr></table></figure>
<p>2017.12.20. 今天是个好天气。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; ####(八) 表格</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">表格的基本写法很简单, 就跟表格形状很相似:</span></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody><tr>
<td>小明</td>
<td>男</td>
<td>95</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>70</td>
</tr>
<tr>
<td>小龙</td>
<td>女</td>
<td>55</td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">| 学号   | 姓名   | 分数   |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| ---- | ---- | ---- |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| 小明   | 男    | 95   |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| 小红   | 女    | 70   |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| 小龙   | 女    | 55   |</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">**表格对齐方式: 我们可以指定表格的单元格的对齐方式, 冒号在左边表示左对齐, 右边表示右对齐, 两边都有表示居中。**</span></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>学号</td>
<td>姓名</td>
<td>分数</td>
</tr>
<tr>
<td>:-</td>
<td>:-:</td>
<td>-:</td>
</tr>
<tr>
<td>小明</td>
<td>男</td>
<td>95</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>70</td>
</tr>
<tr>
<td>小龙</td>
<td>女</td>
<td>55</td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 学号   |  姓名  |   分数 |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| :--- | :--: | ---: |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| 小明   |  男   |   95 |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| 小红   |  女   |   70 |</span></pre></td></tr><tr><td class="code"><pre><span class="line">| 小龙   |  女   |   55 |</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">### 三、常用技巧</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; ####(一) 换行</span></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>方法1: 连续两个以上空格 + 回车</td>
<td></td>
<td></td>
</tr>
<tr>
<td>方法2: 使用html语言换行标签: <br></td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; ####(二) 缩进字符</span></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>不断行的空格 &nbsp; 或 &#160;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>半角空格 &ensp; 或 &#8194;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>全角空格 &emsp; 或 &#8195;</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ####(三) 如何打出一些特殊符号</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">* (1) 对于 Markdown 中的语法符号, 前面加反斜杠 \ 即可显示符号本身。</span></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>\ 反斜杠</td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 星号</td>
<td></td>
<td></td>
</tr>
<tr>
<td>_ 下划线</td>
<td></td>
<td></td>
</tr>
<tr>
<td>{}[]() 括号</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">* (2) 其他特殊字符</span></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&#10084;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&#10003;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&#9782;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&#9733;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&#9775;</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符对应的 Unicode 编码, 可以看这个网站 &lt;https:&#x2F;&#x2F;unicode-table.com&#x2F;cn&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">**附上几个工具对特殊字符的支持的对比图:**</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">**工具或网站** | **是否特殊字符**</span></pre></td></tr><tr><td class="code"><pre><span class="line">:-|:-</span></pre></td></tr><tr><td class="code"><pre><span class="line">简书|是</span></pre></td></tr><tr><td class="code"><pre><span class="line">MarkDownPad|否(不知道付费版是否支持)</span></pre></td></tr><tr><td class="code"><pre><span class="line">有道云笔记|是</span></pre></td></tr><tr><td class="code"><pre><span class="line">zybuluo.com|是</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; ####(四) 字体、字号与颜色</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Markdown是一种可以使用普通文本编辑器编写的标记语言, 通过类似HTML的标记语法, 它可以使普通文本内容具有一定的格式。 但是它本身是不支持修改字体、字号与颜色等功能的!</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">CSDN-markdown 编辑器是其衍生版本, 扩展了 Markdown 的功能 (如表格、脚注、内嵌HTML等), 对, 就是内嵌HTML, 接下来要说的功能就需要内嵌HTML的方法来实现。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">字体, 字号和颜色编辑如下代码</span></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td><font face="黑体">我是黑体</font></td>
<td></td>
<td></td>
</tr>
<tr>
<td><font face="微软雅黑">我是微软雅黑</font></td>
<td></td>
<td></td>
</tr>
<tr>
<td><font face="STCAIYUN">我是华文彩云</font></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Size: 规定文本的尺寸大小。可能的值:从 1 到 7 的数字。浏览器默认是 3。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; ####(五) 链接的高级操作 (这个需要掌握一下, 很有用)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">**(1) 行内式。这个在上文第二条 &#96;基本语法&#96; 的 &#96;链接&#96; 这个小结已经讲过, 这里就不继续讲解了。**</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">**(2) 参考式链接。**</span></pre></td></tr></table></figure>
<p>在文档要插入图片的地方写 ![图片或网址][标记], 在文档的最后写上[标记]:图片地址 “标题”。(最后这个”标题”可以不填写)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line">写法:</span></pre></td></tr><tr><td class="code"><pre><span class="line">[简书地址][1], [文章地址][3], [百度地址][2]</span></pre></td></tr><tr><td class="code"><pre><span class="line">标记:</span></pre></td></tr><tr><td class="code"><pre><span class="line">[1]:https:&#x2F;&#x2F;www.jianshu.com</span></pre></td></tr><tr><td class="code"><pre><span class="line">[2]:https:&#x2F;&#x2F;www.baidu.com &quot;百度&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">[3]:https:&#x2F;&#x2F;www.zybuluo.com&#x2F;15606711121&#x2F;note&#x2F;1063289</span></pre></td></tr></table></figure>

<p><strong>(3) 内容目录</strong></p>
<p>在段落中填写 [TOC] 以显示全文内容的目录结构。</p>
<p><strong>(4) 锚点</strong></p>
<p>锚点其实就是页内超链接。比如我这里写下一个锚点, 就能跳转到目录。在目录中点击这个点, 就能跳回来。</p>
<p><strong>注意: 在简书中使用锚点时, 点击会打开一个新的页面, 虽然锚点用的不是很舒服, 但是可以用注脚实现这个功能。</strong></p>
<p><strong>语法说明:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在你准备跳转到的指定标题后面插入锚点&#123;#标记&#125;,  然后再文档其它地方写上连接到锚点的链接。</span></pre></td></tr></table></figure>
<p>使用如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">插入锚点</span></pre></td></tr><tr><td class="code"><pre><span class="line">## 标题 &#123;#index&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">链接锚点</span></pre></td></tr><tr><td class="code"><pre><span class="line">跳转到[标题](#index)</span></pre></td></tr></table></figure>

<p><strong>(5) 注脚</strong></p>
<p>语法说明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在需要添加注脚的文字后加上注脚名字[^注脚名字], 称为加注。然后在文本的任意位置(一般在文章末尾)添加注脚。</span></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 Markdown[^1] 可以效率的书写文档, 并直接转换为 HTML[^2] 语言。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[^1]:Markdown是一种纯文本标记语言    </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[^2]:HyperText Markup Language 超文本标记语言</span></pre></td></tr></table></figure>
<p>注:<br>(1) 脚注自动被搬运到最后面, 请到文章末尾查看, 并且脚注的链接可以直接回到加注的地方。<br>(2) 由于简书不支持锚点 , 所以可以用脚注实现页面内部跳转。</p>
<blockquote>
<p>####(六) 背景色</p>
</blockquote>
<p>Markdown本身不支持背景色设置, 需要采用内置html的方式实现: 借助 table, tr, td等表格的 bgcolor 属性来实现背景色的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;orange&gt;背景色为:orange&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;</span></pre></td></tr></table></figure>

<blockquote>
<p>####(七) emoji表情符号</p>
</blockquote>
<p>emoji表情使用:EMOJICODE:的格式, 详细列表可见<br><a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">https://www.webpagefx.com/tools/emoji-cheat-sheet/</a></p>
<p>现在很多 Markdown 工具或者网站都不支持。</p>
<p><strong>下面列出平台对比:</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>工具或网站</strong></th>
<th align="left"><strong>是否支持emoji表情符号</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">简书</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">MarkDownPad</td>
<td align="left">否(付费版未知)</td>
</tr>
<tr>
<td align="left">有道云笔记</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">zybuluo.com</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">github</td>
<td align="left">是</td>
</tr>
</tbody></table>
<p>###四、高端用法</p>
<p>目前的简书, CSDN, 包括MarkdownPad软件都不支持下面这些功能, 有一个网站 <a href="https://www.zybuluo.com" target="_blank" rel="noopener">https://www.zybuluo.com</a> 可以支持。</p>
<blockquote>
<p>####(一) 使用LaTex数学公式</p>
</blockquote>
<ul>
<li><ol>
<li>行内公式: 使用两个 “$”  符号引用公式:</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$公式$</span></pre></td></tr></table></figure>
<ul>
<li><ol start="2">
<li>行间公式: 使用两对 “$$” 符号引用公式:</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$公式$$</span></pre></td></tr></table></figure>
<p>举例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\sqrt&#123;x^&#123;2&#125;&#125;$</span></pre></td></tr></table></figure>
<p>$\sqrt{x^{2}}$</p>
<p>具体参考 <a href="http://blog.csdn.net/testcs_dn/article/details/44229085" target="_blank" rel="noopener">markdown编辑器使用LaTeX数学公式</a></p>
<blockquote>
<p>####(二) 流程图</p>
</blockquote>
<p>简单介绍一下流程图语法, 仅作了解, 如下</p>
<p><strong>Markdown 流程图语法主要有三部分组成, 流程图语块定义、流程图符号声明和流程处理</strong></p>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\&#96;&#96;&#96;flow    </span></pre></td></tr><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始     &#x2F;&#x2F; 定义流程图的开始</span></pre></td></tr><tr><td class="code"><pre><span class="line">op1&#x3D;&gt;operation: My Operation    &#x2F;&#x2F; 定义一个长方形的里路程图</span></pre></td></tr><tr><td class="code"><pre><span class="line">c&#x3D;&gt;condition: YES or NO?    &#x2F;&#x2F; 定义一个判断</span></pre></td></tr><tr><td class="code"><pre><span class="line">e&#x3D;&gt;end: 结束    &#x2F;&#x2F; 定义了流程图结束</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">st-&gt;op1-&gt;c      &#x2F;&#x2F; 从开始到长方形再到判断</span></pre></td></tr><tr><td class="code"><pre><span class="line">c(yes)-&gt;e       &#x2F;&#x2F; 判断为真的时候执行分支</span></pre></td></tr><tr><td class="code"><pre><span class="line">c(no)-&gt;op1      &#x2F;&#x2F; 判断为假的时候执行分支</span></pre></td></tr><tr><td class="code"><pre><span class="line">\</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">效果</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;flow</span></pre></td></tr><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始:&gt;www.baidu.com     </span></pre></td></tr><tr><td class="code"><pre><span class="line">op1&#x3D;&gt;operation: My Operation    </span></pre></td></tr><tr><td class="code"><pre><span class="line">c&#x3D;&gt;condition: YES or NO?    </span></pre></td></tr><tr><td class="code"><pre><span class="line">e&#x3D;&gt;end: 结束    </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">st-&gt;op1-&gt;c</span></pre></td></tr><tr><td class="code"><pre><span class="line">c(yes)-&gt;e</span></pre></td></tr><tr><td class="code"><pre><span class="line">c(no)-&gt;op1</span></pre></td></tr></table></figure>
<pre><code>*另外,可以在流程图符号后面加上需要跳转的链接, 例如: 
st=&gt;start: 开始:&gt;www.baidu.com*</code></pre><p><strong>说明: operation、subroutine 和 inputoutput 分别对应的是 长方形、子程序和四边形, 需要哪一种就写哪一个。</strong></p>
<p>也可以通过(right, left, top, bottom)这四个方向来调整流程图处理的时候调整流程的方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\&#96;&#96;&#96;flow    </span></pre></td></tr><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始     &#x2F;&#x2F; 定义流程图的开始</span></pre></td></tr><tr><td class="code"><pre><span class="line">op1&#x3D;&gt;operation: My Operation    &#x2F;&#x2F; 定义一个长方形的里路程图</span></pre></td></tr><tr><td class="code"><pre><span class="line">c&#x3D;&gt;condition: YES or NO?    &#x2F;&#x2F; 定义一个判断</span></pre></td></tr><tr><td class="code"><pre><span class="line">e&#x3D;&gt;end: 结束    &#x2F;&#x2F; 定义了流程图结束</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">st(right)-&gt;op1(right)-&gt;c      &#x2F;&#x2F; 从开始到长方形再到判断</span></pre></td></tr><tr><td class="code"><pre><span class="line">c(yes,right)-&gt;e       &#x2F;&#x2F; 判断为真的时候执行分支</span></pre></td></tr><tr><td class="code"><pre><span class="line">c(no,top)-&gt;op1      &#x2F;&#x2F; 判断为假的时候执行分支</span></pre></td></tr><tr><td class="code"><pre><span class="line">\</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;flow</span></pre></td></tr><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始:&gt;www.baidu.com     </span></pre></td></tr><tr><td class="code"><pre><span class="line">op1&#x3D;&gt;operation: My Operation    </span></pre></td></tr><tr><td class="code"><pre><span class="line">c&#x3D;&gt;condition: YES or NO?    </span></pre></td></tr><tr><td class="code"><pre><span class="line">e&#x3D;&gt;end: 结束    </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">st(right)-&gt;op1(right)-&gt;c</span></pre></td></tr><tr><td class="code"><pre><span class="line">c(yes,right)-&gt;e</span></pre></td></tr><tr><td class="code"><pre><span class="line">c(no,top)-&gt;op1</span></pre></td></tr></table></figure>
<p>更多流程图语法参考: <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">流程图语法参考</a></p>
<blockquote>
<p>####(三) 制作一份待办事宜—-Todo列表 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**使用规范:**</span></pre></td></tr><tr><td class="code"><pre><span class="line">- [ ] 已处理的事情1</span></pre></td></tr><tr><td class="code"><pre><span class="line">- [ ] 已处理的事情2</span></pre></td></tr><tr><td class="code"><pre><span class="line">- [x] 未处理的事情1</span></pre></td></tr><tr><td class="code"><pre><span class="line">- [x] 未处理的事情22</span></pre></td></tr></table></figure>
<ul>
<li><input disabled type="checkbox"> 已处理的事情1</li>
<li><input disabled type="checkbox"> 已处理的事情2</li>
<li><input checked disabled type="checkbox"> 未处理的事情1</li>
<li><input checked disabled type="checkbox"> 未处理的事情22</li>
</ul>
<blockquote>
<p>####(四) 绘制 序列图</p>
</blockquote>
<p><strong>使用示范:</strong></p>
<pre><code>​```seq
Alice-&gt;bob: hello bob, how are you?
Note right of bob: bob thinks
bob--&gt;Alice: I am good thanks!
​```</code></pre><p>效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello bob, How are you?</span></pre></td></tr><tr><td class="code"><pre><span class="line">Note left of Alice: Look Bob</span></pre></td></tr><tr><td class="code"><pre><span class="line">Note right of Bob: Bob thinks</span></pre></td></tr><tr><td class="code"><pre><span class="line">Bob--&gt;Alice: I am good, thanks!</span></pre></td></tr></table></figure>

<pre><code>​```sep
Title: here is a title  // 标题
A-&gt;B: Normal line       // 实心箭头, 实线
B--&gt;C: Dashed line      // 实心箭头, 虚线
C-&gt;&gt;D: Open arrow       // 空心箭头, 实线
D--&gt;&gt;A: Dashed open arrow   // 空心箭头, 虚线
​```</code></pre><p>效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title: Here is a title</span></pre></td></tr><tr><td class="code"><pre><span class="line">A-&gt;B: Normal line</span></pre></td></tr><tr><td class="code"><pre><span class="line">B--&gt;C: Dashed line</span></pre></td></tr><tr><td class="code"><pre><span class="line">C-&gt;&gt;D: Open arrow</span></pre></td></tr><tr><td class="code"><pre><span class="line">D--&gt;&gt;A: Dashed open arrow</span></pre></td></tr></table></figure>
<p>更多语法参考: <a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">序列图语法参考</a></p>
<blockquote>
<p>####(五) 绘制 甘特图</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\&#96;&#96;&#96; gantt</span></pre></td></tr><tr><td class="code"><pre><span class="line">title 项目开发流程</span></pre></td></tr><tr><td class="code"><pre><span class="line">section 项目确定</span></pre></td></tr><tr><td class="code"><pre><span class="line">    需求分析    :a1, 2018-03-05, 3d</span></pre></td></tr><tr><td class="code"><pre><span class="line">    可行性报告  :after a1, 5d</span></pre></td></tr><tr><td class="code"><pre><span class="line">    概念验证    :5d</span></pre></td></tr><tr><td class="code"><pre><span class="line">section 项目实施</span></pre></td></tr><tr><td class="code"><pre><span class="line">    概要设计    :2018-03-13, 5d</span></pre></td></tr><tr><td class="code"><pre><span class="line">    详细设计    :2018-03-18, 10d</span></pre></td></tr><tr><td class="code"><pre><span class="line">    编码        :2018-03-28, 10d</span></pre></td></tr><tr><td class="code"><pre><span class="line">    测试        :2018-04-07, 5d</span></pre></td></tr><tr><td class="code"><pre><span class="line">section 发布验收</span></pre></td></tr><tr><td class="code"><pre><span class="line">    发布: 3d</span></pre></td></tr><tr><td class="code"><pre><span class="line">    验收: 3d</span></pre></td></tr><tr><td class="code"><pre><span class="line">\</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">效果</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;&#96;&#96; gantt</span></pre></td></tr><tr><td class="code"><pre><span class="line">title 项目开发流程</span></pre></td></tr><tr><td class="code"><pre><span class="line">section 项目确定</span></pre></td></tr><tr><td class="code"><pre><span class="line">    需求分析    :a1, 2018-03-05, 3d</span></pre></td></tr><tr><td class="code"><pre><span class="line">    可行性报告  :after a1, 5d</span></pre></td></tr><tr><td class="code"><pre><span class="line">    概念验证    :5d</span></pre></td></tr><tr><td class="code"><pre><span class="line">section 项目实施</span></pre></td></tr><tr><td class="code"><pre><span class="line">    概要设计    :2018-03-13, 5d</span></pre></td></tr><tr><td class="code"><pre><span class="line">    详细设计    :2018-03-18, 10d</span></pre></td></tr><tr><td class="code"><pre><span class="line">    编码        :2018-03-28, 10d</span></pre></td></tr><tr><td class="code"><pre><span class="line">    测试        :2018-04-07, 5d</span></pre></td></tr><tr><td class="code"><pre><span class="line">section 发布验收</span></pre></td></tr><tr><td class="code"><pre><span class="line">    发布: 3d</span></pre></td></tr><tr><td class="code"><pre><span class="line">    验收: 3d</span></pre></td></tr></table></figure>
<p>更多语法参考: <a href="https://knsv.github.io/mermaid/#gant-diagrams" target="_blank" rel="noopener">甘特图语法参考</a></p>
<p>[^2]: HyperText Markup Language 超文本标记语言</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
