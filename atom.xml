<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M了个Cの播客</title>
  
  <subtitle>做更好的自己</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoursite.com/"/>
  <updated>2020-03-21T04:17:26.531Z</updated>
  <id>https://yoursite.com/</id>
  
  <author>
    <name>M了个C</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS探索之--类的结构分析(一)</title>
    <link href="https://yoursite.com/2020-03-21-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
    <id>https://yoursite.com/2020-03-21-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90(%E4%B8%80)/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T04:17:26.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 在前面的几篇文章对 <code>iOS</code> 对象的原理进行了探索, 那么类在底层的实现又是什么样子的呢? 类是以什么样的形式存在的? 他的结构又是什么样子的呢? 接下来我们一起来展开对类的一些相关内容探索, 看一下他的真面目。</p></blockquote><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><blockquote><p> 说到 <code>类</code> , 我相信看这篇文章的人都不会陌生, 那么什么是类呢? </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">类 (Class) 是面向对象程序设计 (OOP, Object-Oriented Programming) 实现信息封装的基础。类是一种用户自定义的数据类型,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">也称类类型。每个类包含数据说明和一组操作数据或传递信息的函数(或者方法)。类的实例称为对象。</span></pre></td></tr></table></figure><p>在我们 <code>iOS</code> 中, 我们知道大多数情况下我们使用的类都是从 <code>NSObject</code> 这个基类所派生出来的, 在 <code>OC</code> 的底层, 我们的类到底是什么样子的呢? 接下来开始我们的探索:</p><ol><li>首先在我们的工程里面去尝试直接点进去查看一下, 看看能不能有什么发现</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Class</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_class</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">#if !__OBJC2__</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125; OBJC2_UNAVAILABLE;</span></pre></td></tr></table></figure><p>查看 <code>Class</code> , 发现有一个关于他的结构体定义, 可以看出 <code>Class</code> 本质其实是一个 <code>objc_class</code> 类型的 <strong>结构体指针</strong>。然后我们继续去查看关于 <code>objc_class</code> 的相关内容, 发现了关于该结构体的一些声明, 但是有一个东西需要注意 <code>OBJC2_UNAVAILABLE</code> , 从该宏定义的名字可以看出, 这个定义在我们的 <code>OBJC2</code> 中已经废弃掉了。</p><blockquote><p>关于 <code>OBJC2_UNAVAILABLE</code> 的宏定义, 我在 <code>objc</code> 源码中找到了 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt;&#x2F;* OBJC2_UNAVAILABLE: unavailable in objc 2.0, deprecated in Leopard *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&gt;#if !defined(OBJC2_UNAVAILABLE)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&gt;#   if __OBJC2__</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&gt;#       define OBJC2_UNAVAILABLE UNAVAILABLE_ATTRIBUTE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&gt;#   else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">       &#x2F;* plain C code also falls here, but this is close enough *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&gt;#       define OBJC2_UNAVAILABLE                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">           __OSX_DEPRECATED(10.5, 10.5, &quot;not available in __OBJC2__&quot;) \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">           __IOS_DEPRECATED(2.0, 2.0, &quot;not available in __OBJC2__&quot;)   \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">           __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE __BRIDGEOS_UNAVAILABLE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&gt;#   endif</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&gt;#endif</span></pre></td></tr></table></figure></blockquote><ol start="2"><li>很显然我们没有办法去直接查看 <code>objc_class</code> , 接下来我们去之前一直在使用的 <code>objc</code> 源码中去搜索一下, 发现了新的声明</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_class (一个隐藏的 ISA), 继承自 objc_object</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; Class ISA; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    Class superclass; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#x2F;*</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    ...一大堆函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_object (包含 isa)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><p>在源码中我们找到了新的 <code>objc_class</code> 定义, 发现他继承自 <code>objc_object</code> , 并且 <code>isa</code> 也是从 <code>objc_object</code> 继承过来的, 并没有自己去定义。然后从继承关系上我们还可以得出, <strong>类其实也是一种对象</strong>, 他也有自己的 <code>isa</code> , 并且指向 <strong>元类</strong>。</p><blockquote><p><strong>万物皆对象</strong></p><p>每个实例对象都有个 isa 指针, 指向对象的 (Class)类; 而类对象里也有个 isa 指针, 指向的是 meteClass(元类)。关于 isa 的指向可以去看看我之前的文章 <a href="https://juejin.im/post/5e69972fe51d4527086b4e67" target="_blank" rel="noopener">iOS探索–isa的初始化和指向分析</a></p></blockquote><h2 id="类的结构分析"><a href="#类的结构分析" class="headerlink" title="类的结构分析"></a>类的结构分析</h2><p>在上面的过程中我们找到了关于类的定义, 接下来我们具体看看类的结构是什么样子的? 每一部分的作用又是什么? (注意, 这里内存占用情况默认为 64位情况下)</p><h3 id="1-Class-isa"><a href="#1-Class-isa" class="headerlink" title="1. Class isa"></a>1. Class isa</h3><p>类对象中的 <code>isa</code> 指针, 用于关联 <code>元类</code> , 关于这一点在之前的 <code>isa</code> 指向流程图中可以看出来。<code>Class</code> 类型是一个指针, 所以 <code>isa</code> 占用 8 字节。</p><h3 id="2-Class-superclass"><a href="#2-Class-superclass" class="headerlink" title="2. Class superclass"></a>2. Class superclass</h3><p>根据名字应该可以看出来表示 <code>当前类的父类</code> ,同样是 <code>Class</code> 类型, 所以 <code>superclass</code> 也占 8 个字节。</p><h3 id="3-cache-t-cache"><a href="#3-cache-t-cache" class="headerlink" title="3. cache_t cache"></a>3. cache_t cache</h3><p>缓存, 用于缓存已经调用的方法, 可以加速方法的调用, 具体分析我们放的以后。接下来分析一下他的内存占用情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    struct bucket_t *_buckets; &#x2F;&#x2F; 8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    mask_t _mask;  &#x2F;&#x2F; 4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    mask_t _occupied; &#x2F;&#x2F; 4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#x2F;*</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  一堆函数...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">#if __LP64__</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">typedef uint32_t mask_t;  &#x2F;&#x2F; x86_64 &amp; arm64 asm are less efficient with 16-bits</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">typedef uint16_t mask_t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">#ifndef _UINT32_T</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">#define _UINT32_T</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">typedef unsigned int uint32_t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">#endif &#x2F;* _UINT32_T *&#x2F;</span></pre></td></tr></table></figure><p>可以看出, <code>cache_t</code> 结构体包含 一个结构体指针和两个 <code>mask_t</code> 类型的成员变量, 且 <code>mask_t</code> 在 64位情况下位 int 类型。所以 <code>cache</code> 部分总共占用内存为 16 位。</p><h3 id="4-class-data-bits-t-bits"><a href="#4-class-data-bits-t-bits" class="headerlink" title="4. class_data_bits_t bits"></a>4. class_data_bits_t bits</h3><p>可以看出 <code>bits</code> 也是一个结构体类型, 但是当我们去查看 <code>objc_class</code> 里面的函数时, 会发现很多地方都跟 <code>bits</code> 有关。然后我们去查看 <code>bits</code> 的函数实现, 发现了一个有趣的东西, 内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">class_rw_t* data() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    uint32_t flags;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    uint32_t version;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    const class_ro_t *ro;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    method_array_t methods;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    property_array_t properties;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    protocol_array_t protocols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    Class firstSubclass;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    Class nextSiblingClass;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    char *demangledName;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">#if SUPPORT_INDEXED_ISA</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    uint32_t index;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  &#x2F;*</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  ...函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>在 <code>class_data_bits_t</code> 的 <code>data()</code> 函数返回了一个 <code>class_rw_t</code> 类型的指针对象, 然后我们在 <code>class_rw_t</code> 结构体里面发现了一些我们很熟悉的东西 <code>methods</code>、<code>properties</code>、<code>protocols</code> 等。难道我们的类声明的方法、属性等存储在这里面吗, 所以后面我们来一起着重对这个 <code>bits</code> 来进行研究。</p><h2 id="类的结构探究"><a href="#类的结构探究" class="headerlink" title="类的结构探究"></a>类的结构探究</h2><h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h3><p>开始探究之前, 我们先回到我们的 <code>objc</code> 源码里面, 新建一个 <code>target</code> , 新建一个 <code>Person</code> 类, 然后开始我们的探索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    NSString *name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *sex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) NSInteger age;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">+ (void)person_sayHello;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">- (void)person_study;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">@end</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.m</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    @autoreleasepool &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; insert code here...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        Person *person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        Class pClass &#x3D; object_getClass(person);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        NSLog(@&quot;%@&quot;, pClass);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><blockquote><p><strong>类和元类的创建时机</strong></p></blockquote><p>开始之前我们先看一个东西, 在方法执行之前打一个断点, 然后对我们的 <code>Person</code> 类进行打印, 看一下是否存在。</p><p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-1.png" alt="类的结构分析(一)"></p><p>如上图所示, 此时我们的 <code>person</code> 对象还没有被创建, 但是我们对 <code>Person</code> 的类对象进行打印, 发现已经存在在内存当中了。所以在类进行 <code>alloc</code> 操作之前, 类和元类就已经存在了, 说明类和元类在编译时期就已经被创建了。</p><h3 id="2-bits-探索"><a href="#2-bits-探索" class="headerlink" title="2. bits 探索"></a>2. bits 探索</h3><p>想要去探索 <code>bits</code> , 我们首先要解决如何找到他的问题, 然后才能在内存中对其结构进行一一分析。在上面的结构分析中我们知道, <code>objc_class</code> 内部一共包含 <code>isa</code>、<code>superclass</code>、<code>cache</code> 和 <code>bits</code> 组成, 前面的三位总共占 32 位, 那么我们接下来就借助指针平移来找到 <code>bits</code> 。</p><ul><li><strong>找到 bits 的内存地址</strong></li></ul><p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-2.png" alt="类的结构分析(一)"></p><p>!<img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-3.png" alt="类的结构分析(一)"></p><p>通过指针平移后得到新的地址, 然后进行打印验证得出 <code>bits</code> 的指针地址。</p><ul><li><strong>关于 class_rw_t</strong></li></ul><p>找到了 <code>bits</code> , 我们上面提到过, <code>bits</code> 可以通过 <code>data()</code> 函数返回一个 <code>class_rw_t</code> 类型的指针对象。所以为了去查看 <code>class_rw_t</code> 的结构, 我们继续往下面走</p><p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-4.png" alt="类的结构分析(一)"></p><p>上面我们通过 <code>data()</code> 函数得到了 <code>class_rw_t</code> 类型的指针, 然后又通过打印发现, 果然是我们想要找的内容, 在里面也发现了我们想要寻找的 <code>methods</code> 、<code>properties</code> 和 <code>protocols</code>  。接下来一起看看我们的 属性 和 方法是否在这里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 关于指针前面的 &quot; * &quot; 符号</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对于指针而言, 星号一般出现的场合, 一个是指针定义时, 另一个是使用指针时。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">1. int *p</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">指针定义时前面的星号, 目的是告诉编译器变量 p 是一个指针</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">2. *p + 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">使用指针时, 可以理解为 指针的值, 比如上面这里就是 指针指向的值 加上 1 。</span></pre></td></tr></table></figure><p><strong>1. properties 分析</strong></p><p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-5.png" alt="类的结构分析(一)"></p><p>首先我们直接打印 <code>properties</code> , 发现内部存储的是一个 <code>list_array_tt</code> 类型的东西, 然后打印他的 <code>list</code>, 发现他是一个 <code>property_list_t</code> 类型的指针, 进行值打印, 又出来一个 <code>entsize_list_tt</code> , 下面是 <code>entsize_list_tt</code> 的声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 泛型</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">template &lt;typename Element, typename List, uint32_t FlagMask&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; entsize_list_tt 的声明</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">struct entsize_list_tt &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    uint32_t entsizeAndFlags;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    uint32_t count;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    Element first;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    uint32_t entsize() const &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        return entsizeAndFlags &amp; ~FlagMask;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    uint32_t flags() const &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        return entsizeAndFlags &amp; FlagMask;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    Element&amp; getOrEnd(uint32_t i) const &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        assert(i &lt;&#x3D; count);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        return *(Element *)((uint8_t *)&amp;first + i*entsize()); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    Element&amp; get(uint32_t i) const &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        assert(i &lt; count);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        return getOrEnd(i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    size_t byteSize() const &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        return byteSize(entsize(), count);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  &#x2F;*</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">  一些函数...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>如上, 关于 <code>template</code> 好像是 <code>C++</code> 里面的东西, 用来做泛型编程的, 有兴趣的可以去查询一下。关于 <code>entsizeAndFlags</code> 和 <code>count</code> 可以直接打印出来, 重要的是 <code>first</code> , 然后发现有两个函数 <code>getOrEnd() 和 get()</code> , 尝试调用之后发现真的可以得到与我们的属性相关的东西。<strong>但是, 没有找到我们的成员变量。</strong></p><p><strong>2. methods</strong></p><p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-6.png" alt="类的结构分析(一)"></p><p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-7.png" alt="类的结构分析(一)"></p><p>打印结果如上图, 过程跟 第1步的 <code>properties</code> 一样, 这里不做描述了。可以看到我们定义的 实例方法 和 属性的 <code>getter,setter</code> 方法都可以找到, 除此之外还有一个 <code>C++</code> 的析构函数 <code>.cxx_destruct</code> 。<strong>但是, 我们的类方法没有在里面</strong></p><p><strong>3. 关于 ro</strong></p><p>为了寻找我们的 <code>类方法</code> 和 <code>成员变量</code> , 我们继续对 <code>class_rw_t</code> 的结构进行查看, 发现最有可能在的地方只有可能是 <code>ro</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ro </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    uint32_t flags;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    uint32_t instanceStart;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    uint32_t instanceSize;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">#ifdef __LP64__</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    uint32_t reserved;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    const uint8_t * ivarLayout;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    const char * name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    method_list_t * baseMethodList;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    protocol_list_t * baseProtocols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    const ivar_list_t * ivars;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    const uint8_t * weakIvarLayout;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    property_list_t *baseProperties;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    method_list_t *baseMethods() const &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        return baseMethodList;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><p>在其内部我们同样发现了关于方法和属性的东西 <code>baseMethodList</code>、<code>baseProperties</code> , 还有一个新的东西 <code>ivars</code> , 接下来我们来打印一下里面到底有什么吧 (过程省略, 直接上图):</p><p><img src="/images/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84-8.png" alt="类的结构分析(一)"></p><p>从打印结果可以看出, 不只是我们声明的成员变量, 属性自动生成的带 “_” 的成员变量也在其中, 所以成员变量存在于 <code>ro</code> 下面的 <code>ivars</code> 中。</p><p><strong>注意: 此处省略了对 <code>baseMethodList</code> 和 <code>baseProperties</code> 的打印, 有兴趣的可以去自己试一下, 你会发现这里同样存储着我们所定义的 实例方法 和 属性, 至于为什么我们留到以后解答。</strong></p><p> <strong>4. 总结</strong></p><p>经过上面的探索, 我们发现在 <code>class_rw_t</code> 里面可以找到我们在类中定义的 <strong>属性</strong> 和 <strong>实例方法</strong> , 但是无法找到 <strong>成员变量</strong>。<br>然后在 <code>ro</code> 里面可以找到我们的 <strong>成员变量</strong>, 同样也可以找到我们的 <strong>属性</strong> 和 <strong>实例方法</strong>。那么为什么这里他们两个都会存储 <strong>属性</strong> 和 <strong>实例方法</strong>, 这些我们放到下一期来讨论。 <a href>正在补作业中…敬请期待…</a></p><h3 id="3-类方法的存储位置"><a href="#3-类方法的存储位置" class="headerlink" title="3. 类方法的存储位置"></a>3. 类方法的存储位置</h3><p>前面我们一起找到了 <strong>属性</strong> 、<strong>实例方法</strong> 和 <strong>成员变量</strong> , 那么 <strong>类方法</strong> 到底存储在哪里呢? 接下来我们借助 <code>runtime</code> 的 API 来一起测试一下。</p><h4 id="1-作为实例方法"><a href="#1-作为实例方法" class="headerlink" title="1. 作为实例方法"></a>1. 作为实例方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; + (void)person_sayHello;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; - (void)person_study;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const char *className &#x3D; object_getClassName(pClass);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Class metaClass &#x3D; objc_getMetaClass(className);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Method method1 &#x3D; class_getInstanceMethod(pClass, @selector(person_sayHello));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Method method2 &#x3D; class_getInstanceMethod(metaClass, @selector(person_sayHello));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">Method method3 &#x3D; class_getInstanceMethod(pClass, @selector(person_study));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">Method method4 &#x3D; class_getInstanceMethod(metaClass, @selector(person_study));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%p-%p-%p-%p&quot;,method1,method2,method3,method4);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">打印结果:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">0x0-0x100001108-0x100001170-0x0</span></pre></td></tr></table></figure><p>根据上面打印结果可以总结如下:</p><ul><li><code>person_sayHello</code> 是 <strong>元类对象</strong>的实例方法, 所以存在于<strong>元类</strong>当中, 不存在<strong>类</strong></li><li><code>person_study</code> 是<strong>类对象</strong>的实例方法, 所以存在于<strong>类</strong>当中, 不存在<strong>元类</strong></li></ul><h4 id="2-作为类方法"><a href="#2-作为类方法" class="headerlink" title="2. 作为类方法"></a>2. 作为类方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; + (void)person_sayHello;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; - (void)person_study;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const char *className &#x3D; object_getClassName(pClass);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Class metaClass &#x3D; objc_getMetaClass(className);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Method method1 &#x3D; class_getClassMethod(pClass, @selector(person_sayHello));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Method method2 &#x3D; class_getClassMethod(metaClass, @selector(person_sayHello));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">Method method3 &#x3D; class_getClassMethod(pClass, @selector(person_study));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">Method method4 &#x3D; class_getClassMethod(metaClass, @selector(person_study));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%p-%p-%p-%p&quot;,method1,method2,method3,method4);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">打印结果:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">0x100001108-0x100001108-0x0-0x0</span></pre></td></tr></table></figure><p>根据结果可以看出, 不管是类还是元类, 作为类方法去查找 <code>person_study</code> 方法时都无法获取到, 而去查找 <code>person_sayHello</code> 方法时又都找到了, 这里就有问题了, 那么我们进入到 <code>class_getClassMethod</code> 方法内部实现里去找一下答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Method class_getClassMethod(Class cls, SEL sel) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    if (!cls  ||  !sel) return nil;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    return class_getInstanceMethod(cls-&gt;getMeta(), sel);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Class getMeta() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  if (isMetaClass()) return (Class)this;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  else return this-&gt;ISA();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">inline Class </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">objc_object::ISA() </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    assert(!isTaggedPointer()); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">#if SUPPORT_INDEXED_ISA</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    if (isa.nonpointer) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        uintptr_t slot &#x3D; isa.indexcls;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        return classForIndex((unsigned)slot);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    return (Class)isa.bits;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    return (Class)(isa.bits &amp; ISA_MASK);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可以看到 <code>class_getClassMethod</code> 方法的内部其实也是在调用 <code>class_getInstanceMethod</code> 方法, 不同点在于 <code>getMeta()</code> 方法, 可以看到如果是<strong>元类</strong>调用会直接返回; 如果是<strong>类</strong>调用的话, 会返回 <code>ISA()</code> , 也就是<strong>元类</strong>, 所以不管是在<strong>类</strong>中查找 <code>person_sayHello</code> 方法, 还是在<strong>元类</strong>中查找, 其结果是一样的。</p><blockquote><p><strong>所以, 我们的类方法是存储在元类中的, 实例方法是存储在类中的</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次探索对类进行了一系列的研究, 总结如下:</p><ol><li>我们发现类其实也是一个对象, 并且类和元类是在编译时就创建的。</li><li>对类的结构进行了分析, 并且在 <code>class_rw_t</code> 和 <code>ro</code> 里面找到了我们的 <code>属性</code> 和 <code>实例方法</code>, 仅在 <code>ro</code> 中找到了我们的 <code>成员变量</code>。</li><li>然后后面又对 <code>类方法</code> 的存储位置进行了探索, 发现类方法是存在元类中的。</li></ol><p>最后希望本次的探索对你有所启发, 如果有不对的地方还请各位指出, 谢谢大家。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 在前面的几篇文章对 &lt;code&gt;iOS&lt;/code&gt; 对象的原理进行了探索, 那么类在底层的实现又是什么样子的呢? 类是以什么样的形式存在的? 他的结构又是什么样子的呢? 接下来我们一起来展开对类的一些相关内容探索, 看一下他的真面目。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="iOS底层学习" scheme="https://yoursite.com/categories/iOS%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS探索" scheme="https://yoursite.com/tags/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>iOS探索之--isa 的初始化和指向分析</title>
    <link href="https://yoursite.com/2020-03-12-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--isa%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%8C%87%E5%90%91%E5%88%86%E6%9E%90/"/>
    <id>https://yoursite.com/2020-03-12-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--isa%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%8C%87%E5%90%91%E5%88%86%E6%9E%90/</id>
    <published>2020-03-11T16:00:00.000Z</published>
    <updated>2020-03-12T03:36:54.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的研究中我们大概知道了对象创建和分配内存的过程, 但是在这中间有一个东西还没有去注意。那就是对象的 <code>isa</code> 属性, 我们只是知道在过程中有伴随着它的一系列初始化操作, 但是这个过程中为什么要创建 <code>isa</code> 呢 ? 这就是此次我们要研究的目的。</p><h2 id="isa-的初始化-和-结构分析"><a href="#isa-的初始化-和-结构分析" class="headerlink" title="isa 的初始化 和 结构分析"></a>isa 的初始化 和 结构分析</h2><h3 id="1-isa-初始化"><a href="#1-isa-初始化" class="headerlink" title="1. isa 初始化"></a>1. isa 初始化</h3><p>在之前的 <a href="https://juejin.im/post/5e0220c3f265da339f7d025f" target="_blank" rel="noopener">alloc流程分析</a> 中我们从 <code>objc</code> 源码中看到过对 <code>isa</code> 的初始化过程, 下面我们回过去重新看一下当时的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; callAlloc 方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">obj-&gt;initInstanceIsa(cls, dtor);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">inline void </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    assert(!cls-&gt;instancesRequireRawIsa());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    assert(hasCxxDtor &#x3D;&#x3D; cls-&gt;hasCxxDtor());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    initIsa(cls, true, hasCxxDtor);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化具体实现</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">inline void </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    assert(!isTaggedPointer()); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    if (!nonpointer) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        isa.cls &#x3D; cls;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        assert(!DisableNonpointerIsa);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        assert(!cls-&gt;instancesRequireRawIsa());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        isa_t newisa(0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">#if SUPPORT_INDEXED_ISA</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        assert(cls-&gt;classArrayIndex() &gt; 0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        newisa.bits &#x3D; ISA_INDEX_MAGIC_VALUE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        newisa.indexcls &#x3D; (uintptr_t)cls-&gt;classArrayIndex();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        newisa.bits &#x3D; ISA_MAGIC_VALUE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        newisa.shiftcls &#x3D; (uintptr_t)cls &gt;&gt; 3;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; This write must be performed in a single store in some cases</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; (for example when realizing a class because other threads</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; may simultaneously try to use the class).</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; fixme use atomics here to guarantee single-store and to</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; guarantee memory order w.r.t. the class index table</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; ...but not too atomic because we don&#39;t want to hurt instantiation</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        isa &#x3D; newisa;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>从对象创建过程中方法的调用我们不难发现, <code>nonpointer</code> 被默认传的 <code>true</code> 。然后下面的一些判断操作可以理解为对 <code>isa</code> 的一系列的赋值操作。还有重要的一点, 我们可以看到 <code>isa</code> 的类型为 <code>isa_t</code> 类型, 下面我们来看一看这个类型到底是什么。</p><blockquote><p><strong>补充: 关于Tagged Pointer</strong></p><p>我们可以在 WWDC2013 的《Session 404 Advanced in Objective-C》视频中，看到苹果对于Tagged Pointer特点的介绍：</p><ol><li>Tagged Pointer 专门用来存储小的对象，例如 NSNumber, NSDate, NSString。</li><li>Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free 。</li><li>在内存读取上有着 3 倍的效率，创建时比以前快 106 倍。</li></ol><p>有兴趣的可以去看看这两篇文章 <a href="https://www.jianshu.com/p/e354f9137ba8" target="_blank" rel="noopener">iOS Tagged Pointer</a> , <a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/" target="_blank" rel="noopener">深入理解 Tagged Pointer</a> 。</p></blockquote><h3 id="2-isa-的结构分析"><a href="#2-isa-的结构分析" class="headerlink" title="2. isa 的结构分析"></a>2. isa 的结构分析</h3><p>在分析结构之前, 我们首先了解两个概念, <code>联合体</code> 和 <code>位域</code>。</p><ol><li>联合体 (<code>union</code>)</li></ol><p>在进行某些算法的C语言编程的时候，需要使几种不同类型的变量存放到同一段<a href="https://baike.baidu.com/item/内存单元/7914266" target="_blank" rel="noopener">内存单元</a>中。也就是使用覆盖技术，几个变量互相覆盖。这种几个不同的变量共同占用一段内存的结构，在C语言中，被称作“<a href="https://baike.baidu.com/item/共用体/3874970" target="_blank" rel="noopener">共用体</a>”类型结构，简称共用体，也叫联合体。<a href="https://baike.baidu.com/item/联合体" target="_blank" rel="noopener">(出自百度百科联合体)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1. 联合体是一个结构</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2. 它的所有成员相对于首地址的偏移量都为 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">3. 长度取决于各成员中最长的长度</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">4. 各变量是“互斥”的——共用一个内存首地址，联合变量可被赋予任一成员值,但每次只能赋一种值, 赋入新值则冲去旧值</span></pre></td></tr></table></figure><ol start="2"><li>位域</li></ol><p>位域是指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。 (选自:<a href="https://baike.baidu.com/item/位段?fromtitle=位域&fromid=9215688" target="_blank" rel="noopener">百度百科</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 联合体</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    isa_t() &#123; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    Class cls;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    uintptr_t bits;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">#if defined(ISA_BITFIELD)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    struct &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        ISA_BITFIELD;  &#x2F;&#x2F; defined in isa.h  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  ISA_BITFIELD 的定义</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  位域</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"># if __arm64__</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">#   define ISA_BITFIELD                                                      \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">      uintptr_t nonpointer        : 1;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      uintptr_t has_assoc         : 1;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      uintptr_t has_cxx_dtor      : 1;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">      uintptr_t shiftcls          : 33; &#x2F;*MACH_VM_MAX_ADDRESS 0x1000000000*&#x2F; \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">      uintptr_t magic             : 6;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">      uintptr_t weakly_referenced : 1;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      uintptr_t deallocating      : 1;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">      uintptr_t has_sidetable_rc  : 1;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">      uintptr_t extra_rc          : 19</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">#   define RC_ONE   (1ULL&lt;&lt;45)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">#   define RC_HALF  (1ULL&lt;&lt;18)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"># elif __x86_64__</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">#   define ISA_BITFIELD                                                      \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">      uintptr_t nonpointer        : 1;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">      uintptr_t has_assoc         : 1;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">      uintptr_t has_cxx_dtor      : 1;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">      uintptr_t shiftcls          : 44; &#x2F;*MACH_VM_MAX_ADDRESS 0x7fffffe00000*&#x2F; \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">      uintptr_t magic             : 6;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">      uintptr_t weakly_referenced : 1;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">      uintptr_t deallocating      : 1;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">      uintptr_t has_sidetable_rc  : 1;                                       \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">      uintptr_t extra_rc          : 8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">#   define RC_ONE   (1ULL&lt;&lt;56)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">#   define RC_HALF  (1ULL&lt;&lt;7)</span></pre></td></tr></table></figure><p>可以发现, <code>isa_t</code> 就是一个 <code>联合体</code> 类型, 至于 <code>ISA_BITFIELD</code> 从后面的宏定义可以看出是一个 <code>位域</code>, 所以 <code>isa</code> 的实际类型是一个 <code>联合体</code>, 并且在联合体内部包含一个 <code>位域</code>, 用来存储不同的信息。</p><p>下面我们来展开分析一下:</p><ol><li><p>首先是两个构造函数 <code>isa_t(), isa_t(unitptr_value)</code> 。</p></li><li><p>然后是三个数据成员 <code>Class cls</code>, <code>unitptr_t bits</code>, <code>struct</code> 。其中 <code>unitptr_t</code> 被定义为 <code>typedef unsigned long uintptr_t</code> , 占64位。 </p><p>关于 <code>uintptr_t bits</code> 和 <code>struct</code> , 这两个其实可以看出一个成员, 首先他们都占据 64 位内存空间, 并且联合里面的空间是重叠的, 所以他们两个的内存空间是完全重叠的。即 <code>uintptr_t bits</code> 和 <code>struct</code> 是一个东西的两种表现形式。</p><p>实际上在 <code>runtime</code> 中，任何对 <code>struct</code>  的操作和获取某些值，如 <code>extra_rc</code>，实际上都是通过对 <code>uintptr_t bits</code>  做位操作实现的。<code>uintptr_t bits</code> 和 <code>struct</code> 的关系可以看做，<code>uintptr_t bits</code> 向外提供了操作 <code>struct</code>  的接口，而 <code>struct</code> 本身则说明了 <code>uintptr_t bits</code>  中各个二进制位的定义。</p><p>所以 <code>isa_t</code> 其实可以看做有两个可能的值, <code>Class cls</code> 或者 <code>struct</code> 。</p><p><a href="https://blog.csdn.net/u013378438/article/details/80733391" target="_blank" rel="noopener">内容出处:(Objective-C runtime机制(5)——iOS 内存管理)</a></p></li><li><p>当作为 <code>Class cls</code> 使用时, 就符合了我们一惯的认知, <code>isa</code> 是一个指向对象所属类的指针。但是一个 64位 的指针很显然不划算。所以大多数情况下苹果采用的是优化的 <code>isa</code> 策略, 即 <code>struct</code> 。</p></li><li><p>下面来看一下 <code>struct</code> 里面各个成员所起到的作用</p></li></ol><table><thead><tr><th align="center">成员</th><th align="center">位</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">nonpointer</td><td align="center">1bit</td><td align="left">表示是否对 <strong>isa</strong> 指针开启指针优化 <strong>0</strong>:纯<strong>isa</strong>指针，<strong>1</strong>:不止是类对象地址<strong>,isa</strong> 中包含了类信息、对象的引用计数等</td></tr><tr><td align="center">has_assoc</td><td align="center">1bit</td><td align="left">关联对象标志位，<strong>0</strong>没有，<strong>1</strong>存在</td></tr><tr><td align="center">has_cxx_dtor</td><td align="center">1bit</td><td align="left">该对象是否有 <strong>C++</strong> 或者 <strong>Objc</strong> 的析构器<strong>,</strong>如果有析构函数<strong>,</strong>则需要做析构逻辑<strong>,</strong> 如果没有<strong>,</strong>则可以更快的释放对象</td></tr><tr><td align="center">shiftcls</td><td align="center">33bit</td><td align="left">存储类指针的值。开启指针优化的情况下，在 <strong>arm64</strong> 架构中有 <strong>33</strong> 位用来存储类指针。</td></tr><tr><td align="center">magic</td><td align="center">6bit</td><td align="left">固定为  0x1a, 用于调试器判断当前对象是真的对象还是没有初始化的空间</td></tr><tr><td align="center">weakly_referenced</td><td align="center">1bit</td><td align="left">指对象是否被指向或者曾经指向一个 <strong>ARC</strong> 的弱变量, 没有弱引用的对象可以更快释放。</td></tr><tr><td align="center">deallocating</td><td align="center">1bit</td><td align="left">标志对象是否正在释放内存</td></tr><tr><td align="center">has_sidetable_rc</td><td align="center">1bit</td><td align="left">当对象引用计数大于 <strong>19</strong> 位时，则需要借用该变量存储进位</td></tr><tr><td align="center">extra_rc</td><td align="center">19bit</td><td align="left">当表示该对象的引用计数值，实际上是引用计数值减 <strong>1</strong>， 例如，如果对象的引用计数为 10，那么 <strong>extra_rc</strong> 为 9。如果引用计数大于 <strong>19</strong> 位， 则需要使用到上面的 <strong>has_sidetable_rc</strong>。</td></tr></tbody></table><p>以上就是对 <code>isa</code> 结构的分析, 具体的 <code>struct</code> 内部成员分析可以去看一下上面分享的链接。</p><h2 id="isa-的指向分析"><a href="#isa-的指向分析" class="headerlink" title="isa 的指向分析"></a>isa 的指向分析</h2><h3 id="1-class-objc-getClass-与-object-getclass-的区别"><a href="#1-class-objc-getClass-与-object-getclass-的区别" class="headerlink" title="1. class , objc_getClass () 与 object_getclass () 的区别 ?"></a>1. class , objc_getClass () 与 object_getclass () 的区别 ?</h3><p>开始分析 <code>isa</code> 指向之前, 我们首先了解一下上面这三个方法的区别是什么, 下面我们从 <code>objc</code> 源码里直接找到了上面方法的实现 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; class ()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">+ (Class)class &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    return self;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">- (Class)class &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    return object_getClass(self);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_getClass ()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">* objc_getClass.  Return the id of the named class.  If the class does</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">* not exist, call _objc_classLoader and then objc_classHandler, either of </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">* which may create a new class.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">* Warning: doesn&#39;t work if aClassName is the name of a posed-for class&#39;s isa!</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">**********************************************************************&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">Class objc_getClass(const char *aClassName)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    if (!aClassName) return Nil;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; NO unconnected, YES class handler</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    return look_up_class(aClassName, NO, YES);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; object_getclass () </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">Class object_getClass(id obj)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    if (obj) return obj-&gt;getIsa();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    else return Nil;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">inline Class </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">objc_object::getIsa() </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    if (!isTaggedPointer()) return ISA();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    uintptr_t ptr &#x3D; (uintptr_t)this;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    if (isExtTaggedPointer()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        uintptr_t slot &#x3D; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            (ptr &gt;&gt; _OBJC_TAG_EXT_SLOT_SHIFT) &amp; _OBJC_TAG_EXT_SLOT_MASK;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        return objc_tag_ext_classes[slot];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        uintptr_t slot &#x3D; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">            (ptr &gt;&gt; _OBJC_TAG_SLOT_SHIFT) &amp; _OBJC_TAG_SLOT_MASK;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        return objc_tag_classes[slot];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">inline Class </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">objc_object::ISA() </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    assert(!isTaggedPointer()); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">#if SUPPORT_INDEXED_ISA</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    if (isa.nonpointer) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        uintptr_t slot &#x3D; isa.indexcls;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        return classForIndex((unsigned)slot);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    return (Class)isa.bits;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; ISA_MASK 掩码, 通过 &amp; 运算来获取到 isa 的指向信息</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; #   define ISA_MASK        0x00007ffffffffff8ULL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    return (Class)(isa.bits &amp; ISA_MASK); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>从以上的源码实现我们可以总结如下:</p><ol><li>class 方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 当为实例方法时, 其返回与 object_getClass () 一致, 即当前对象的 isa 指向的类对象</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2. 当为类方法时, 返回该类对象本身</span></pre></td></tr></table></figure><ol start="2"><li>objc_getClass ( ) 方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 该方法的参数是一个字符串, 当我们传进去一个类名的字符串, 就会返回这个类的类对象</span></pre></td></tr></table></figure><ol start="3"><li>object_getclass ( ) 方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据传入的参数获取 isa 指向, 需要说明的一点在于</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当传入的是一个实例对象时, 获取到的是 类对象; 当传入的是一个类对象时, 获取到的是 元类</span></pre></td></tr></table></figure><h3 id="2-isa-指向分析"><a href="#2-isa-指向分析" class="headerlink" title="2. isa 指向分析"></a>2. isa 指向分析</h3><p>首先放上来自官方的指向图:</p><p><img src="/images/isa-1.png" alt="isa 的指向流程"></p><p>从标注可以看出, <code>实线箭头表示继承关系, 虚线箭头表示 isa 指向关系</code> , 然后从上图我们可以得出 <code>isa</code> 的指向顺序依次为: <strong>对象 –&gt; 类 –&gt; 元类 –&gt; 根元类 –&gt; 根元类</strong> 。下面我们来一起验证一下这个过程 (注: 此过程需要用到 lldb 相关打印命令, 有兴趣的可以去自己查询一下。) :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义两个类</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 父类 : YJPerson</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 子类 : YJTeacher</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; YJPerson类</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    Class class &#x3D; object_getClass(person);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; YJPerson元类</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    Class metaClass &#x3D; object_getClass(class);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; YJPerson根元类</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    Class rootMetaClass &#x3D; object_getClass(metaClass);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; YJPerson根根元类</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    Class rootRootMetaClass &#x3D; object_getClass(rootMetaClass);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;\n%p 实例对象 %@\n%p 类 %@\n%p 元类 %@\n%p 根元类 %@\n%p 根根元类 %@&quot;,person,person,class,class,metaClass,metaClass,rootMetaClass,rootMetaClass,rootRootMetaClass,rootRootMetaClass);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意: 模拟器情况下是不会对 isa 进行优化的, 所以我们这里选择真机调试</span></pre></td></tr></table></figure><p>说明: 通过上面的 object_getclass ( ) 方法的内部实现, 我们可以了解到 可以直接通过 <code>isa &amp; ISA_MASK(掩码)</code> 来获取所指向的类, 所以我们下面的验证是通过采用这种方式进行的。 </p><p><img src="/images/isa-2.png" alt="isa 指向验证"></p><ol><li>首先通过上面介绍的方法一次获取到 <code>person</code> 对象的 类, 元类, 根元类和根根元类并将结果打印出来</li><li>然后通过 <code>lldb</code> 命令去读取 <code>person</code> 对象的内存情况, 我们知道内存中前 <code>8</code> 位存储的就是我们的 <code>isa</code>, 所以通过 <code>isa &amp; ISA_MASK</code> 方式来获取到 <code>isa</code> 指向的地址并将其打印</li><li>最后得出的结果如上图所示, 通过内存读取的结果与第1步打印的结果完全一致</li><li>还有最重要的一点, 可以发现我们的 <code>根元类</code> 与 <code>根根元类</code> 的地址其实是完全一样的, 然后查看流程图右上角的箭头指向得出结论: <strong>根元类以后的 isa 都是指向根元类本身</strong> 。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过此篇文章, 主要研究了 <code>isa</code> 相关的一些内容, 包括 <code>isa</code> 的结构组成和指向关系等, 期间也包含了一些内容的补充, 比如: Tagged Pointer、联合体、位域等。这次文章的内容到这里就结束了, 希望内容能对你有所帮助和启发, 如有不对的地方也请大佬们指正, 我们一起探讨共同进步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在之前的研究中我们大概知道了对象创建和分配内存的过程, 但是在这中间有一个东西还没有去注意。那就是对象的 &lt;code&gt;isa&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="iOS底层学习" scheme="https://yoursite.com/categories/iOS%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS探索" scheme="https://yoursite.com/tags/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>iOS探索之--内存对齐原理分析</title>
    <link href="https://yoursite.com/2020-02-19-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://yoursite.com/2020-02-19-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2020-02-18T16:00:00.000Z</published>
    <updated>2020-03-12T03:38:03.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在探索 <a href="https://juejin.im/post/5e0220c3f265da339f7d025f#heading-7" target="_blank" rel="noopener">alloc流程</a> 的时候有关<code>内存对齐</code> 方面的内容没有去详细分析, 接下来在本文中着重对内存对齐方面的内容进行补充和继续探索。</p><h2 id="内存对齐的概念"><a href="#内存对齐的概念" class="headerlink" title="内存对齐的概念"></a>内存对齐的概念</h2><blockquote><p>首先我们要搞清楚什么是内存对齐 ?</p></blockquote><p><code>内存对齐 (Memory alignment)</code> , 也叫做字节对齐。计算机中的内存空间都是按照 byte 划分的, 从理论上讲对任何类型的变量的访问可以从任何地址开始, 但是实际情况下在访问特定类型变量的时候经常在特定的内存地址访问, 这就需要各类型数据按照一定的规则在空间上排列, 而不是按顺序的一个一个排放, 这就是内存对齐。<a href="https://baike.baidu.com/item/对齐" target="_blank" rel="noopener">参考自百度百科</a></p><blockquote><p>为什么要进行内存对齐 ?</p></blockquote><p>为了减少CPU访问内存的次数, 提高计算机性能, 一些计算机硬件平台要求存储在内存中的变量需要按照自然边界对齐。</p><ol><li>性能提升</li></ol><p>从内存占用的角度讲, 对齐以后比未对齐时有些情况反而增加了内存分配的开支, 是为了什么?</p><p>数据结构 (尤其是栈) 应该尽可能地在自然边界上对齐, 为了访问未对齐的内存, 处理器就需要做两次内存访问, 而对齐的内存访问只需要一次访问。重要的是提高内存系统的性能。</p><ol start="2"><li>跨平台</li></ol><p>有些硬件平台并不能访问任意地址上的任意数据的，只能处理特定类型的数据，否则会导致硬件层级的错误。</p><p>有些CPU（如基于 Alpha，IA-64，MIPS，和 SuperH 体系的）拒绝读取未对齐数据。当一个程序要求这些 CPU 读取未对齐数据时，这时 CPU 会进入异常处理状态并且通知程序不能继续执行。</p><p>举个例子，在 ARM，MIPS，和 SH 硬件平台上，当操作系统被要求存取一个未对齐数据时会默认给应用程序抛出硬件异常。所以，如果编译器不进行内存对齐，那在很多平台的上的开发将难以进行。</p><h2 id="获取对象内存大小的方法"><a href="#获取对象内存大小的方法" class="headerlink" title="获取对象内存大小的方法"></a>获取对象内存大小的方法</h2><p>在研究内存对齐之前, 首先我们需要了解一下下面这三个方法的具体作用:</p><ul><li><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3></li></ul><p>他是一个操作符, 不是函数, 作用对象是数据类型, 主要作用于编译时。因此, 它作用于变量时, 同样是对其类型进行操作, 得到的结果是该数据类型占用空间的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">struct test</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  int a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  double b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125; MyTest;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%zd&quot;, sizeof(MyTest));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 上面的结果得到 16, 需要考虑内存对齐问题, 关于内存对齐规则后面提到</span></pre></td></tr></table></figure><p>sizeof 只会计算类型所占用的内存大小, 不会关心具体的内存布局。(例如, 64位结构下, 我们自定义一个 NSObject 对象, 里面无论有多少个成员变量, 最后的结果都是 8)</p><ul><li><h3 id="class-getInstanceSize"><a href="#class-getInstanceSize" class="headerlink" title="class_getInstanceSize"></a>class_getInstanceSize</h3></li></ul><p>这是 <code>runtime</code> 提供的一个API, 用于获取类的实例对象所占用的内存大小, 返回具体的字节数。</p><p>我们通过在之前获取到的 objc4 源码中搜索该方法, 在 objc-class.mm 中找到了该方法的实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">size_t class_getInstanceSize(Class cls)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    if (!cls) return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    return cls-&gt;alignedInstanceSize();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Class&#39;s ivar size rounded up to a pointer-size boundary.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">uint32_t alignedInstanceSize() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  return word_align(unalignedInstanceSize());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  return (x + WORD_MASK) &amp; ~WORD_MASK;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">#define WORD_MASK 7UL</span></pre></td></tr></table></figure><p>可以看出, 该方法会返回实例对象中成员变量的内存大小, 所以, <code>class_getInstanceSize</code> 就是获取实例对象中成员变量的内存大小。</p><ul><li><h3 id="malloc-size"><a href="#malloc-size" class="headerlink" title="malloc_size"></a>malloc_size</h3></li></ul><p>这个函数主要获取系统实际分配的内存大小, 具体的实现可以在libmalloc源码中找到。代码如下, 这里不做分析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">size_t malloc_size(const void *ptr)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">size_t size &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">if (!ptr) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">return size;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">(void)find_registered_zone(ptr, &amp;size);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">return size;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">static inline malloc_zone_t *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">find_registered_zone(const void *ptr, size_t *returned_size)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Returns a zone which contains ptr, else NULL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">if (0 &#x3D;&#x3D; malloc_num_zones) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">if (returned_size) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">*returned_size &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">return NULL;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; first look in the lite zone</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">if (lite_zone) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">malloc_zone_t *zone &#x3D; lite_zone;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">size_t size &#x3D; zone-&gt;size(zone, ptr);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">if (size) &#123; &#x2F;&#x2F; Claimed by this zone?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">if (returned_size) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">*returned_size &#x3D; size;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Return the virtual default zone instead of the lite zone - see &lt;rdar:&#x2F;&#x2F;problem&#x2F;24994311&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">return default_zone;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The default zone is registered in malloc_zones[0]. There&#39;s no danger that it will ever be unregistered.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; So don&#39;t advance the FRZ counter yet.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">malloc_zone_t *zone &#x3D; malloc_zones[0];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">size_t size &#x3D; zone-&gt;size(zone, ptr);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">if (size) &#123; &#x2F;&#x2F; Claimed by this zone?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">if (returned_size) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">*returned_size &#x3D; size;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Asan and others replace the zone at position 0 with their own zone.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; In that case just return that zone as they need this information.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Otherwise return the virtual default zone, not the actual zone in position 0.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">if (!has_default_zone0()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">return zone;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">&#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">return default_zone;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">int32_t volatile *pFRZCounter &#x3D; pFRZCounterLive;   &#x2F;&#x2F; Capture pointer to the counter of the moment</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">OSAtomicIncrement32Barrier(pFRZCounter); &#x2F;&#x2F; Advance this counter -- our thread is in FRZ</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">unsigned index;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">int32_t limit &#x3D; *(int32_t volatile *)&amp;malloc_num_zones;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">malloc_zone_t **zones &#x3D; &amp;malloc_zones[1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; From this point on, FRZ is accessing the malloc_zones[] array without locking</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; in order to avoid contention on common operations (such as non-default-zone free()).</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; In order to ensure that this is actually safe to do, register&#x2F;unregister take care</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; to:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;   1. Register ensures that newly inserted pointers in malloc_zones[] are visible</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;      when malloc_num_zones is incremented. At the moment, we&#39;re relying on that store</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;      ordering to work without taking additional steps here to ensure load memory</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;      ordering.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;   2. Unregister waits for all readers in FRZ to complete their iteration before it</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;      returns from the unregister call (during which, even unregistered zone pointers</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;      are still valid). It also ensures that all the pointers in the zones array are</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;      valid until it returns, so that a stale value in limit is not dangerous.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">for (index &#x3D; 1; index &lt; limit; ++index, ++zones) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">zone &#x3D; *zones;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">size &#x3D; zone-&gt;size(zone, ptr);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">if (size) &#123; &#x2F;&#x2F; Claimed by this zone?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">goto out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Unclaimed by any zone.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">zone &#x3D; NULL;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">size &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">out:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">if (returned_size) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">*returned_size &#x3D; size;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">OSAtomicDecrement32Barrier(pFRZCounter); &#x2F;&#x2F; our thread is leaving FRZ</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">return zone;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="内存对齐的原则"><a href="#内存对齐的原则" class="headerlink" title="内存对齐的原则"></a>内存对齐的原则</h2><ul><li><h3 id="数据成员对齐规则"><a href="#数据成员对齐规则" class="headerlink" title="数据成员对齐规则"></a>数据成员对齐规则</h3><p>结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始 (比如int在32位机为４字节,则要从４的整数倍地址开始存储。)  举例如下: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">struct MyStruct &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    int a;&#x2F;&#x2F; 0-3  补位 4,5,6,7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    double b;&#x2F;&#x2F; 8-15</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    char c;&#x2F;&#x2F; 16部位 17,18,19</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    short d;&#x2F;&#x2F; 20-24</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125; struct1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%lu&quot;,sizeof(struct1));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">2020-02-18 20:41:12.974406+0800 LGTest[36584:2131553] 24</span></pre></td></tr></table></figure><p><em>注意: 测试环境均为 64位 环境, 32位环境下感兴趣的同学可以自行测试。</em></p><p>分析上面的结果, 首先 <code>a</code> 为 int 类型占4位, 所以 <code>a</code> 所在的区域为0-3位。接下来的 <code>b</code> 为 double 类型占8位, 因为内存对齐原则起始位置应该为8的整数倍, 所以起始位置应该为8, 前面的4位补齐。然后 <code>c</code> 的起始位置就是16, 因为 <code>c</code> 只需要1位, 那么 <code>d</code> 的起始位置就是17, 17如果需要是 4 的倍数需要变成 20, 所以前面补齐3位, <code>d</code> 的起始位置为20, 20加上 <code>d</code> 的4位就得出最终的结果24。</p><p>还可以用下面的方式去理解:</p><blockquote><p>我们把内存对齐原则理解为 <code>min(m, n)</code> 的公式, 其中 m表示当前成员的开始位置, n表示当前成员所需要的位数。如果满足条件 m 整除 n 的话, 就让 n 从 m 位置开始存储, 否则继续检查 m+1 能否整除 n, 直到可以整除, 从而就确定了当前成员的开始位置。</p><p>上面结构体中的 <code>b</code> 就可以看做, <code>min(4, 8)</code> , 直到 <code>min(8, 8)</code> 时满足条件, 所以 <code>b</code> 的存储区域为 <code>8-15</code> 这8位</p><p>然后 <code>c</code> 就是 <code>min(16, 1)</code> , 可以直接整除, <code>c</code> 的区域就是 16, 占1位</p><p>最后 <code>d</code> 为 <code>min(17, 4)</code> , 直到 <code>min(20, 4)</code> 时满足条件, 可以得出, <code>d</code> 所在的区域为 20-23 </p></blockquote></li><li><h3 id="结构体作为成员对齐规则"><a href="#结构体作为成员对齐规则" class="headerlink" title="结构体作为成员对齐规则"></a>结构体作为成员对齐规则</h3><p>如果一个结构里有某些结构体成员, 则结构体成员要从其内部最大元素大小的整数倍地址开始存储。(struct a 里存有 struct b, b 里有 char, int , double等元素, 那 b 应该从8的整数倍开始存储。) 可以看一下下面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">struct MyStruct4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  double a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  short b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    struct MyStruct5 &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        int c;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        double d;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125; struct5;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125; struct4;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%lu&quot;, sizeof(struct4));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">2020-02-18 21:45:20.741445+0800 LGTest[38755:2172577] 32</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照原则1&#x2F;&#x2F; 遵循原则2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 0-7&#x2F;&#x2F;0-7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 8-11&#x2F;&#x2F;  8-11</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 12-15min(12, 4)&#x2F;&#x2F;  16-19   min(12, 8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 16-23min(16, 8)&#x2F;&#x2F;  24-31min(20, 8)</span></pre></td></tr></table></figure><p>可以看到, 如果我们继续按照上面的方式去存储的话, 得到的结果应该是 24。根据结构体作为成员的规则要求, <code>struct5</code> 的最大元素大小为 8 位, 所以 <code>struct5</code> 的第一个数据成员的起始位置应该是 8 的整数倍, 也就是 <code>min(12, 8)</code> , 然后再继续往下存储, 最后得出结果为32。</p></li><li><h3 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h3><p>结构体的总大小, 也就是 <code>sizeof</code> 的结果, 必须是其内部最大成员的整数倍, 不足的话需要补齐。实例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">struct MyStruct2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  int a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  char b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125; struct2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">struct MyStruct3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  double a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  char b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125; struct3;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%lu&quot;, sizeof(struct2));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%lu&quot;, sizeof(struct3));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">2020-02-18 21:25:22.008413+0800 LGTest[38015:2158667] 8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">2020-02-18 21:25:22.008605+0800 LGTest[38015:2158667] 16</span></pre></td></tr></table></figure><p>假如仅凭第一条的规则, 我们可以得出, <code>struct2</code> 的打印结果应该为 5, <code>struct3</code> 的结果应该为 9。但是我们的打印结果是 8 和 16, 这就验证了我们这一条的原则, <code>struct2</code> 的结果必须是 4 的倍数, 所以结果是 8; <code>struct3</code> 的结果应该是 8 的倍数, 所以结果是 16。</p></li></ul><h2 id="对象的内存对齐"><a href="#对象的内存对齐" class="headerlink" title="对象的内存对齐"></a>对象的内存对齐</h2><h3 id="1-属性的内存对齐"><a href="#1-属性的内存对齐" class="headerlink" title="1. 属性的内存对齐"></a>1. 属性的内存对齐</h3><p>了解了内存对齐的原则, 下面我们再来看一下对象的内存对齐是在什么时候进行的。通过之前的 <a href="https://juejin.im/post/5e0220c3f265da339f7d025f#heading-7" target="_blank" rel="noopener">alloc流程探索</a> 过程中我们知道了对象的创建是在 <code>callAlloc</code> 方法中完成的, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">#if __OBJC2__</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; No alloc&#x2F;allocWithZone implementation. Go straight to the allocator.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; fixme store hasCustomAWZ in the non-meta class and </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; add it to canAllocFast&#39;s summary</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        if (fastpath(cls-&gt;canAllocFast())) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &#x2F;&#x2F; No ctors, raw isa, etc. Go straight to the metal.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            bool dtor &#x3D; cls-&gt;hasCxxDtor();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            id obj &#x3D; (id)calloc(1, cls-&gt;bits.fastInstanceSize());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            if (slowpath(!obj)) return callBadAllocHandler(cls);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            return obj;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            &#x2F;&#x2F; Has ctor or raw isa or something. Use the slower path.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            id obj &#x3D; class_createInstance(cls, 0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            if (slowpath(!obj)) return callBadAllocHandler(cls);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            return obj;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; No shortcuts available.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    if (allocWithZone) return [cls allocWithZone:nil];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    return [cls alloc];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>根据方法名我们就不难发现 <code>id obj = class_createInstance(cls, 0);</code> 这一行代码应该就是创建对象的方法, 下面我们在往里逐一探索:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">id class_createInstance(Class cls, size_t extraBytes)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    return _class_createInstanceFromZone(cls, extraBytes, nil);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">static __attribute__((always_inline)) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">id</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                              bool cxxConstruct &#x3D; true, </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                              size_t *outAllocatedSize &#x3D; nil)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    if (!cls) return nil;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    assert(cls-&gt;isRealized());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    bool hasCxxCtor &#x3D; cls-&gt;hasCxxCtor();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    bool fast &#x3D; cls-&gt;canAllocNonpointer();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    size_t size &#x3D; cls-&gt;instanceSize(extraBytes);&#x2F;&#x2F; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    id obj;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    if (!zone  &amp;&amp;  fast) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        obj &#x3D; (id)calloc(1, size);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        if (!obj) return nil;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        if (zone) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            obj &#x3D; (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            obj &#x3D; (id)calloc(1, size);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        if (!obj) return nil;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; doing something weird with the zone or RR.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        obj-&gt;initIsa(cls);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    if (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        obj &#x3D; _objc_constructOrFree(obj, cls);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    return obj;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>来到这里, 发现这一行代码 <code>size_t size = cls-&gt;instanceSize(extraBytes);</code> , 继续往下走:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  size_t size &#x3D; alignedInstanceSize() + extraBytes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  if (size &lt; 16) size &#x3D; 16;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  return size;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Class&#39;s ivar size rounded up to a pointer-size boundary.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">uint32_t alignedInstanceSize() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  return word_align(unalignedInstanceSize());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  return (x + WORD_MASK) &amp; ~WORD_MASK;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">#define WORD_MASK 7UL</span></pre></td></tr></table></figure><p>这里当我们看到 <code>alignedInstanceSize()</code> 方法时发现此方法就是上面提到过的 <code>class_getInstanceSize</code> 方法的内部实现, 此方法的作用就是用来获取实例对象所占用的内存的大小, 此时就明了了。下面我们来着重看一下这个方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  return (x + WORD_MASK) &amp; ~WORD_MASK;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">#define WORD_MASK 7UL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设 x 为 9, 转换为二进制为  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; x + WORD_MASK (7) &#x3D; 16 转换为二进制</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 0001 0000   (即 16)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &amp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1111 1000   (&amp; 上 -7的二进制)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 0001 0000 (16)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 实际为 (x + 7) &gt;&gt; 3 &lt;&lt; 3</span></pre></td></tr></table></figure><p>根据方法名字可以看出, 该方法主要做的工作就是 <code>字节对齐</code> , 这正是我们要找的东西。通过上面对算法的模拟, 我们可以看出, 在这里系统对实例对象所占用的内存 (<strong>也就是对象属性所需要占用的内存大小</strong>) 进行了 <code>8字节对齐</code> 。然后回过头来通过 <code>instanceSize(size_t extraBytes)</code> 该方法的实现得知, 对象的内存大小至少为 16 字节。</p><h3 id="2-对象的内存对齐"><a href="#2-对象的内存对齐" class="headerlink" title="2. 对象的内存对齐"></a>2. 对象的内存对齐</h3><p>通过上面的探索我们知道了对象属性的 <code>8字节对齐</code> , 并且对象在申请内存空间时至少为16字节。下面来继续验证一下我们的结论是否正确:</p><p><em>这里需要注意: 在计算对象内存大小时不要忽略 isa 的 8 字节大小。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义类</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) int age;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) long height;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *hobby;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">MCPerson *person &#x3D; [[MCPerson alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%lu&quot;, class_getInstanceSize([MCPerson class]));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)(person)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">2020-02-18 23:39:29.977673+0800 LGTest[42667:2246768] 40</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">2020-02-18 23:39:29.979105+0800 LGTest[42667:2246768] 48</span></pre></td></tr></table></figure><p>通过打印结果可以看出, 对象需要的内存空间为 40, 但是实际开辟的内存空间确实 48。那么到底是在哪里发成了问题:</p><p><img src="/images/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-1.png" alt></p><p>从上图发现, 调用 <code>calloc</code> 方法时我们申请的内存大小是 40, 这里是没有问题的。继续往下执行, </p><p><img src="/images/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-2.png" alt></p><p>然后我们打印一下生成的对象的内存大小发现, 结果为 <code>0x0000000000000030</code> , 转换成10进制为 <code>48</code> 。那么, 问题出在 <code>calloc</code> 方法, 关于 <code>calloc</code> 的分析由于篇幅较长这里不做叙述了, 有兴趣的同学可以去看看 <a href="https://juejin.im/post/5e0894916fb9a016153dfa11" target="_blank" rel="noopener">Cooci老师的malloc分析</a>, 下面我们直接进入重点实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">static MALLOC_INLINE size_t</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">segregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; size &#x3D; 40</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">size_t k, slot_bytes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">if (0 &#x3D;&#x3D; size) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">size &#x3D; NANO_REGIME_QUANTA_SIZE; &#x2F;&#x2F; Historical behavior</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 40 + 16-1 &gt;&gt; 4 &lt;&lt; 4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 40 - 16*3 &#x3D; 48</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 16</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; #define NANO_REGIME_QUANTA_SIZE(1 &lt;&lt; SHIFT_NANO_QUANTUM)&#x2F;&#x2F; 16</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">k &#x3D; (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; &#x2F;&#x2F; round up and shift for number of quanta</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">slot_bytes &#x3D; k &lt;&lt; SHIFT_NANO_QUANTUM;&#x2F;&#x2F; multiply by power of two quanta size</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">*pKey &#x3D; k - 1;&#x2F;&#x2F; Zero-based!</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">return slot_bytes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>通过对 <code>calloc</code> 的一连串探索操作, 最终我们找到了上面的方法, 也找到了对象申请内存大小与实际大小不一样的关键问题。可以看出我们传过来的 <code>size</code> 经过 <code>(size + 16 - 1) &gt;&gt; 16 &lt;&lt; 16</code> 之后返回, 这不类似于之前属性的 <code>8字节对齐</code> 吗, 不同点在于这里是 <code>16字节对齐</code> 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这次内存对齐原理的全部内容, 通过以上的内容, 我们可以明白内存对齐的相关概念, 以及对象创建的过程中是怎样进行内存对齐的。首先在获取对象所需要的内存大小的时候进行了 属性的 <code>8字节对齐</code>, 然后在返回时进行了 <code>&lt;16</code> 判断, 最后就是 <code>calloc</code> 申请内存时又进行了一次对象的 <code>16字节对齐</code> 。<strong>通过这两次的字节对齐, 能有防止访问溢出, 同时也能够有效的提高寻址访问效率。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前在探索 &lt;a href=&quot;https://juejin.im/post/5e0220c3f265da339f7d025f#heading
      
    
    </summary>
    
    
      <category term="iOS底层学习" scheme="https://yoursite.com/categories/iOS%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS探索" scheme="https://yoursite.com/tags/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>iOS探索之--KVC 原理分析</title>
    <link href="https://yoursite.com/2020-02-16-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--KVC%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://yoursite.com/2020-02-16-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--KVC%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2020-02-15T16:00:00.000Z</published>
    <updated>2020-03-12T03:35:04.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>KVC (Key-Value Coding), 是利用 <code>NSKeyValueCoding</code> 非正式协议实现的一种机制, 对象采用这种机制来提供对其属性的间接访问。当对象采用该协议时, 可以通过简洁统一的方法来访问其属性。简单来说, 就是我们在开发中可以通过key名直接访问对象的属性, 或者对属性进行赋值操作, 而不需要去调用明确的存取方法。这样就允许我们在运行时去动态地访问和修改对象的属性, 而不是在编译时决定。</p></blockquote><h2 id="KVC-简介"><a href="#KVC-简介" class="headerlink" title="KVC 简介"></a>KVC 简介</h2><p>通过查看API我们不难发现, KVC的定义是通过对 <code>NSObject</code> 的扩展来实现的。所以对于所有集成了 <code>NSObject</code> 的类来说都可以使用 KVC, 也就是说出去少数类型 (结构体) 以外都可以使用KVC。下面是我们经常使用到的一些方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;&#x2F;&#x2F; 通过 key 设值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;&#x2F;&#x2F; 通过 key 取值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;&#x2F;&#x2F; 通过 keyPath 设值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;&#x2F;&#x2F; 通过 keyPath 取值</span></pre></td></tr></table></figure><p>NSKeyValueCoding类别的其它方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 默认为YES。 如果返回为YES,如果没有找到 set&lt;Key&gt; 方法的话, 会按照_key, _isKey, key, isKey的顺序搜索成员变量, 返回NO则不会搜索</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">+ (BOOL)accessInstanceVariablesDirectly;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 键值验证, 可以通过该方法检验键值的正确性, 然后做出相应的处理</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果key不存在, 并且没有搜索到和key有关的字段, 会调用此方法, 默认抛出异常。两个方法分别对应 get 和 set 的情况</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; setValue方法传 nil 时调用的方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意文档说明: 当且仅当 NSNumber 和 NSValue 类型时才会调用此方法 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">- (void)setNilValueForKey:(NSString *)key;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一组 key对应的value, 将其转成字典返回, 可用于将 Model 转成字典</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;</span></pre></td></tr></table></figure><h2 id="KVC-原理分析"><a href="#KVC-原理分析" class="headerlink" title="KVC 原理分析"></a>KVC 原理分析</h2><h3 id="1-KVC-设值过程"><a href="#1-KVC-设值过程" class="headerlink" title="1. KVC 设值过程"></a>1. KVC 设值过程</h3><p>当我们去调用 <code>setValue:值 forKey:名字</code> 设值方法时, 底层的执行机制大致如下:</p><ol><li><p>程序会去优先调用, <code>set&lt;Key&gt;: 或者 _set&lt;Key&gt;, setIs&lt;Key&gt;</code> 方法, 如果存在这些命名规则的方法, 会直接调用该方法进行赋值。<strong>调用优先顺序按照上面书写的顺序。</strong></p><p><strong>说明: 这里的 “key” 指成员变量名字, 书写格式需要符合 KVC 的命名规则。</strong></p></li><li><p>如果没有找到步骤1的方法, 程序会回去判断 <code>+ (BOOL)accessInstanceVariablesDirectly;</code> 方法的返回值, 如果该方法返回值为NO (默认为 YES, 在我们重写该方法时有可能返回NO, 一般不会返回NO), 则会执行 <code>setValue: forUndefinedKey:</code> 方法报错。</p></li><li><p>如果上一步方法的返回值为YES, 程序会去查找命名方式为 <code>_&lt;key&gt;, _&lt;isKey&gt;, &lt;key&gt;, &lt;isKey&gt;</code> 形式的实例变量, 加入存在该形式的实例变量, 则会直接将我们调用方法的值赋值给该实例变量。<strong>这里的查找优先顺序也会按照书写顺序去查找。</strong></p></li><li><p>如果第三步没有查找到符合规则的实例变量, 程序就会去执行 <code>setValue: forUndefinedKey:</code> 方法进行报错。</p></li></ol><p>下面是一段验证代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明实例变量</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">@interface MCPerson : NSObject &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    @public</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    NSString *_name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    NSString *name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    NSString *_isName;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    NSString *isName;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">@end</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .m文件实现上面提到的方法进行监听</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">+ (BOOL)accessInstanceVariablesDirectly &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    return YES;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">- (void)setValue:(id)value forUndefinedKey:(nonnull NSString *)key &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;设置出现异常!!!&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)value &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;%s - %@&quot;, __func__, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">- (void)setIsName:(NSString *)value &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;%s - %@&quot;, __func__, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">- (void)_setName:(NSString *)value &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;%s - %@&quot;, __func__, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 测试代码</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    MCPerson *person &#x3D; [[MCPerson alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    [person setValue:@&quot;person&quot; forKey:@&quot;name&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;%@ - %@ - %@ - %@&quot;, person-&gt;_name, person-&gt;_isName, person-&gt;name, person-&gt;isName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;%@ - %@ - %@&quot;, person-&gt;_isName, person-&gt;name, person-&gt;isName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;%@ - %@&quot;, person-&gt;name, person-&gt;isName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;%@&quot;, person-&gt;isName);</span></pre></td></tr></table></figure><ol><li>执行上面的代码, 查看打印信息如下:</li></ol><p><img src="/images/kvc-1.png" alt><br>可以看到程序执行了 <code>setName</code> 方法, 验证了上面步骤1的内容。而且我们发现三个方法中执行完第一个方法以后后面的就不会去执行了, 如果我们注释掉 <code>setName</code> 的话, 得到的结果是执行<code>_setName</code> , 由此就能得出方法的查找和执行优先顺序。</p><ol start="2"><li>将上面的set方法注释掉, 然后 <code>accessInstanceVariablesDirectly</code> 方法的返回值改为 NO</li></ol><p><img src="/images/kvc-2.png" alt><br>根据打印信息发现调用了 <code>setValue: forUndefinedKey:</code> 方法抛出了异常, 下面再把返回值改为 YES。</p><p><img src="/images/kvc-3.png" alt><br>可以发现我们的值被赋值给了 <code>_name</code> ,其余的三个实例变量仍然是空值, 然后试着把 <code>_name</code>注释掉就可以去一一验证实例变量的查找优先顺序了有兴趣的可以自己去验证一下。</p><h3 id="2-KVC-取值过程"><a href="#2-KVC-取值过程" class="headerlink" title="2. KVC 取值过程"></a>2. KVC 取值过程</h3><ol><li><p>首先按照 <code>get&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;, _&lt;key&gt;</code> 的顺序查找方法, 如果找到方法, 执行找到的方法得到返回值, 返回值的判断跳到第5步; 如果没有查找到方法, 进行下一步</p></li><li><p>如果没有找到上面的方法, KVC 就会去继续查找 <code>countOf&lt;Key&gt;, objectIn&lt;Key&gt;AtIndex: (对应NSArray的方法), &lt;key&gt;AtIndexes: (对应NSArray 的 objectsAtIndexes: 方法)</code> 格式的方法, 如果找到 <code>countOf&lt;Key&gt;</code> 和 另外两个方法中的一个, 就会返回一个可以响应所有NSArray方法的代理集合对象。当该代理集合对象接收到 NSArray 的方法调用时, 会去转换为对 <code>countOf&lt;Key&gt;, objectIn&lt;Key&gt;AtIndex 或 &lt;Key&gt;AtIndexes</code> 这几个方法的调用 (此外还有一个可选方法格式为 <code>get&lt;Key&gt;:range</code> )。(<strong>注意: 该类为<code>NSKeyValueArray</code> , 是NSArray的子类</strong>)</p></li><li><p>如果第2步仍然没有找到, 就会继续去查找 <code>countOf&lt;Key&gt;, enumeratorOf&lt;Key&gt;, 和 memberOf&lt;Key&gt;: (对应NSSet的方法)</code> 格式的方法, 如果这三种格式的方法都找到, 就会返回一个响应所有NSSet方法的代理集合对象, 反之则进行第4步。该集合对象会将接收到的NSSet方法调用转换为对 <code>countOf&lt;Key&gt;, enumeratorOf&lt;Key&gt;, 和 memberOf&lt;Key&gt;:</code> 方法的调用。</p></li><li><p>如果没有找到任何符合要求的方法, 然后 <code>accessInstanceVariablesDirectly</code> 的返回值为YES, 会像上面的设值过程一样去查询实例变量 <code>_&lt;key&gt;, _&lt;isKey&gt;, &lt;key&gt;,</code> , 如果查询到符合条件的实例变量, 会直接取出实例变量的值, 然后进行第5步。反之, 直接到第6步。</p></li><li><p>如果第4步获取到的属性值是一个对象指针, 直接返回结果; 如果该值是 NSNumber 支持的标量类型, 将其存储为 NSNumber类型的实例然后返回; 如果该值不是 NSNumber 支持的标量类型, 将其转换为 NSValue对象然后返回。</p></li><li><p>调用 <code>valueForUndefinedKey:</code> 方法进行报错。</p></li></ol><p>下面是关于取值过程的代码验证:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) NSArray *array;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) NSSet *set;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) NSMutableString *arrayM;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) NSMutableSet *setM;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) NSMutableOrderedSet *orderSetM;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">- (id)valueForUndefinedKey:(NSString *)key &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;取值出现异常!!!&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    return key;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">- (NSString *)getName &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    return NSStringFromSelector(_cmd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">- (NSString *)name &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    return NSStringFromSelector(_cmd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">- (NSString *)isName &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    return NSStringFromSelector(_cmd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">- (NSString *)_name &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    return NSStringFromSelector(_cmd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">#pragma - NSArray -</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">- (NSUInteger)countOfPens &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;- %s -&quot;, __func__);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    return [self.array count];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">- (id)objectInPensAtIndex:(NSUInteger)index &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;- %s -&quot;, __func__);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    return self.array[index];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">#pragma - NSSet -</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">- (NSUInteger)countOfBooks &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;- %s -&quot;, __func__);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    return [self.set count];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">- (NSEnumerator *)enumeratorOfBooks &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;- %s -&quot;, __func__);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    return [self.set objectEnumerator];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">- (NSString *)memberOfBooks:(NSString *)object &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;- %s -&quot;, __func__);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    return [self.set containsObject:object] ? object : nil;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 验证代码</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    person-&gt;_name &#x3D; @&quot;我是 _name&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    person-&gt;name &#x3D; @&quot;我是 name&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    person-&gt;isName &#x3D; @&quot;我是 isName&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    person-&gt;_isName &#x3D; @&quot;我是 _isName&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;***** %@&quot;, [person valueForKey:@&quot;name&quot;]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    person.array &#x3D; @[@&quot;pen0&quot;, @&quot;pen1&quot;, @&quot;pen2&quot;, @&quot;pen3&quot;, @&quot;pen4&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    NSArray *array &#x3D; [person valueForKey:@&quot;pens&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;%@&quot;, [array objectAtIndex:1]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;数量 %ld&quot;, [array count]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;是否存在该值 %d&quot;, [array containsObject:@&quot;pen2&quot;]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">    person.set &#x3D; [NSSet setWithArray:person.array];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">    NSSet *set &#x3D; [person valueForKey:@&quot;books&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">    [set enumerateObjectsUsingBlock:^(id  _Nonnull obj, BOOL * _Nonnull stop)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">        NSLog(@&quot;遍历set: %@&quot;, obj);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;是否存在该值 %d&quot;, [set containsObject:@&quot;pen2&quot;]);</span></pre></td></tr></table></figure><p>打印结果:<br><img src="/images/kvc-4.png" alt><br>通过上面的代码可以去检索KVC在 <code>valueForKey:@&quot;name&quot;</code> 是的查询机制, 这里不再一一列出, 有兴趣的可以自己去一一验证。</p><h3 id="3-KVC-与-容器类"><a href="#3-KVC-与-容器类" class="headerlink" title="3. KVC 与 容器类"></a>3. KVC 与 容器类</h3><p>我们知道对象的属性既可以是一对一的, 也可以是一对多的。可以是有序的数组, 也可以是无序的集合。当对象属性是可变容器时, 苹果给我们提供了下面的方法:</p><h4 id="1-有序的"><a href="#1-有序的" class="headerlink" title="1. 有序的"></a>1. 有序的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;</span></pre></td></tr></table></figure><p>该方法返回一个可变的有序数组, 当调用该方法时KVC的搜索顺序是这样的:</p><ul><li><p>首先搜索 <code>insertObject:in&lt;Key&gt;AtIndex: 和 removeObjectFrom&lt;Key&gt;AtIndex:</code> 方法 (对应<code>NSMutableArray</code> 的 <code>insertObject:atIndex: 和 removeObjectAtIndex:</code> 方法), 或者<code>insert&lt;Key&gt;:atIndexes: 和 remove&lt;Key&gt;AtIndexes:</code> (对应<code>NSMutableArray</code>的<code>insertObjects:atIndexes: 和 removeObjectsAtIndexes:</code> 方法)。如果至少找到一个 insert方法和一个remove方法,就会返回一个可以相应NSMutableArray所有方法的代理集合, 当该代理集合对象接收到 NSMutableArray 的方法调用时, 会去转换为对 <code>insertObject:inAtIndex:</code> , <code>removeObjectFromAtIndex:</code> 或者 <code>insertAdIndexes</code> , <code>removeAtIndexes</code>组合的形式调用 (此外还有两个可选的方法<code>replaceOnjectAtIndex:withObject:, replaceAtIndexes:with:</code>) 。</p></li><li><p>如果上面的条件没有成立, 会继续搜索格式为 <code>set&lt;Key&gt;</code> 的方法, 如果找到, 那么代理集合对象接收到的NSMutableArray方法调用都会去调用<code>set&lt;Key&gt;</code>方法。就是说, 取出的代理集合如果被修改后, 都会通过调用 <code>set&lt;Key&gt;</code> 方法重新赋值回去, 这样做的话大大降低了效率。(所以尽量实现上面的方法)</p></li><li><p>如果上一步的方法还是没有找到, 会去检查 <code>accessInstanceVariablesDirectly</code> 的返回值, 为YES, 会按照 <code>_&lt;key&gt;, &lt;key&gt;</code> 的顺序去搜索实例变量, 如果找到的话, 代理集合接收到的NSMutableArray消息直接交给这个实例变量处理。</p></li><li><p>如果仍然没有结果, 调用 <code>valueForUndefinedKey:</code>。</p></li><li><p>关于 <code>mutableArrayValueForKey</code> 的用法, 网上只找到了关于<code>NSMutableArray</code> 添加观察者时。如果对象的属性是 <code>NSMutableArray、NSMutableSet、NSMutableDictionary</code> 等集合类型时, 如果我们对其添加KVO, 会发现当添加或者移除元素时并不能接收到变化。因为KVO是在系统检测到某个属性的内存地址或者常量发生改变时, 才会去发送通知。一种方法是我们去手动调用方法通知对象的改变, 但是并不推荐, 因为我们无法像系统一样准确的知道其改变。另外一种就是利用 <code>mutableArrayValueForKey</code> :</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@interface MCStudent ()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) NSMutableArray *arr;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">@end</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    if (self &#x3D; [super init]) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        _arr &#x3D; [NSMutableArray array];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        [self addObserver:self forKeyPath:@&quot;arr&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    return self;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;change: %@&quot;, change);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    [self removeObserver:self forKeyPath:@&quot;arr&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">- (void)addItem&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    [_arr addObject:@&quot;1&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">- (void)addItemObserver&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    [[self mutableArrayValueForKey:@&quot;arr&quot;] addObject:@&quot;1&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">- (void)removeItemObserver&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    [[self mutableArrayValueForKey:@&quot;arr&quot;] removeLastObject];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 测试代码</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    [student addItem];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    [student addItemObserver];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    [student removeItemObserver];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果如下</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">2020-02-16 16:16:21.315056+0800 002-KVC取值&amp;赋值过程[2281:1547198] change: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    indexes &#x3D; &quot;&lt;_NSCachedIndexSet: 0x60000107edc0&gt;[number of indexes: 1 (in 1 ranges), indexes: (1)]&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    kind &#x3D; 2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    new &#x3D;     (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">2020-02-16 16:16:21.315270+0800 002-KVC取值&amp;赋值过程[2281:1547198] change: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    indexes &#x3D; &quot;&lt;_NSCachedIndexSet: 0x60000107edc0&gt;[number of indexes: 1 (in 1 ranges), indexes: (1)]&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    kind &#x3D; 3;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    old &#x3D;     (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>从上面的代码可以看出, 当我们按照通常的方式去给数组添加对象时, 并没有触发KVO的监听方法, 只有通过 <code>mutableArrayValueForKey</code> 方法拿到数组然后再去进行添加/移除时才会触发KVO。</p><h4 id="2-无序的"><a href="#2-无序的" class="headerlink" title="2. 无序的"></a>2. 无序的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;</span></pre></td></tr></table></figure><p>该方法返回一个可变的无序数组, KVC搜索顺序如下:</p><ul><li>首先会去查询 <code>addObject&lt;Key&gt;Object: , remove&lt;Key&gt;Object: 或者 add&lt;Key&gt;: , remove&lt;Key&gt;:</code>, 如果至少找到一个 insert和一个remove方法, 就会返回一个可以响应NSMutableSet所有方法的代理集合, 当该代理集合对象接收到 NSMutableSet 的方法调用时, 会去转换为对 <code>addObject&lt;Key&gt;Object: , remove&lt;Key&gt;Object: 或者 add&lt;Key&gt;:, remove&lt;Key&gt;:</code>组合的形式调用 (此外还有两个可选的方法<code>replaceOnjectAtIndex:withObject:, replaceAtIndexes:with:</code>) 。</li><li>如果 receiver 是 managed object, 那么就不会继续搜索 (See Managed Object Accessor Methods in <em><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_blank" rel="noopener">Core Data Programming Guide</a></em> for more information) 。</li><li>如果上一步的方法没有找到，则搜索<code>set&lt;Key&gt;:</code> 格式的方法，如果找到，那么发送给代理集合的 <code>NSMutableSet</code> 方法最终都会调用<code>set&lt;Key&gt;:</code>方法。 也就是说，<code>mutableSetValueForKey</code> 取出的代理集合修改后，用<code>set&lt;Key&gt;:</code> 重新赋值回去。这样做效率会低很多。所以推荐实现上面的方法。</li><li>如果上一步的方法还是没有找到, 会去检查 <code>accessInstanceVariablesDirectly</code> 的返回值, 为YES, 会按照 <code>_&lt;key&gt;, &lt;key&gt;</code> 的顺序去搜索实例变量, 如果找到的话, 代理集合接收到的NSMutableSet 消息直接交给这个实例变量处理。</li><li>如果仍然没有结果, 调用 <code>valueForUndefinedKey:</code>。</li></ul><h3 id="4-KVC-与-字典"><a href="#4-KVC-与-字典" class="headerlink" title="4. KVC 与 字典"></a>4. KVC 与 字典</h3><p>当对字典对象使用KVC时, KVC给我们提供了下面两个方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;</span></pre></td></tr></table></figure><p><code>dictionaryWithValuesForKeys:</code> 该方法接收一组key, 然后将该组key对应的属性封装成一个字典返回。</p><p><code>setValuesForKeysWithDictionary:</code> 通过一个字典来修改对应key的值。</p><h2 id="KVC-的使用注意事项"><a href="#KVC-的使用注意事项" class="headerlink" title="KVC 的使用注意事项"></a>KVC 的使用注意事项</h2><h3 id="1-在KVC中使用-keyPath"><a href="#1-在KVC中使用-keyPath" class="headerlink" title="1. 在KVC中使用 keyPath"></a>1. 在KVC中使用 keyPath</h3><p>在实际过程中, 一个类的成员变量有可能是自定义的类或者其他的复杂类型, 这时候如果想要使用KVC获取到自定义类的属性就会比较麻烦。这时KVC给我们提供了一个解决方案, 键路径 <code>keyPath</code>。方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;  &#x2F;&#x2F;通过KeyPath来取值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  &#x2F;&#x2F;通过KeyPath来设值</span></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MCStudent *student &#x3D; [[MCStudent alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">student.classNumber &#x3D; @&quot;num1&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">student.number &#x3D; @&quot;007&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">person.student &#x3D; student;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;classNum: %@&quot;, [personvalueForKeyPath:@&quot;student.classNumber&quot;]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">2020-02-16 13:27:08.482381+0800 002-KVC取值&amp;赋值过程[96366:1435734] classNum: num1</span></pre></td></tr></table></figure><p>上面展示<code>keyPath</code>的简单用法, 此时如果我们调用的方法是 <code>valueForKey:</code> 的话, 一般情况下系统会去调用<code>undefinedKey</code>方法, 因为没有找到这个属性及其相关的方法和实例变量。KVC在此方法中的搜索机制首先根据 “ . “ 来分割key, 然后在去按照上面的顺序去搜索下去。</p><h3 id="2-KVC-的自动转换"><a href="#2-KVC-的自动转换" class="headerlink" title="2. KVC 的自动转换"></a>2. KVC 的自动转换</h3><p>我们进行设值或者取值的时候, 不是每次都是对象类型, 但是在 <code>valueForKey: 和 setValue: forKey:</code> 时总是需要或者返回一个id对象类型。看一下下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    float x, y, z;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125; ThreeFloats;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *subject;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) int  age;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) BOOL sex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic) ThreeFloats  threeFloats;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  [person setValue:@18 forKey:@&quot;age&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 上面那个表达 大家应该都会! 但是下面这样操作可以?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  [person setValue:@&quot;20&quot; forKey:@&quot;age&quot;]; &#x2F;&#x2F; int - string</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  NSLog(@&quot;%@-%@&quot;,[person valueForKey:@&quot;age&quot;],[[person valueForKey:@&quot;age&quot;] class]);&#x2F;&#x2F;__NSCFNumber</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  [person setValue:@&quot;20&quot; forKey:@&quot;sex&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  NSLog(@&quot;%@-%@&quot;,[person valueForKey:@&quot;sex&quot;],[[person valueForKey:@&quot;sex&quot;] class]);&#x2F;&#x2F;__NSCFNumber</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">2020-02-16 14:40:31.263662+0800 004-KVC异常小技巧[98873:1483589] 20-__NSCFNumber</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">2020-02-16 14:40:33.829650+0800 004-KVC异常小技巧[98873:1483589] 1-__NSCFBoolean</span></pre></td></tr></table></figure><p>如果原本的变量类型是值类型或者布尔类型, 我们直接以字符串进行赋值以后, 得出的结果为 <code>__NSCFNumber 和__NSCFBoolean</code> 类型, 说明在我们进行setValue 和 getValue操作时, 系统帮我们进行了自动转换。那么当变量类型是结构体类型的时候呢, 此时我们是无法再去直接使用字符串赋值的, 需要我们将其转换为 <code>NSValue</code>类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 赋值操作</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ThreeFloats floats &#x3D; &#123;1., 2., 3.&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">NSValue *value  &#x3D; [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">[person setValue:value forKey:@&quot;threeFloats&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">NSValue *reslut &#x3D; [person valueForKey:@&quot;threeFloats&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%@&quot;,reslut);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%@-%@&quot;,[person valueForKey:@&quot;threeFloats&quot;],[[person valueForKey:@&quot;threeFloats&quot;] class]);&#x2F;&#x2F;NSConcreteValue</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 取值操作</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">ThreeFloats th;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">[reslut getValue:&amp;th] ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%f - %f - %f&quot;,th.x,th.y,th.z);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">2020-02-16 15:05:00.494832+0800 004-KVC异常小技巧[99701:1501772] &#123;length &#x3D; 12, bytes &#x3D; 0x0000803f0000004000004040&#125;-NSConcreteValue</span></pre></td></tr></table></figure><p>通过打印结果可以看出, 转换成 NSValue 类型以后赋值成功了, 然后如果我们需要使用 <code>valueForKey</code> 取值时, 同样取出的也是 NSValue 类型的值, 此时需要进行如上面样将其转换为结构体然后进行使用。所以当我们进行KVC设值和取值操作时, 因为我们传递进去和取出来的都是id类型的值, 有时候需要我们自己去保证类型的正确性。</p><h3 id="3-KVC-异常处理"><a href="#3-KVC-异常处理" class="headerlink" title="3. KVC 异常处理"></a>3. KVC 异常处理</h3><p>这一点需要结合上面的第2点进行说明, 我们知道KVC有时候会帮我们去自动转换我们所传的值, 但是当我们传 nil 的时候KVC是怎么处理的呢。下面看一段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (void)setNilValueForKey:(NSString *)key;</span></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (void)setNilValueForKey:(NSString *)key&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;你傻不傻: 设置 %@ 是空值&quot;,key);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *subject;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) int  age;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) BOOL sex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic) ThreeFloats  threeFloats;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 测试代码</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  NSLog(@&quot;******2: 设置空值******&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  [person setValue:nil forKey:@&quot;age&quot;]; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  [person setValue:nil forKey:@&quot;subject&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  [person setValue:nil forKey:@&quot;sex&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  [person setValue:nil forKey:@&quot;threeFloats&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印结果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">2020-02-16 16:58:44.538117+0800 004-KVC异常小技巧[3703:1577245] ******2: 设置空值******</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">2020-02-16 16:58:44.538200+0800 004-KVC异常小技巧[3703:1577245] 你傻不傻: 设置 age 是空值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">2020-02-16 16:58:44.538293+0800 004-KVC异常小技巧[3703:1577245] 你傻不傻: 设置 sex 是空值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">2020-02-16 16:58:44.538487+0800 004-KVC异常小技巧[3703:1577245] 你傻不傻: 设置 threeFloats 是空值</span></pre></td></tr></table></figure><p>可以看出给subject设置空值时, 不会走该方法, 其余三个进行 nil 赋值时都会调用该方法抛出异常。官方文档上面说明的是针对需要转换为 <code>NSNumber 和 NSValue</code> 类型的数据赋值 nil 时会抛出异常, 所以 当我们给 <code>NSString</code> 类型的subject进行赋值时并没有报错。</p><h3 id="4-KVC-正确性验证"><a href="#4-KVC-正确性验证" class="headerlink" title="4. KVC 正确性验证"></a>4. KVC 正确性验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span></pre></td></tr></table></figure><p>该方法默认返回YES, 如果类中实现了该方法, 那么就会去调用新实现的方法来返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (BOOL)validateValue:(inout id  _Nullable __autoreleasing *)ioValue forKey:(NSString *)inKey error:(out NSError *__autoreleasing  _Nullable *)outError&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    if([inKey isEqualToString:@&quot;name&quot;])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        [self setValue:[NSString stringWithFormat:@&quot;里面修改一下: %@&quot;,*ioValue] forKey:inKey];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        return YES;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    *outError &#x3D; [[NSError alloc]initWithDomain:[NSString stringWithFormat:@&quot;%@ 不是 %@ 的属性&quot;,inKey,self] code:10088 userInfo:nil];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    return NO;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>如上所示, 我们可以在该方法里面去验证某个key是否允许通过KVC去设定, 然后进行相关处理和返回。(注意: KVC是不会去主动验证的, 需要我们在该方法里面去实现验证。)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是KVC的一些原理和一些需要注意的点, 所有的东西都是通过阅读官方的文档和自己结合官方文档的一些理解。希望读者在看完后能对KVC有更进一步的理解, 同时推荐你们去看一下官方文档上的详细说明。如果有不对的地方或者不合理的地方欢迎大佬们提出, 我们一起学习, 一起进步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;KVC (Key-Value Coding), 是利用 &lt;code&gt;NSKeyValueCoding&lt;/code&gt; 非正式协议实现的一种机制, 对象采用这种机制来提供对其属性的间接访问。当对象采用该协议时, 可以通过简洁统一的方法来访问其属性。简单
      
    
    </summary>
    
    
      <category term="iOS底层学习" scheme="https://yoursite.com/categories/iOS%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS探索" scheme="https://yoursite.com/tags/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>iOS探索之--alloc、init 与 new</title>
    <link href="https://yoursite.com/2019-12-24-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--alloc%E3%80%81init%20%E4%B8%8E%20new/"/>
    <id>https://yoursite.com/2019-12-24-iOS%E6%8E%A2%E7%B4%A2%E4%B9%8B--alloc%E3%80%81init%20%E4%B8%8E%20new/</id>
    <published>2019-12-23T16:00:00.000Z</published>
    <updated>2020-03-12T03:39:53.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote><p>最近这段时间在跟 <a href="https://juejin.im/user/5c3f3c415188252b7d0ea40c/likes" target="_blank" rel="noopener">Cooci 老师</a> 学习 iOS 底层原理的探究, 然后准备在接下来的时间里把所学内容一步步整理下来。方便以后的回顾和查看, 也为自己定个目标和督促自己。如果文章中出现什么问题或错误, 希望各位大佬能多多指正和提出, 谢谢大家。一起努力, 共同进步😺!!!</p></blockquote><h3 id="一-源码跟踪"><a href="#一-源码跟踪" class="headerlink" title="一. 源码跟踪"></a>一. 源码跟踪</h3><p>一般情况下, 当我们想要去了解某个方法的实现的时候, 我们可以在工程里面 <code>command + Ctrl</code> 然后点击我们想要查看的方法。但是在系统方法上却不能找到我们想要的答案, 因为苹果公司并没有把所有方法的实现开源出来, 下面介绍几种寻找源码实现的方法:</p><h4 id="方法断点"><a href="#方法断点" class="headerlink" title="方法断点:"></a>方法断点:</h4><p>第一种方法就是我们通常使用通过给当前方法下断点, 然后逐步往后运行的方法。需要注意的地方如下图:</p><p><img src="/images/alloc,init,new-1.png" alt></p><center>图 1</center>需要按住 ``` Ctrl``` 然后一步步往下执行, 才能找到我们需要的东西。还有就是需要在真机上进行调试, 模拟器会在 'pushq' 和 'jmp' 之间一直循环。<p><img src="/images/alloc,init,new-2.png" alt></p><center>图 2</center>最后得到的结果如上图2, ```libobjc.A.dylib``` 就是我们所要找的东西。<h4 id="符号断点"><a href="#符号断点" class="headerlink" title="符号断点:"></a>符号断点:</h4><p>通过在程序运行中加入 <code>符号断点</code> 来拦截当前正在执行的方法, 如下图:</p><p><img src="/images/alloc,init,new-3.png" alt></p><center>图 3</center>不过需要注意的是, 在开始打符号断点之前, 首先要先等程序走到我们之前打过的方法断点。因为比如上图的 ``` alloc``` 方法, 系统有太多的类会去调用该方法, 如果不先定位到方法断点, 就会一直走到符号断点, 无法确认当前 ```alloc``` 方法到底是哪个类调用的。<h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编:"></a>汇编:</h4><p>使用这个方法首先需要设置 <code>xcode-&gt;Debug-&gt;Debug workflow-&gt;勾选 always Show Disassembly</code> , 然后重新启动程序。 在程序运行到我们的断点的时候就会直接进入汇编界面, 如下图:</p><p><img src="/images/alloc,init,new-4.png" alt></p><center>图 4</center>找到我们想要了解的方法, 上图中红框内的 ```objc_alloc```, 就是我想要去找的方法。然后继续断点, 按住 ``` Ctrl``` , 一步步执行, 一直到如下页面:<p><img src="/images/alloc,init,new-5.png" alt></p><center>图 5</center>最后的结果如上图。(ps: 如果你发现最后的结果跟上面不一样, 不要慌, 修好车, 我们从头再来 !!!)<h3 id="二-alloc-amp-init-amp-new-探究"><a href="#二-alloc-amp-init-amp-new-探究" class="headerlink" title="二. alloc &amp; init &amp; new 探究"></a>二. alloc &amp; init &amp; new 探究</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备:"></a>准备:</h4><p>通过上面的方法, 我们找到了我们的方法所在的位置。然后下一步就去展开对源码的探究吧, 具体准备如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">objc4-750源码 + Xcode 11 + MacOS 10.15</span></pre></td></tr></table></figure><p><a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">官方源码地址</a></p><p>官方的源码下载下来是不能直接编译的, 我们还需要做一下后面的处理, 具体处理步骤在这里 😝 :<a href="https://juejin.im/post/5d9c829df265da5ba46f49c9" target="_blank" rel="noopener">iOS_objc4-756.2 最新源码编译调试</a> , 当然你也可以直接下载下来。</p><h4 id="1-alloc-原理"><a href="#1-alloc-原理" class="headerlink" title="1. alloc 原理:"></a>1. alloc 原理:</h4><p>环境配置好之后, 在 <code>alloc</code> 方法打上断点, 然后一步步往下层查看。</p><p><img src="/images/alloc,init,new-6.png" alt></p><center>图6 准备代码</center>##### alloc 流程图:<p>废话少说, 先放上我根据调试流程画的 alloc 流程图:</p><hr><p><img src="/images/alloc,init,new-7.png" alt></p><hr><center>图7 alloc 流程图</center>从流程图上可以看出, 在 ``` callAlloc()``` 方法执行以后, 程序开始出现分叉, 下面是方法源码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;*** 此处不需要了 ***&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    #if __OBJC2__</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        if (fastpath(cls-&gt;canAllocFast())) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            &#x2F;&#x2F; No ctors, raw isa, etc. Go straight to the metal.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            bool dtor &#x3D; cls-&gt;hasCxxDtor();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            id obj &#x3D; (id)calloc(1, cls-&gt;bits.fastInstanceSize());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            if (slowpath(!obj)) return callBadAllocHandler(cls);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            return obj;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            &#x2F;&#x2F; Has ctor or raw isa or something. Use the slower path.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">          &#x2F;&#x2F; 重点在这里</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            id obj &#x3D; class_createInstance(cls, 0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            if (slowpath(!obj)) return callBadAllocHandler(cls);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            return obj;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    #endif</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#x2F;*** 此处也不要了 ***&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>接下来我们首先一起看一下 <code>fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())</code> 这个条件是否成立, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; hasCustomAWZ()的实现</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">bool hasCustomAWZ() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        return ! bits.hasDefaultAWZ();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; hasDefaultAWZ()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 出现宏定义, FAST_HAS_DEFAULT_AWZ 和 RW_HAS_DEFAULT_AWZ</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">#if FAST_HAS_DEFAULT_AWZ</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">#else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    bool hasDefaultAWZ() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        return data()-&gt;flags &amp; RW_HAS_DEFAULT_AWZ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    void setHasDefaultAWZ() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        data()-&gt;setFlags(RW_HAS_DEFAULT_AWZ);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    void setHasCustomAWZ() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        data()-&gt;clearFlags(RW_HAS_DEFAULT_AWZ);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">#endif</span></pre></td></tr></table></figure><p>下面是我根据宏定义的名字搜索到的具体定义, 由于内容较多进行了删减</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#if !__LP64__ &#x2F;&#x2F; 如果是 32位的话</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; class or superclass has default alloc&#x2F;allocWithZone: implementation</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Note this is is stored in the metaclass.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">#define RW_HAS_DEFAULT_AWZ    (1&lt;&lt;16)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">#elif 1&#x2F;&#x2F; if (1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; class or superclass has default alloc&#x2F;allocWithZone: implementation</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Note this is is stored in the metaclass.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">#define RW_HAS_DEFAULT_AWZ    (1&lt;&lt;16)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#x2F;* 在这里, FAST_ALLOC 和 FAST_HAS_DEFAULT_AWZ 根本没有被编译 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">#else &#x2F;&#x2F; 好像走不到这里😹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; summary bit for fast alloc path: !hasCxxCtor and </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;   !instancesRequireRawIsa and instanceSize fits into shiftedSize</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">#define FAST_ALLOC              (1UL&lt;&lt;2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; class or superclass has default alloc&#x2F;allocWithZone: implementation</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Note this is is stored in the metaclass.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">#define FAST_HAS_DEFAULT_AWZ    (1UL&lt;&lt;48)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据上面的宏定义我发现</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ()) 结果为 true, 因为 cls-&gt;ISA()-&gt;hasCustomAWZ() 结果为false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; fastpath(cls-&gt;canAllocFast()) 结果为 false, 因为 canAllocFast() 结果为 false</span></pre></td></tr></table></figure><p>经过上面的分析, 我们最后来到了 <code>id obj = class_createInstance(cls, 0);</code> 该方法里面, 从方法名字就可以得出 “创建对象”, 我们继续查看该方法的内部实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">id class_createInstance(Class cls, size_t extraBytes) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    return _class_createInstanceFromZone(cls, extraBytes, nil);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">static __attribute__((always_inline)) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                              bool cxxConstruct &#x3D; true, </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                              size_t *outAllocatedSize &#x3D; nil) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    if (!cls) return nil;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Locking: To prevent concurrent realization, hold runtimeLock.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 加锁, 防止该步骤的并发实现, 保持运行时锁定</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    assert(cls-&gt;isRealized());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    bool hasCxxCtor &#x3D; cls-&gt;hasCxxCtor();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    bool fast &#x3D; cls-&gt;canAllocNonpointer(); &#x2F;&#x2F; 是否需要初始化 isa 指针</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    size_t size &#x3D; cls-&gt;instanceSize(extraBytes);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    id obj;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    if (!zone  &amp;&amp;  fast) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        obj &#x3D; (id)calloc(1, size); &#x2F;&#x2F; 内存申请</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        if (!obj) return nil;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor); &#x2F;&#x2F; 初始化 isa</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        if (zone) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            obj &#x3D; (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            obj &#x3D; (id)calloc(1, size);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        if (!obj) return nil;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; doing something weird with the zone or RR.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        obj-&gt;initIsa(cls);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    if (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        obj &#x3D; _objc_constructOrFree(obj, cls);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    return obj;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>在对上面代码的分析中, 我们找到了 <code>内存申请 (id)calloc(1, size);</code> 和 <code>初始化 isa指针 obj-&gt;initInstanceIsa(cls, hasCxxDtor);</code> 的方法, 那么在这之前还有一行代码需要我们去注意:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">size_t size &#x3D; cls-&gt;instanceSize(extraBytes); &#x2F;&#x2F; 获取需要开辟的内存大小</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        size_t size &#x3D; alignedInstanceSize() + extraBytes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        if (size &lt; 16) size &#x3D; 16;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        return size;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Class&#39;s ivar size rounded up to a pointer-size boundary.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">uint32_t alignedInstanceSize() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  return word_align(unalignedInstanceSize());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 7+8 &#x3D; 15</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 0000 1111</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 0000 1000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;&amp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 1111 1000 ~7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 0000 1000 8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 0000 0111</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; x + 7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 8 二阶</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; (x + 7) &gt;&gt; 3 &lt;&lt; 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里可以看出, 我们的系统通过一系列的算法操作, 最后帮我们算出了所需开辟的内存大小。那么这个结果是具体怎么来的, 这就关系到了 <u>内存对齐</u> 方面的内容, 我们放到下一期里面讨论吧😝。</p><h4 id="2-init-原理"><a href="#2-init-原理" class="headerlink" title="2. init 原理:"></a>2. init 原理:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    return _objc_rootInit(self);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">id _objc_rootInit(id obj) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; In practice, it will be hard to rely on this function.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; Many classes do not properly chain -init calls.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    return obj;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>至于 <code>init</code> 方法就相对简单了, 因为他什么都没有做, 只是 返回了 self。<code>init</code> 方法之所以这样实现其实是为了提供 <strong>工厂设计模式</strong> 下的接口方法, 给子类去自定义重写该方法。</p><p>谈到 <code>init</code> , 我们会想起在日常写代码中用到的 <code>self = [super init]</code> , 那么我们为什么要这样写呢 ? 结合自己的想法 和 网上找到的意见我总结出一下几点:</p><blockquote><ol><li>想要确定父类在初始化中是否失败或者直接返回 nil</li><li>父类有可能不是去返回self, 而是去返回另外一个不同的对象。这种情况我们可能很少见, 在苹果的 <code>Foundation</code> 框架中存在一种设计模式 <strong><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html#//apple_ref/doc/uid/TP40010810-CH4-SW1" target="_blank" rel="noopener">类集群(类簇)</a></strong> , 该模式下就存在这种情况。(扩展: <a href="http://blog.sunnyxx.com/2014/12/18/class-cluster/" target="_blank" rel="noopener">有关类簇的探讨</a>)</li><li>单例对象, 假如父类是单例的话这里的返回同样会出问题</li></ol></blockquote><h4 id="3-New-方法"><a href="#3-New-方法" class="headerlink" title="3. New 方法:"></a>3. New 方法:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">+ (id)new &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    return [callAlloc(self, false&#x2F;*checkNil*&#x2F;) init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>通过查看 <code>new</code> 方法的源码, 我们发现该方法总共做了两件事。首先通过 <code>callAlloc</code> 方法申请内存, 然后再去调用 <code>init</code> 方法, 其实就是对上面两个方法的整合。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语:"></a>结语:</h2><p>以上就是本人这段时间结合所学的东西进行的一些总结, 如果有错误和不足的地方欢迎大佬们纠正。 大家一起探讨, 共同进步 !!!</p><p><u><em>45°仰望天空, 做更好的自己~</em></u></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近这段时间在跟 &lt;a href=&quot;https://juejin.im/user/5c3f3c41518825
      
    
    </summary>
    
    
      <category term="iOS底层学习" scheme="https://yoursite.com/categories/iOS%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS探索" scheme="https://yoursite.com/tags/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>GitLab 学习</title>
    <link href="https://yoursite.com/2018-12-20-GitLab-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://yoursite.com/2018-12-20-GitLab-%E5%AD%A6%E4%B9%A0/</id>
    <published>2018-12-19T16:00:00.000Z</published>
    <updated>2019-12-21T12:48:34.206Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司的新项目部署到了gitlab上面, 鉴于之前一直在使用svn, 这里写篇文章记录下自己最近对于gitlab的相关学习。</p><h4 id="一-什么是Git"><a href="#一-什么是Git" class="headerlink" title="一. 什么是Git"></a>一. 什么是Git</h4><p>git就是一种 <strong>版本控制</strong> 工具, 说到版本控制, 我们可能想到了另外一个工具 svn。但是两者在本质上又有着区别。</p><p>首先, svn 是集中化的版本控制系统, 即只有一个单一的集中管理服务器, 用来保存所有文件的修订版本。 所有协同工作的人员都通过客户端连接到这台服务器, 进行最新文件的更新或者所修改文件的提交。</p><p>git 是分布式的版本控制系统, 没一个终端都是一个仓库。客户端不只是去提取最新版本文件的快照, 而是把原始的代码仓库完整的克隆到本地; 每一次的提取操作, 实际上都是一次对代码仓库的完整备份。</p><p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-1.png" alt></p><center>图1 集中式版本控制</center><p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-2.png" alt></p><center>图2 分布式管理控制</center><h4 id="二-GitLab基本使用"><a href="#二-GitLab基本使用" class="headerlink" title="二. GitLab基本使用"></a>二. GitLab基本使用</h4><h5 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h5><ul><li><p><strong>登录</strong></p><p>先说一下, 这个一般是布在内网服务器的, 就是去联系管理员去要账号。昨天同事问我gitlab有没有账号, 我敲了个gitlab的网址, 然后就傻乎乎的去注册了😂。 一顿操作猛如虎后领导给我了个内网的地址, 然后给了我一个账号(🙅‍♀️)… </p><p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-3.png" alt></p><center>图3 登录页面</center></li></ul><p>  登录页面如图三, 有两种不同的登录方式, 具体看公司给你的账号吧。最后一个tab是注册的, 我这里没有用到, 具体情况应该会有人告诉你的。</p><ul><li><p><strong>设置</strong></p><p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-4.png" alt></p></li></ul><center>图4 账号设置页面</center><p>​        账号设置页面, 可以补充一下自己的个人信息, 同时在  ‘Preferred language’ 项里面也可以设置自己的偏好语言(支持中文)。</p><h5 id="2-项目创建-和-用户管理"><a href="#2-项目创建-和-用户管理" class="headerlink" title="2. 项目创建 和 用户管理"></a>2. 项目创建 和 用户管理</h5><ul><li>项目管理<ol><li>新建项目</li><li>编辑或删除项目</li></ol></li><li>用户管理<ol><li>新建用户</li><li>编辑或删除用户</li><li>组管理</li><li>权限说明</li></ol></li></ul><p>*<em>注意: *</em>以上内容均为管理员操作内容, 由于本人没有权限, 也没有亲自操作过, 所以不做介绍。可以通过下面的链接进行了解(<a href="https://blog.csdn.net/Adelly/article/details/79099772#_Toc480656596" target="_blank" rel="noopener">GitLab使用教程</a>)。</p><h4 id="三-GitLab-使用配置"><a href="#三-GitLab-使用配置" class="headerlink" title="三. GitLab 使用配置"></a>三. GitLab 使用配置</h4><h5 id="1-配置SSH-key"><a href="#1-配置SSH-key" class="headerlink" title="1. 配置SSH-key"></a>1. 配置SSH-key</h5><p>git仓库之间代码的传输协议主要使用 ssh 协议。而一般搭建 gitlab 的时候使用的git用户是没有密码的, 因此直接 ssh 是不能登录的, 需要使用 ssh-key 上传公钥, 使用非对称加密传输。</p><ol><li>查看之前是否生成个 id_rsa.pub 文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"> ls (列举目录文件名, 查看目录是否有 id_rsa.pub 文件)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> 如果存在, 查看公钥: cat id_rsa.pub 或者 vim id_rsa.pub</span></pre></td></tr></table></figure><p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-5.png" alt></p><center>图5</center><p>效果如上图, 因为我之前已经生成过, 所以会有结果。如果你之前生成过, 执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span></pre></td></tr></table></figure><p>对你的 ssh-key 进行拷贝操作</p><ol start="2"><li>终端未出现id_rsa.pub 或 id_dsa.pub文件，表示该电脑还没有配置SSH Key, 继续输入以下命令:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#  -t 为指定加密方式为RSA， -C 为指定邮箱。命令完成后目录下会生成id_rsa(私钥)和id_rsa.pub（公钥）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span></pre></td></tr></table></figure><p>注意, 这里的 email 就用自己常用的邮箱即可。执行完以后不出意外文件就生成出来了, 中间可能会要求输入开机密码, 其余一直回车即可。生成的文件可以前往 ‘~/.ssh’ 该路径下面去找, 如果不确定, 可以回到第一步去验证一下。</p><ol start="3"><li>生成以后通过在步骤1对你的ssh-key进行过拷贝操作, 然后在gitlab网页上面依次点击 “头像-&gt; Settings -&gt; SSH Keys”</li></ol><p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-6.png" alt></p><center>图6</center><p>如图, 将步骤1拷贝的key直接粘贴到 ‘key’ 里面, 然后设置 ‘title’, 点击 Add Key 即可。</p><h4 id="四-GitLab使用"><a href="#四-GitLab使用" class="headerlink" title="四. GitLab使用"></a>四. GitLab使用</h4><h5 id="1-使用命令行工具"><a href="#1-使用命令行工具" class="headerlink" title="1. 使用命令行工具"></a>1. 使用命令行工具</h5><p>GitLab使用命令行工具通git, 这里不再描述了, 如果想要熟悉命令可以通过 <code>git --help</code> 指令查看。</p><h5 id="2-通过-SourceTree-图形化管理工具"><a href="#2-通过-SourceTree-图形化管理工具" class="headerlink" title="2. 通过 SourceTree 图形化管理工具"></a>2. 通过 SourceTree 图形化管理工具</h5><p>如果你不喜欢命令行的使用方式, 也可以使用 git 的图形化管理工具 SourceTree 进行统一管理, </p><p>界面如下图, 界面简洁, 使用也很方便。<a href="https://www.sourcetreeapp.com" target="_blank" rel="noopener">SourceTree官网</a></p><p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-7.png" alt></p><center>图 7</center><h5 id="3-使用-Xcode-进行git管理"><a href="#3-使用-Xcode-进行git管理" class="headerlink" title="3. 使用 Xcode 进行git管理"></a>3. 使用 Xcode 进行git管理</h5><p>如果你使用的是Mac, 并且开发使用xcode的话, 也可以通过xcode来对git进行统一管理。</p><p>具体步骤如下:</p><ol><li>打开Xcode, 选择 <code>Clone an existing project</code> :</li></ol><p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-8.png" alt></p><center>图 8</center><p>​    </p><ol start="2"><li>接下来弹出的窗口需要你输入所要 clone 的项目的 URL, 将自己的项目地址 copy 进去即可:</li></ol><p><img src="/images/GitLab-%E5%AD%A6%E4%B9%A0-9.png" alt></p><center>图 9</center><p>点击 <code>Clone</code> 按钮进行克隆, 弹出选择你需要克隆的分支, 这个根据需要自行选择就好, 然后一直点下去会出现让你登录用户名的对话框。输入登录名和密码, 成功。</p><ol start="3"><li>接下来就是通过 <code>xcode</code> 对自己的代码进行 更新和提交操作。可以通过 xcode 工具栏上方的 </li></ol><p><code>Source Control -&gt; Commit/Pull/Push</code> 来进行, 需要注意的是, 在进行 pull 和 push 操作时一定要注意当前分支, 然后在 push 的时候最好对自己的提交内容进行详细说明, 这也是团队合作所必要的。</p><p>*<em>结语: *</em>上面这些就是我今天所学习的 GitLab 相关的内容, 可能不是很全面, 在后续的使用过程中有可能会遇到更多的问题需要补充。仅此以记录自己的学习情况, 不喜勿喷😀<del>~</del></p><p><em>Be a better yourself !!!</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近公司的新项目部署到了gitlab上面, 鉴于之前一直在使用svn, 这里写篇文章记录下自己最近对于gitlab的相关学习。&lt;/p&gt;
&lt;h4 id=&quot;一-什么是Git&quot;&gt;&lt;a href=&quot;#一-什么是Git&quot; class=&quot;headerlink&quot; title=&quot;一. 什么
      
    
    </summary>
    
    
      <category term="工具" scheme="https://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>内存管理之内存管理方式(二)</title>
    <link href="https://yoursite.com/2017-06-10-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F(%E4%BA%8C)/"/>
    <id>https://yoursite.com/2017-06-10-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F(%E4%BA%8C)/</id>
    <published>2017-06-09T16:00:00.000Z</published>
    <updated>2019-12-18T06:07:58.812Z</updated>
    
    <content type="html"><![CDATA[<p>之前一篇文章介绍了一下内存区域的划分以及平时我们程序中涉及到的一些变量常量等的存储方式, 下面主要是去整理一下有关内存的管理方式(手动内存管理 和 自动内存管理)和 property 参数方面的知识。提到管理方式, 首先不得不去说一下 引用计数的概念:</p><h4 id="1-引用计数的概念-Reference-Count"><a href="#1-引用计数的概念-Reference-Count" class="headerlink" title="1. 引用计数的概念 (Reference Count)"></a>1. 引用计数的概念 (Reference Count)</h4><p><code>引用计数</code> 即 Objective-C 管理对象生命周期的方式, 当我们创建一个对象时, 初始的引用计数为1, 为了保证对象一直存在, 每当引用该对象时, 会通过向其发送 retain 消息使引用计数 +1, 当不再需要该对象时会去发送 release 消息使其引用计数 -1, 当对象的引用计数为 0 时, 系统会通过给对象发送 dealloc 消息销毁对象并回收内存。</p><p>*<em>注意: *</em>在MRC下, 这里当我们使用完一个对象没有进行release操作时, 此时对象的引用计数会永远大于1, 该对象就会一直占有内存空间无法释放, 从而造成<code>内存泄漏</code>。当<code>内存泄漏</code>到一定程度的话就有可能<code>内存溢出</code>, 进而导致程序崩溃。</p><table><thead><tr><th align="center">对象操作</th><th align="center">Objective-C方法</th><th align="center">对应操作结果</th></tr></thead><tbody><tr><td align="center">生成并持有对象</td><td align="center">alloc, new, copy, mutableCopy 等方法</td><td align="center">生成对象并设置引用计数为1</td></tr><tr><td align="center">持有对象</td><td align="center">retain</td><td align="center">使对象的引用计数 +1</td></tr><tr><td align="center">释放对象</td><td align="center">release</td><td align="center">使对象的引用计数 -1</td></tr><tr><td align="center">销毁对象</td><td align="center">dealloc方法 — 系统调用</td><td align="center">对象的引用计数为 0 时调用</td></tr></tbody></table><h4 id="2-手动引用计数-MRC-Manual-Reference-Count"><a href="#2-手动引用计数-MRC-Manual-Reference-Count" class="headerlink" title="2. 手动引用计数(MRC / Manual Reference Count)"></a>2. 手动引用计数(MRC / Manual Reference Count)</h4><p><code>手动引用计数</code> 即引用计数的管理是由我们自己通过对对象的 retain / release 等操作去完成的, 需要我们自己去跟踪对象来明确的管理内存。</p><h5 id="2-1-alloc-new-copy-mutableCopy"><a href="#2-1-alloc-new-copy-mutableCopy" class="headerlink" title="2.1 alloc / new / copy / mutableCopy"></a>2.1 alloc / new / copy / mutableCopy</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSMutableArray *array &#x3D; [[NSMutableArray alloc] init]; &#x2F;&#x2F; 创建对象 array</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%p&quot;, array);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[array release];&#x2F;&#x2F; 释放 array</span></pre></td></tr></table></figure><p>以上第一行我们通过 alloc 去创建数组对象 array, 此时对象的引用计数为1, 然后我们对其指针进行打印。打印完成以后我们不需要此对象了, 就去调用 release 方法使其引用计数 -1, 此时对象的引用计数为 0, 会触发 dealloc 方法对其进行回收操作。然后如果我们再去访问 array对象, 就可能发生崩溃。</p><h5 id="2-2-retain-操作"><a href="#2-2-retain-操作" class="headerlink" title="2.2 retain 操作"></a>2.2 retain 操作</h5><h6 id="2-2-1-retain-与-属性"><a href="#2-2-1-retain-与-属性" class="headerlink" title="2.2.1 retain 与 属性"></a>2.2.1 retain 与 属性</h6><p>我们可以通过属性来保存一个对象, 我们可以通过属性的实例变量和存取方法来对某个对象进行操作, 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (void)setPerson:(Person *)person &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    [person retain];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    [_person release];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    _person &#x3D; person;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>以上方法中, 我们通过先 retain 新值, 然后 release 旧值的操作, 打到给我们的属性更新值的目的。需要注意的是: 需要首先去 retain 新值, 因为如果新值 和 旧值是同一个对象的话, 如果我们先调用 release 方法就有可能导致对象被释放掉, 那样再去调用 retain 就没有意义了。再如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, retain)Person *person;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">@end</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">[super viewDidLoad];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 实力变量持有 Person 类对象, 这样赋值不会调用 set 方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    _person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    self.person &#x3D; _person;&#x2F;&#x2F; 调用 set 方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">- (void)setPerson:(Person *)person &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; release 释放对象, _person对象的引用计数值为0, 对象会被系统回收</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    [_person release];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 由于对象已经被回收, 再去 retain 就容易出问题</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    _person &#x3D; person;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">@end</span></pre></td></tr></table></figure><p>由于对象对应的内存已经被系统回收, 如果该块内存还没有被覆盖, 那么 该对象会可以使用, 如果内存已经被覆盖, 那么就会指向一个被覆盖了的位置对象, 此实例变量就会变成一个<code>悬挂指针</code>。</p><h6 id="2-2-2-retain-与-数组"><a href="#2-2-2-retain-与-数组" class="headerlink" title="2.2.2 retain 与 数组"></a>2.2.2 retain 与 数组</h6><p>如果我们将一个对象加入到一个数组中去, 该数组的 addObject 方法同样会对该对象做 retain 操作, 比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先创建对象 person</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建数组 array</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">NSMutableArray *array &#x3D; [[NSMutableArray alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将person对象添加到array数组当中</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">[array addObject:person];&#x2F;&#x2F; 此时 person 的引用计数为2</span></pre></td></tr></table></figure><h5 id="2-3-release-操作"><a href="#2-3-release-操作" class="headerlink" title="2.3 release 操作"></a>2.3 release 操作</h5><h6 id="2-3-1-释放自己持有的对象"><a href="#2-3-1-释放自己持有的对象" class="headerlink" title="2.3.1 释放自己持有的对象"></a>2.3.1 释放自己持有的对象</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建 array 对象</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">NSArray *array &#x3D; [[NSArray alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 释放</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">[array release];</span></pre></td></tr></table></figure><h6 id="2-3-2-过度释放对象问题"><a href="#2-3-2-过度释放对象问题" class="headerlink" title="2.3.2 过度释放对象问题"></a>2.3.2 过度释放对象问题</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建 array 对象</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">NSArray *array &#x3D; [[NSArray alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 释放</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">[array release];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 再释放</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">[array release];&#x2F;&#x2F; 过度释放</span></pre></td></tr></table></figure><h5 id="2-4-autorelease"><a href="#2-4-autorelease" class="headerlink" title="2.4. autorelease"></a>2.4. autorelease</h5><p><code>autorelease</code> 指的是自动释放操作, 当一个对象收到 autorelease 消息的时候, 该对象就会被注册到当前处于栈顶的自动释放池(autorelease pool)。如果没有主动生成自动释放池, 则当前自动释放池对应的是主运行循环的自动释放池。当前线程的RunLoop进入休眠之前, 就回对被注册到该自动释放池的所有对象进行一次 release 操作。</p><p>autorelease 和 release 的主要区别就是: release 会立马对对象发送消息, autorelease则是延迟发送。</p><p>autorelease 通常运用在当调用某个方法需要返回对象的情况下, 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">+ (id)person &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 初始化需要返回的person对象</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    Person *person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; [person release];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    [person autorelease];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    return person;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>很显然这里是不能进行<code>release</code>操作的, 因为如果对象还没有返回就被 release 的话就没有意义了。通过使用 autorelease方法, 将对象的释放注册到自动释放池中区, 可以延长对象的生命周期, 使其在 autorelease pool 结束前一直能够使用。</p><p>另外, 因为我们已经将该对象放入了自动释放池中, 就不需要再次对其release操作了, 如果有别的对象需要持有该对象, 只需要再次对其 retain 操作就好了, 使用完以后注意 release。</p><h5 id="2-5-autorelea-pool-自动释放池"><a href="#2-5-autorelea-pool-自动释放池" class="headerlink" title="2.5. autorelea pool(自动释放池)"></a>2.5. autorelea pool(自动释放池)</h5><h6 id="2-5-1-autorelease-pool-和-RunLoop"><a href="#2-5-1-autorelease-pool-和-RunLoop" class="headerlink" title="2.5.1 autorelease pool 和 RunLoop"></a>2.5.1 autorelease pool 和 RunLoop</h6><p>每条线程都包含一个与其对应的自动释放池, 当某条线程被终止的时候, 对应线程的自动释放池也会被销毁。同时, 处于该自动释放池中的对象也会做一次 release 操作。</p><p>当应用程序启动时, 系统会默认开启一条线程(主线程), 主线程也有一个与之对应的自动释放池, 例如: ARC 下 main 文件中的 autoreleasepool。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    return UIApplication(argc, argv, nil, NSStringFromClass([APPDelegate class]));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>该自动释放池用来释放在主线程下注册到该自动释放池的对象。需要注意的是, 当我们开启一条子线程, 并且在该线程开启 RunLoop 的时候, 需要为其增加一个 autoreleasepool, 这样有助于保证内存的安全。</p><h6 id="2-5-2-autorelease-pool-和-降低内存峰值"><a href="#2-5-2-autorelease-pool-和-降低内存峰值" class="headerlink" title="2.5.2 autorelease pool 和 降低内存峰值"></a>2.5.2 autorelease pool 和 降低内存峰值</h6><p>当我们执行一些复杂操作的时候, 特别是如果这些复杂的操作要被循环执行, 那么中间免不了会产生一些临时的变量。当被加到主线程自动释放池的对象越来越多, 却没有及时释放时, 就会导致内存溢出。这个时候, 我们可以通过手动添加自动释放池来解决这个问题。如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 创建自动释放池</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    NSAutoreleasePool *pool &#x3D; [[NSAutoreleasePool alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 生成对象</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    id obj &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    [pool drain];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>在for循环中我们会循环很多次, 每次都会去生成新的对象, 因为生成的对象会在for循环结束以后才回去释放, 这样会有可能生成过多的对象。我们通过手动生成一个自动释放池, 每次在循环结束前就把对象释放掉, 这样就可以有效的降低内存的峰值。</p><h4 id="3-自动引用计数-ARC-Automatic-Reference-Counting"><a href="#3-自动引用计数-ARC-Automatic-Reference-Counting" class="headerlink" title="3. 自动引用计数 (ARC / Automatic Reference Counting)"></a>3. 自动引用计数 (ARC / Automatic Reference Counting)</h4><p><code>自动引用计数</code> 即一般情况下, 引用计数的管理是系统帮我们去做的, 所以在ARC下要比MRC下更方便的管理内存。</p><h5 id="3-1-strong"><a href="#3-1-strong" class="headerlink" title="3.1. __strong"></a>3.1. __strong</h5><p>在 ARC 模式下, id类型 和 OC 对象的所有权修饰符默认是 __strong修饰的, 当该变量超出其作用域以后就会被释放掉, 同时对应的值也会被释放掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 创建对象 person </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    Person *person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 超出作用域, person对象将会被释放掉</span></pre></td></tr></table></figure><p>由此可以看出, 在ARC下, 我们不需要去管理对象的引用计数(进行 retain 或者 release操作), 系统会帮我们去处理对象的生命周期。</p><h6 id="3-1-1-stong声明属性"><a href="#3-1-1-stong声明属性" class="headerlink" title="3.1.1 stong声明属性"></a>3.1.1 stong声明属性</h6><p>如果一个属性的修饰符是 strong 类型, 编译器会在类的 dealloc 方法中添加释放对象的方法, 不需要我们手动的去处理了, 但是如果有如 CoreFoundation 等非OC对象, 则需要我们去手动的回收对象, 如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (void)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    CFRelease(_cfObject);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">在ARC下, dealloc方法一般用来执行两个任务。一个是用来 手动的释放掉非OC对象(类似上面), 另一个就是去解除监听。另外, 我们不能在ARC下去主动调用 dealloc 方法, 因为 dealloc 的对象就不再有效, 该方法是由系统在 运行时 根据何时的时机去调用的。</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一篇文章介绍了一下内存区域的划分以及平时我们程序中涉及到的一些变量常量等的存储方式, 下面主要是去整理一下有关内存的管理方式(手动内存管理 和 自动内存管理)和 property 参数方面的知识。提到管理方式, 首先不得不去说一下 引用计数的概念:&lt;/p&gt;
&lt;h4 id
      
    
    </summary>
    
    
      <category term="知识点" scheme="https://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="内存管理" scheme="https://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>内存管理之内存区域划分(一)</title>
    <link href="https://yoursite.com/2017-05-17-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86(%E4%B8%80)/"/>
    <id>https://yoursite.com/2017-05-17-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86(%E4%B8%80)/</id>
    <published>2017-05-16T16:00:00.000Z</published>
    <updated>2018-07-03T11:33:25.463Z</updated>
    
    <content type="html"><![CDATA[<p>最近在重新回过头去看内存管理方面的知识, 一方面去试着总结一下相关的东西吧, 另一方面也是想通过去试着自己去写一下然后使自己的知识掌握更加牢固, 下面是我将内存管理整个的层次划分, 以后的内容会相继的一一补上去:</p><p><img src="/.com//yujialei/Documents/%E4%B8%B4%E6%97%B6%E6%88%AA%E5%9B%BE/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%92%E5%88%86.png" alt="内存管理划分"></p><h4 id="1-区域划分"><a href="#1-区域划分" class="headerlink" title="1.区域划分"></a>1.区域划分</h4><ul><li><p>栈区(stack): 由编译器自动分配和释放, 存放函数的参数值和局部变量的值等。 栈为系统数据机构, 对于的 线程/进程 是唯一的。</p><p>优点是快速高效, 缺点为数据不够灵活(先进后出原则)</p></li><li><p>堆区(heap): 由程序员分配和释放, 如果程序员不释放, 在程序结束时, 可能会被系统回收, 比如在 iOS 中 alloc 都是存放在堆中的。</p><p>优点是灵活方便, 数据适应面广, 但是效率有一定降低。</p><p>堆是向高地址扩展的数据结构, 不连续的内存区域。系统用链表存储空闲地址, 链表遍历由低向高, 堆的大小直接受设备有效虚拟内存影响。</p></li></ul><ul><li><p>全局区(静态区)(static): 静态变量和全局变量是存储在意起的, 初始化的全局变量和静态变量存储的一块区域 (初始化全局区: BSS段), 未初始化的全局变量和静态变量在相邻的另一块区域存储(未初始化全局区: Data段), 程序结束后会系统释放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">int a; &#x2F;&#x2F; 未初始化的静态区</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">int b &#x3D; 1; &#x2F;&#x2F; 初始化的静态区</span></pre></td></tr></table></figure></li><li><p>文字常量区: 存放常量字符串, 程序结束后由系统释放</p></li><li><p>代码区: 存放函数的二进制代码</p></li></ul><h4 id="2-申请后的响应"><a href="#2-申请后的响应" class="headerlink" title="2.申请后的响应"></a>2.申请后的响应</h4><ul><li><p>栈</p><blockquote><p>存储每一个函数的时候都会向操作系统索要资源, 栈区就是函数运行时的内存, 栈区中的变量由编译器负责分配和释放, 内存随着函数的运行进行分配, 随着函数的结束而释放, 由系统自动完成。</p><p>注意: 如果栈的剩余空间大于所申请空间, 系统将为程序提供内存, 否则将会报异常提示栈溢出。</p></blockquote></li><li><p>堆</p><blockquote><ol><li>首先应该知道操作系统有一个记录空闲内存地址的链表。</li><li>当系统收到程序的申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆结点, 然后将该结点从空闲结点链表中删除</li><li>由于找到的堆结点的大小不一定刚好等于申请的大小, 系统会自动的将多余的部分重新放入到空闲链表中</li></ol></blockquote></li></ul><h4 id="3-申请大小的限制"><a href="#3-申请大小的限制" class="headerlink" title="3.申请大小的限制"></a>3.申请大小的限制</h4><ol><li><p>栈: 栈是向低地址扩展的数据结构, 是一块连续的内存区域。栈顶的地址和栈的最大容量是由系统预先规定好的, 栈的大小为2M (有的说1M, 总之是一个编译时就确定的常数), 如果申请的空间超过栈的剩余空间, 会提示 overFlow。因此, 能从栈获得的空间较小。</p></li><li><p>堆: 堆是向高地址扩展的数据结构, 是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的, 自然是不连续的, 而链表的遍历方向是由低到高的。堆的大小受限于系统中的有效虚拟内存。由此可见, 堆获得的空间比较灵活, 也相对较大。</p></li><li><p>栈: 由系统自动分配, 速度较快, 不会产生内存碎片</p></li><li><p>堆: alloc 分配, 速度较慢, 容易产生内存碎片, 使用方便</p></li></ol><h4 id="4-下面通过对字符串的初始化-来分析内存分布情况"><a href="#4-下面通过对字符串的初始化-来分析内存分布情况" class="headerlink" title="4.下面通过对字符串的初始化, 来分析内存分布情况"></a>4.下面通过对字符串的初始化, 来分析内存分布情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSString *str0 &#x3D; @&quot;123&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   NSLog(@&quot;str0 &#x3D; %p, str0 &#x3D; %@&quot;, str0, str0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   NSString *str1 &#x3D; @&quot;123&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   NSLog(@&quot;str1 &#x3D; %p, str1 &#x3D; %@&quot;, str1, str1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   NSString *str2 &#x3D; @&quot;456&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">   NSLog(@&quot;str2 &#x3D; %p, str2 &#x3D; %@&quot;, str2, str2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">   NSLog(@&quot;-----------------------------------&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">   NSString *str3 &#x3D; [[NSString alloc] initWithFormat:@&quot;123&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">   NSLog(@&quot;str3 &#x3D; %p, str3 &#x3D; %@&quot;, str3, str3);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">   NSString *str4 &#x3D; [[NSString alloc] initWithFormat:@&quot;123&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">   NSLog(@&quot;str4 &#x3D; %p, str4 &#x3D; %@&quot;, str4, str4);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">   NSString *str5 &#x3D; [[NSString alloc] initWithFormat:@&quot;456&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">   NSLog(@&quot;str5 &#x3D; %p, str5 &#x3D; %@&quot;, str5, str5);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">   NSLog(@&quot;-----------------------------------&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">   NSString *str6 &#x3D; [[NSString alloc] initWithString:str3];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">   NSLog(@&quot;str6 &#x3D; %p, str6 &#x3D; %@&quot;, str6, str6);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">   NSString *str7 &#x3D; [[NSString alloc] initWithString:str3];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">   NSLog(@&quot;str7 &#x3D; %p, str7 &#x3D; %@&quot;, str7, str7);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">   NSString *str8 &#x3D; [[NSString alloc] initWithString:str4];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">   NSLog(@&quot;str8 &#x3D; %p, str8 &#x3D; %@&quot;, str8, str8);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">   NSString *str9 &#x3D; [[NSString alloc] initWithString:str5];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">   NSLog(@&quot;str9 &#x3D; %p, str9 &#x3D; %@&quot;, str9, str9);</span></pre></td></tr></table></figure><p>打印结果如下图:</p><p> <img src="http://p9y1zwo62.bkt.clouddn.com/%E5%8F%98%E9%87%8F%E5%9C%B0%E5%9D%80%E6%8E%A2%E7%A9%B6.png" alt="内存地址打印结果"></p><p>根据打印的结果可以看出:</p><ol><li>首先 @”123” 和 @”456” 为字符串常量, 被分配到了常量区, 然后 str0 和 str1 同时指向了常量 @”123”, 所以 str0 和 str1 的指针是一样的。至于 str0 和 str2 所指向的是2个不同的常量, 所以指针地址是不一样的。</li><li>str3 所指向的是一个 alloc 出来的对象, 这个对象是被分配在堆内存中的, 所以 str3 与上面的 str0 和 str1 所对应的指针是不一样的。str4 也指向了一个 alloc 出来的对象, 这个对象也是分配在堆内存的, 由于 iOS 系统对字符串内存的优化 (如果一个字符串是通过字符串常量初始化而来, 那么这个字符串里面的值可以直接从常量区拿, 这样就不需要为每一个堆上面的字符串分配新的内存。) </li><li>Str6 和 str7 都是指向堆上面的内存, 并且是通过变量初始化来的, 和 str3, str4 同理。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在重新回过头去看内存管理方面的知识, 一方面去试着总结一下相关的东西吧, 另一方面也是想通过去试着自己去写一下然后使自己的知识掌握更加牢固, 下面是我将内存管理整个的层次划分, 以后的内容会相继的一一补上去:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/.com//yujial
      
    
    </summary>
    
    
      <category term="知识点" scheme="https://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="内存管理" scheme="https://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试知识总结_功能区分</title>
    <link href="https://yoursite.com/2017-05-11-iOS%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93(2)_%E5%8A%9F%E8%83%BD%E5%8C%BA%E5%88%86/"/>
    <id>https://yoursite.com/2017-05-11-iOS%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93(2)_%E5%8A%9F%E8%83%BD%E5%8C%BA%E5%88%86/</id>
    <published>2017-05-10T16:00:00.000Z</published>
    <updated>2019-12-18T05:55:11.431Z</updated>
    
    <content type="html"><![CDATA[<p>本次内容主要是为了区分一些相似的内容或者功能的概念, 加深一下自己对这些内容的理解, 避免混淆:</p><h4 id="1-面向过程-和-面向对象"><a href="#1-面向过程-和-面向对象" class="headerlink" title="1. 面向过程 和 面向对象"></a>1. 面向过程 和 面向对象</h4><p><code>面向过程</code>: 以事件为核心, 各功能的实现是按照事件的先后顺序或者因果关系展开的。</p><p><code>面向对象</code>: 以对象为核心, 以事件为驱动, 将个功能模块化, 彼此之间相互独立互不影响。</p><h4 id="2-MVC-和-MVVM"><a href="#2-MVC-和-MVVM" class="headerlink" title="2. MVC 和 MVVM"></a>2. MVC 和 MVVM</h4><p><code>MVC弊端:</code> Controller 去负责 Model 与 View 的关联, 造成 View 与 Model 的耦合度较高, 而且 Controller 会比较的庞大复杂。</p><p><code>MVVM有点</code>: (需要后续…)</p><ol><li>低耦合, View 可以独立于 Model 变化和修改, ViewModel可以绑定到不同的View上, 当View变化的时候Model可以不变, 当 Model变化的时候View也可以不变</li><li>可重用性, 可以把一些视图的逻辑放在 ViewModel 里面, 让很多 View 重用这段视图逻辑</li><li>独立开发, 开发人员可以专注于业务逻辑和数据的开发(ViewModel), 设计人员可以专注于界面(View)的设计。</li><li>可测试性, 可以针对 ViewModel 来对界面(View)进行测试</li></ol><h4 id="3-MRC-和-ARC-内存管理"><a href="#3-MRC-和-ARC-内存管理" class="headerlink" title="3. MRC 和 ARC 内存管理"></a>3. MRC 和 ARC 内存管理</h4><p>iOS 5.0 以后ARC(Automatic Reference Counting)出现, 减少了代码, 省去了对象释放的麻烦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ARC中加入MRC</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">target-&gt;build phase-&gt;compbile source, 添加 -fon-objc-arc</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MRC中加入ARC</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">target-&gt;build phase-&gt;compbile source, 添加 -fobjc-arc</span></pre></td></tr></table></figure><p>iOS 通过引用计数来记录对象的引用, 每次 runloop 完成一次循环的时候, 都会检查对象的retainCount, 如果说对象的retainCount为0, 说明该对象没有地方需要引用了, 就可以释放掉了。</p><h4 id="4-深拷贝-和-浅拷贝"><a href="#4-深拷贝-和-浅拷贝" class="headerlink" title="4. 深拷贝 和 浅拷贝"></a>4. 深拷贝 和 浅拷贝</h4><p><code>浅拷贝:</code> 指针拷贝, 不会增加新的内存, 只是增加一个指针指向原对象的内存区域。</p><p><code>深拷贝:</code> 内容拷贝, 同时拷贝指针和内存, 会同时增加指针和内存。</p><p><code>拷贝的条件:</code> 并非所有的对象都支持 copy 和 mutableCopy, 只有遵循了 NSCopy 协议或者NSMutableCopy 协议的类才行。如果遵循这两个协议就必须分别实现 copyWithZone 和 mutableCopyWithZone 方法。</p><p><code>拷贝原则:</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1. 非容器类: 像NSString、NSNumber这些系统类的不可变对象调用copy的话是浅拷贝, 调用mutableCopy是深拷贝并且拷贝的对象为可变对象; 可变对象的话无论调用 copy 或者 mutableCopy 都为深拷贝, 区别在于copy返回的是不可变对象而mutableCopy返回的是可变对象</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2. 容器类: 像NSArray、NSMutableArray等不可变对象调用copy属于浅拷贝, 调用mutableCopy为深拷贝得到可变对象, 可变对象调用copy或者mutableCopy的情况与非容器类相同。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">3. 自定义类: 我们自定义一个类并且实现NSCopy协议, 根据我们实现的拷贝协议的不同, 拷贝的结果也是不同的。如果在协议方法中直接返回对象的 self 就相当于浅拷贝, 如果返回的是一个创建的对象的话就属于深拷贝。</span></pre></td></tr></table></figure><h4 id="5-关于-strong-和-weak"><a href="#5-关于-strong-和-weak" class="headerlink" title="5. 关于 strong 和 weak"></a>5. 关于 strong 和 weak</h4><ol><li>strong: 强引用, strong类型的指针指向的对象不会被释放</li><li>weak: 弱引用, 无法阻止对象的释放, 如果一个对象没有被强引用指针指向, 不管有多少weak指向都无法阻止该对象被释放。</li></ol><h4 id="6-区分-include、-import-和-class"><a href="#6-区分-include、-import-和-class" class="headerlink" title="6. 区分 #include、#import 和 @class"></a>6. 区分 #include、#import 和 @class</h4><ul><li><code>#include</code> </li></ul><p>一般在导入 C / C++ 头文件时用 #include, include相当于拷贝文件中的内容, 多次使用的话会提示重复定义的错误。比如, classA 和 classB 都引入了 classC, 如果 classD 同时引用 classA 和 classB 的话, 就会有重复引用的错误。</p><ul><li><code>#import</code> </li></ul><p>我们在导入 Objective-C 的头文件时用到的, 不会产生重复定义的错误提示, 因为它只会做一次判断, 如果已经导入过的话就不会再去做导入了。</p><ul><li><code>@class</code></li></ul><p>@class 仅仅是对类的一个声明, 只是用来告诉编译器有这么一个类, 至于类的具体实现是不知道的,</p><p>另外@class的由于不会关注其实现, 编译速度相对来说比较快</p><p>此外@class还可以解决循环依赖的问题, 例如 A导入了B, B又导入了A, 但是每一个头文件的编译都需要让对方先编译成功才行, 这样就产生了循环依赖问题。所以一般在头文件里面我们使用 @class 来声明类的名称, 然后在实现类里面用 #import 来包含这个被引用的类的头文件, 这样就可以获取到类的内部变量和方法了。</p><p>*<em>注意: *</em> #impor&lt; &gt; 和 #import” “ 的区别, 前者用来包含 iOS 框架类库里面的类, 后者用来包含自定义的类。</p><h4 id="7-区分UDID与UUID"><a href="#7-区分UDID与UUID" class="headerlink" title="7.区分UDID与UUID"></a>7.区分UDID与UUID</h4><p><strong>UDID (Unique Device Identifier)</strong> 用户设备唯一编码</p><p>UDID是一串由40位16进制组成的字符串, 用以标识唯一的设备。苹果从iOS5开始就移除了通过代码访问UDID的权限, 所以我们无法从代码中获取用户设备的UDID。如果我们想查看自己设备的UDID, 可以通过 iTunes 来查看。通常我们在增加 Provisioning Profile 文件时会用到。</p><p><strong>UUID (Universally Unique IDentifier)</strong> 通用唯一识别符</p><p>UUID 是一个32位的十六进制序列, 使用小横线来连接: 8-4-4-4-12。它是一种应用加设备绑定产生的标识符。当在设备上安装来自同一个供应商的不同App时, 此值保持不变。如果你删除了来自某个供应商的所有app, 再重新安装时, 此值会改变。获取UUID:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSString *uuidString &#x3D; [[[UIDevice currentDevice] identifierForVendor] UUIDString];</span></pre></td></tr></table></figure><h4 id="8-区分nil、Nil、NULL、NSNUll"><a href="#8-区分nil、Nil、NULL、NSNUll" class="headerlink" title="8.区分nil、Nil、NULL、NSNUll"></a>8.区分nil、Nil、NULL、NSNUll</h4><ol><li><p>nil</p><p>nil一般是指把一个对象置空, 既完全是一个空对象, 完全从内存中释放。</p></li><li><p>Nil</p><p>Nil 与 nil 基本没有任何区别, 也可以说只要是可以使用 nil 的地方都可以使用Nil, 反之亦然。但是我们应该更加严谨一些, nil 标识置空一个对象, 而 Nil 表示置空一个类。</p></li><li><p>NULL</p><p>NULL 源于 C语言, 表示一个空指针, 即: int *p = NULL</p></li><li><p>NSNull</p><p>NSNull是继承于 NSObject 的对象, 它和nil的区别在于, nil 是把对象完全释放掉了, 完全从内存中释放。当我们想要把对象置空又想要一个容器的时候, 我们可以使用NSNull。</p></li></ol><h4 id="9-区分类目与扩展"><a href="#9-区分类目与扩展" class="headerlink" title="9.区分类目与扩展"></a>9.区分类目与扩展</h4><p>类目: category 为已知的类增加新的方法</p><p>1.类目中扩展的方法会被子类继承</p><p>2.增加原有类的方法, 而且是可以增加多个类目将大的功能划分为小功能</p><p>3.类目中的方法会比原有类中的方法具有更高的优先级。所以不能和原有类方法重名, 不然就会覆盖原有方法。</p><p>4.类目只能添加方法, 不能添加变量</p><p>扩展: 即延展, 一般是在类的实现文件中, 给当前类添加私有变量和私有方法, 添加的方法是必须实现的。</p><h4 id="10-区分-TCP-和-UDP"><a href="#10-区分-TCP-和-UDP" class="headerlink" title="10.区分 TCP 和 UDP"></a>10.区分 TCP 和 UDP</h4><p>TCP: 面向连接、传输可靠(保证数据正确性, 保证数据顺序传输)、用于传输大量数据(流模式)、速度慢, 建立连接需要开销较多(时间, 系统资源)。</p><p>UDP: 面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快, 传输的是报文。</p><h4 id="11-区分HTTP与Socket"><a href="#11-区分HTTP与Socket" class="headerlink" title="11.区分HTTP与Socket"></a>11.区分HTTP与Socket</h4><p>HTTP请求: 客户端主动发起请求, 服务器才能给与响应, 一次请求完毕后断开连接, 节省资源。</p><p>Socket: 客户端与服务的直接使用socket套接字连接, 双方保持连接通道, 都可以主动发送数据, 适合游戏或者股票等即时性很强的要求。主要使用的类是CFSocketRef。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本次内容主要是为了区分一些相似的内容或者功能的概念, 加深一下自己对这些内容的理解, 避免混淆:&lt;/p&gt;
&lt;h4 id=&quot;1-面向过程-和-面向对象&quot;&gt;&lt;a href=&quot;#1-面向过程-和-面向对象&quot; class=&quot;headerlink&quot; title=&quot;1. 面向过程 和 
      
    
    </summary>
    
    
      <category term="知识点" scheme="https://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="iOS" scheme="https://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试知识总结_基本概念</title>
    <link href="https://yoursite.com/2017-05-04-iOS%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93_%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>https://yoursite.com/2017-05-04-iOS%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93_%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2017-05-03T16:00:00.000Z</published>
    <updated>2019-12-03T03:21:54.209Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iOS面试知识总结-基本概念"><a href="#iOS面试知识总结-基本概念" class="headerlink" title="iOS面试知识总结_基本概念"></a><center>iOS面试知识总结_基本概念</center></h3><p><strong>前言:</strong> 经过这几天的面试发现, 虽然在实际的开发中做过许多的项目, 但是也会被一个自己认为很普通的问题问住。因此意识到虽然在平时能够做到会用这些知识去开发, 但是却很难将我们平时用到的知识很好的表述出来, 所以我决定将一些比较常用的知识点总结出来。一方面有助于面试, 同时也有助于闲暇之余对知识点的回顾。</p><h4 id="1-iOS开发者账号类型"><a href="#1-iOS开发者账号类型" class="headerlink" title="1.iOS开发者账号类型"></a>1.iOS开发者账号类型</h4><table><thead><tr><th>账号类型</th><th>协作人数</th><th>其它</th></tr></thead><tbody><tr><td>个人账号(individual)</td><td>1人</td><td>99美元一年, 允许上架 App Store, 最多支持 100个 UUID</td></tr><tr><td>公司账号(company)</td><td>多人协作</td><td>99美元一年, 允许上架 App Store, 最多支持 100个 UUID</td></tr><tr><td>企业账号(enterprise)</td><td>多人</td><td>299美元一年, 不允许上架 App Store, UUID 无限制</td></tr></tbody></table><ol><li>个人开发者账号可以申请升级为 公司账号, 可以通过拨打苹果公司客服电话 (400 6701 855) 来咨询办理</li><li>公司账号允许多个开发者进行写作开发, 比个人多一些账号管理设置, 可以设置多个 apple ID, 分4种管理级别权限。申请公司账号需要填写公司的邓白氏编码 (DUNS)</li><li>需要注意的是, 企业账号不能发布到 App Store, 适合那些不希望公开发布应用的企业, 申请时也需要邓白氏编码。</li></ol><h4 id="2-了解沙盒的目录结构"><a href="#2-了解沙盒的目录结构" class="headerlink" title="2.了解沙盒的目录结构"></a>2.了解沙盒的目录结构</h4><p><img src="/.com//yujialei/Documents/%E4%B8%B4%E6%97%B6%E6%88%AA%E5%9B%BE/%E6%B2%99%E7%9B%92%E7%9B%AE%E5%BD%95.png" alt="沙盒目录"></p><h4 id="3-理解-OC-是一门动态运行时语言"><a href="#3-理解-OC-是一门动态运行时语言" class="headerlink" title="3.理解 OC 是一门动态运行时语言"></a>3.理解 OC 是一门动态运行时语言</h4><p>OC将数据、对象类型的确定从编译阶段推迟到了运行时阶段。实现这一操作的基础是面向对象语言的 多态特性。</p><p>运行时: 运行时机制使程序在运行的时候才会去确定一个对象的类型、以及调用该类对象的指定方法。</p><p>多态: 不同的对象以自己的方式来响应相同的消息, 子类的指针可以赋值给父类。</p><h4 id="4-常见的-HTTP-状态码"><a href="#4-常见的-HTTP-状态码" class="headerlink" title="4.常见的 HTTP 状态码"></a>4.常见的 HTTP 状态码</h4><p>302: 请求重定向</p><p>500以及500以上是服务器错误, 如果 503 表示服务器找不到, 3840表示服务器返回无效的 JSON 数据。</p><p>400以及400以上是请求链接错误或者找不到服务器, 比如常见的403错误。</p><p>200以及200以上是正确的, 比如200表示请求正常。</p><h4 id="5-理解内存中的区域划分"><a href="#5-理解内存中的区域划分" class="headerlink" title="5.理解内存中的区域划分"></a>5.理解内存中的区域划分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">栈区(stack): 由系统自动分配和释放, 存放局部变量的值, 容量小速度快, 有序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">堆区: 一般由程序员去分配和释放, 如果不去释放, 则出现内存泄漏问题。程序会回收内存(容量大, 速度慢, 无序)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">静态存储区: 全局变量 (外部变量) 和 静态变量都存储在静态区域。当程序结束时, 系统回收</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">常量区: 存放常量的内存区域, 程序结束时系统回收</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">代码区: 存放程序二进制代码的区域</span></pre></td></tr></table></figure><h4 id="6-内存管理的基本原则"><a href="#6-内存管理的基本原则" class="headerlink" title="6.内存管理的基本原则"></a>6.内存管理的基本原则</h4><ul><li>iOS 5.0 之前: OC内存管理遵循”谁创建, 谁释放, 谁引用, 谁管理”的原则, 当创建或者引用一个对象时, 需要发送 alloc、copy、retain消息, 当释放一个对象时需要向该对象发送 release 消息, 当对象的引用计数为 0 时, 系统将会释放该对象, 这是 OC 的手动管理对象机制 (MRC)。</li><li>iOS 5.0 以后: 使用自动管理机制–自动引用计数(ARC), 管理机制与手动机制一样, 只是不再需要调用 retain、release、autorelease;  自动引用计数同样也是基于引用计数的机制来管理内存的, 不同点在于, MRC 需要我们自己去跟踪和管理对象, ARC通常情况下都是系统去帮助我们处理的(注:有些还是需要我们去处理)。</li></ul><p>当使用 alloc、copy(mutableCopy) 或者 retain 创建一个对象时, 必须有对应的 release 或者 autorelease 消息。向一个对象发送一条 autorelease 消息时, 对象并不会立即销毁, 而是将这个对象放入自动释放池中, 等待自动释放池释放时, 它会向池中的每一个对象发送一条 release 消息, 以此来释放对象。</p><p>向一个对象发送 release 消息时, 并不意味着对象就被销毁了, 而是当这个对象的引用计数 为 0 时, 系统才会去调用 dealloc 方法, 释放该对象 和 对象本身的实例。</p><h4 id="7-属性相关"><a href="#7-属性相关" class="headerlink" title="7.属性相关"></a>7.属性相关</h4><ol><li>原子性: atomic, nonatomic</li><li>读写: readwrite, readonly</li><li>方法名: getter=&lt;name<del>&gt;, setter=&lt;name</del>&gt;</li><li>内存: strong, retain, copy, weak, assign, unsafe_unretain</li></ol><p>atomic(默认情况): 表示原子性, 使用该属性可以保护属性的存取方法, 如果当前线程进行到一半有其它线程来访问当前资源, 可以保证必须优先进行完当前线程。原子性与对象的线程安全性是不同的, 并不能保证线程安全, 如果有多个线程同时访问一个实例变量, 其中一个调用了release的话就会造成程序的崩溃。同时, atomic 生成的互斥锁代码也会很消耗资源, 导致程序变慢。</p><p>nonatomic: 非原子属性, 与atomic相反, 系统不会去使用互斥锁保护属性的存取方法, 当多个线程同时访问一个属性时有可能出现无法预计的结果。 但是与 atomic 相比, 效率会更高。</p><p>readwrite(默认情况): 表示同时拥有 getter 和 setter 方法</p><p>readonly: 只读操作, 只有 getter 方法</p><p>注: 如果某个实例只允许外部读取, 但是在类的实现文件可以写操作的话, 可以在头文件什么为只读, 在实现文件设置为读写, 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 头文件声明</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">@property(nonatomic, readonly, copy) NSString *string;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现文件声明</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">@property(nonatomic, readwrite, copy) NSString *string;</span></pre></td></tr></table></figure><p>retain: 表示属性的保留操作, 用于获取对象的所有权, 会使对象引用计数 +1, 主要用作MRC, ARC下用 strong 替代。</p><p>assign(默认情况): 一般 int, float, double 和 NSInteger, CGFloat, BOOL 等值类型属性默认使用 assign, 用于赋值操作, 不存在所有权关系。</p><p>copy: 对对象的拷贝(分为浅拷贝 和 深拷贝), 并且属于强引用, 设置 copy 属性的任何对象都必须遵循 NSCopying 协议。</p><p>strong(默认情况): 声明为强引用, 需要注意的是 两个强引用的对象相互指向对方的时候有可能造成循环引用的问题。</p><p>weak: 声明弱引用, 与 strong相反, 当对象被释放以后, 实力变量会自动变为nil。所以, 我们通常可以使用 __weak 将强引用对象替换为弱引用, 用来解决循环引用的问题。</p><p>unsafe_unretain: 表示不安全引用, 当所引用对象被释放以后, 实例变量不会自动变为nil, 就会留下一个悬挂指针, 指向被释放的对象所占用的内存, 会导致程序崩溃。</p><h4 id="8-关于Block"><a href="#8-关于Block" class="headerlink" title="8.关于Block"></a>8.关于Block</h4><p>1.block为什么需要用 copy 修饰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">a. block 在创建的时候默认是被分配在 栈 上的, 这样的话其本身的作用域是属于栈内存的, 一旦在作用域之外去调用就回导致程序崩溃, 所以需要使用copy 将其拷贝到堆内存上面。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">b. 由于 block 创建在栈区, 而 block 的代码中可能会用到本地的一些变量, 只有将其拷贝到对手, 才能使用这些变量。</span></pre></td></tr></table></figure><p>2.block 为什么不用 retain</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">retain 只是增加了一次计数, block的内存还是在栈上面的, 并没有存在堆上, 存储的栈上的 block 可能随时被系统回收</span></pre></td></tr></table></figure><p>3.为什么进入block中的对象的引用计数需要自动加1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">block 执行的是回调, 因此 block 并不知道其中的对象创建以后会在什么时候被释放, 为了不在 block 使用该对象之前对象就已经被释放掉了, block 就会将该对象 retain 操作</span></pre></td></tr></table></figure><p>4.block 和 函数 的关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">block 的使用很像 函数指针, 不过与函数最大的不同是 block 可以访问函数外、词法作用域以内的外部变量的值。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">换句话说, block 不仅实现函数的功能, 还能携带函数的执行环镜。</span></pre></td></tr></table></figure><p>5.对于block的理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">block 实际上就是 指向结构体的指针, 编译器会将 block 的内部代码生成对于的函数</span></pre></td></tr></table></figure><p>6.对于基本数据类型, 进入到block 中会被当做常量处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果需要在 block 中对 num 进行修改, 需要加上 __block 关键字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">int num1 &#x3D; 10;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">void (^block1)() &#x3D; ^&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;num1 &#x3D; %d&quot;, num1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">num1 &#x3D; 20;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">block1();&#x2F;&#x2F; 结果为10</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 改进: 使用 block, 使进入到 block 块中的变量不被当做常量来对待</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">__block num2 &#x3D; 10;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">void (^block2)() &#x3D; ^&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;num2 &#x3D; %d&quot;, num2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">num2 &#x3D; 20;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">block2();&#x2F;&#x2F; 结果为20</span></pre></td></tr></table></figure><p>7.关于 block 中 self 的循环引用问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">block 默认是创建在栈上面的, 所以要对其进行 copy 操作拷贝到堆区使用。但是进行了 copy 操作以后, 在 block 中使用 self 的话对象就会被 retain 一次(注意: block在堆区上时才会起到retain的作用), 会造成循环引用。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">解决办法:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">在 MRC 下, 使用 __block 修饰</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">在 ARC 下, 使用 __unsafe_unretain 或者 weak 修饰</span></pre></td></tr></table></figure><h4 id="9-关于循环引用出现的三种情况"><a href="#9-关于循环引用出现的三种情况" class="headerlink" title="9.关于循环引用出现的三种情况"></a>9.关于循环引用出现的三种情况</h4><p>1.NSTimer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NStimer 对象 timer 作为一个对象A的属性, 本意在A的dealloc中释放timer, 但是 timer 没有停止就不会触发 dealloc, 然后就是相互等待, 造成循环引用。所以我们需要去显式的调用 timer 的关闭方法 [timer invaluate], 再去释放 A对象。</span></pre></td></tr></table></figure><p>2.Block</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">block 代码块没有配合 weak 使用</span></pre></td></tr></table></figure><p>3.Delegate</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">声明 delegate 时请使用 assign(MRC) 或者 weak(ARC)。</span></pre></td></tr></table></figure><p>举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSMutableArray *aArray &#x3D; [NSMutableArray array];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">NSMutableArray *bArray &#x3D; [NSMutableArray array];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[aArray addObject:bArray];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">[bArray addObject:aArray];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">检测方法:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Xcode-&gt;Product-&gt;Profile-&gt;Leaks</span></pre></td></tr></table></figure><h4 id="10-理解创建对象所需要经历的步骤-和-layoutSubView何时会被调用"><a href="#10-理解创建对象所需要经历的步骤-和-layoutSubView何时会被调用" class="headerlink" title="10.理解创建对象所需要经历的步骤 和 layoutSubView何时会被调用"></a>10.理解创建对象所需要经历的步骤 和 layoutSubView何时会被调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">创建对象:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">1.开辟内存空间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">2.初始化参数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">3.返回内存地址的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">layoutSubView的调用:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">1.初始化方法时不会调用</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">2.滚动UIScrollView时触发该方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">3.旋转屏幕时触发</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">4.改变View的值时触发, 前提是改变过frame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">5.改变View的大小时触发</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">(具体内容需要后续)</span></pre></td></tr></table></figure><h4 id="11-理解-iOS-的远程推送"><a href="#11-理解-iOS-的远程推送" class="headerlink" title="11.理解 iOS 的远程推送"></a>11.理解 iOS 的远程推送</h4><p><img src="/.com//yujialei/Documents/%E4%B8%B4%E6%97%B6%E6%88%AA%E5%9B%BE/%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81.png" alt="远程推送"></p><ol><li>应用程序安装以后会提示用户是否需要接收推送, 如果用户确认以后会向 APNS Server 注册消息推送。</li><li>注册成功以后, App 会接收到 APNS Server 所给的 推送令牌信息</li><li>App 将令牌信息发送到自己的服务器</li><li>当需要向用户推送消息时, 自己的服务器会向苹果的推送服务器(Apple Push Notification Service, 简称 APNS)发送通知</li><li>APNS 会向装有此 App 的 iPhone设备发送消息</li></ol><h4 id="12-理解-iOS-中的多线程"><a href="#12-理解-iOS-中的多线程" class="headerlink" title="12.理解 iOS 中的多线程"></a>12.理解 iOS 中的多线程</h4><p>1.概念</p><p>多线程是针对于单核的 CPU 来设计的, 目的是为了让 CPU 快速的在多个线程之间进行调度。</p><p><strong>多线程的优缺点:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">优点: 提高程序的执行效率</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">缺点: 开启线程需要一定的内存空间</span></pre></td></tr></table></figure><p><strong>同步线程 和 异步线程:</strong> 决定了可不可以开辟新的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">同步: 只在当前线程中执行任务, 不具备开辟新的线程的能力</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">异步: 可以在新的线程中执行任务, 具备开辟新的线程的能力</span></pre></td></tr></table></figure><p><strong>并行队列 和 串行队列:</strong> 决定了任务的执行方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">并行: 多个任务进行并发(同时)执行, 比如迅雷等, 可以多个任务同时进行下载</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">串行: 必须等待一个任务执行完成以后, 才能去执行下一个任务。</span></pre></td></tr></table></figure><p><strong>注意:</strong> 在 iOS应用程序中都是一个主线程, 也称为 UI线程, 主线程的主要作用就是用来更新UI, 或者去显示和刷新页面。如果将耗时的任务放在主线程去执行的话, 会出现卡顿的现象。</p><p>2.iOS 的三种多线程技术</p><p><strong>NSThread</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">直接操作线程对象, 但是需要手动管理声明周期, 经常使用这种方式去查看当前线程</span></pre></td></tr></table></figure><p><strong>GCD (Grand Central Dispatch)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">底层使用的是 C语言, 灵活方便, 可以根据系统的负荷来增减线程, 性能效率更好</span></pre></td></tr></table></figure><p><strong>NSOperation</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSOperation 是对GCD的封装, 使用起来更加好理解, 将任务封装在NSOperation, 添加到NSOperationQueue对象中。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">子类化NSOperation的设计, 更具有面向对象(封装, 复用) 的特性, 更加适合在复杂的项目中使用。</span></pre></td></tr></table></figure><p>3.进程 和 线程</p><p>进程(progress) 和 线程(thread) 是操作系统里的基本概念。</p><p>线程 和 进程的区别:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">线程是资源分配的最小单位, 也是处理器调度的基本单位, 但是进程是资源拥有的单位, 同一个进程内的线程共享进程里面的资源。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">多进程: 允许多个任务同时运行</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">多线程: 允许单个任务分为不同的部分运行</span></pre></td></tr></table></figure><h4 id="13-音频播放相关知识"><a href="#13-音频播放相关知识" class="headerlink" title="13. 音频播放相关知识"></a>13. 音频播放相关知识</h4><p>音频在播放形式上分为 音频播放 和 音乐播放。</p><p>音频播放: 通常时间较短, 不需要进度控制和循环控制, 使用 AudioToolbox.framework</p><p>音乐播放: 通常时间较长, 需要进行精准控制, 使用 AVFoundation.framework</p><p><strong>音频播放</strong></p><p>AudioToolbox.framework是基于C语言的框架</p><p>原理: 将短音频注册到系统的声音服务(System Sound Service)中, System Sound Service 是一种简单、底层的声音播放服务。</p><ol><li>音频的播放时间不能超过30秒</li><li>数据必须是 PCM 或者 IMA4 格式</li><li>音频格式必须打包成 .caf、.aif、wav中的一种 (这些都是官方的说法, 实际上一些 .MP3的格式也可以)</li></ol><p><strong>音乐播放</strong></p><ol><li>是个播放较大的音频文件</li><li>可以对音频进行精准的播放控制</li><li>使用 AVFoundation.framework 中的 AVAudioPlayer 来实现</li></ol><p>使用:</p><ol><li>初始化 AVAudioPlayer 对象, 通常是指定本地文件的路径</li><li>设置播放器属性, 例如重复次数, 音量大小等</li><li>调用 play 方法进行播放</li></ol><p>*<em>注意: *</em>AVAudioPlayer 一次只能播放一个音频文件, 所有的上一曲和下一曲都是通过创建多个 AVAudioPlayer来实现的。</p><h4 id="14-视频播放相关知识"><a href="#14-视频播放相关知识" class="headerlink" title="14. 视频播放相关知识"></a>14. 视频播放相关知识</h4><p>苹果已经给我们提供了很多种方法来实现视频的播放, 包括 MPMoviePlayerController, MPMoviePlayerController, AVPlayer, AVPlayerViewController等。但是 MPMoviePlayerController和MPMoviePlayerViewController 在 iOS9.0 以后被弃用了。<img src="/.com//yujialei/Documents/%E4%B8%B4%E6%97%B6%E6%88%AA%E5%9B%BE/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE.png" alt="视频播放"></p><h5 id><a href="#" class="headerlink" title></a></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;iOS面试知识总结-基本概念&quot;&gt;&lt;a href=&quot;#iOS面试知识总结-基本概念&quot; class=&quot;headerlink&quot; title=&quot;iOS面试知识总结_基本概念&quot;&gt;&lt;/a&gt;&lt;center&gt;iOS面试知识总结_基本概念&lt;/center&gt;&lt;/h3&gt;&lt;p&gt;&lt;stro
      
    
    </summary>
    
    
      <category term="知识点" scheme="https://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="iOS" scheme="https://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>数据持久化方案</title>
    <link href="https://yoursite.com/2017-04-05-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://yoursite.com/2017-04-05-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2017-04-04T16:00:00.000Z</published>
    <updated>2019-12-18T05:01:00.539Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据持久化方案"><a href="#数据持久化方案" class="headerlink" title="数据持久化方案"></a><center>数据持久化方案</center></h4><p>沙盒机制是 iPhone 出于安全考虑, 对于安装在手机上的应用程序的限制。所安装的应用程序只能在为该程序创建的文件系统中读取文件, 不可以去其他地方访问, 此区域就被称为沙盒, 所有的 非代码文件都要保存在此处, 例如: 图像、声音、图标、属性列表, 文本文件等, 沙盒就是一种 独立、安全、封闭的空间。</p><p>特点:</p><ol><li>每个应用程序都有自己的存储空间</li><li>每个应用程序都不可以翻过自己的围墙去随便访问别的存储空间内容。(越狱设备除外)</li><li>访问别的沙盒内数据时需要访问权限</li></ol><p>沙盒目录: documents、library(包含 caches 和 preference 目录)、tmp</p><ol><li>documents: 一般保存应用程序本身产生的文件数据, 例如: 游戏进度, 绘图软件的绘图等, iTunes 备份和恢复的时候, 会包括次目录(注意: 此目录不要保存网络上下载的文件, 否则app无法上架)</li><li>library/caches: 此目录用来保存应用程序运行时生成的需要持久化的数据, 数据一般体积比较大, 又不是很重要, 比如网络请求等。需要用户负责删除(iTunes同步设备时不会备份该目录)</li><li>librar/preference: 此目录保存应用程序的所有偏好设置, iOS的settings(设置)应用会在该目录查找应用的设备信息。iTunes同步设备时会备份该目录。(在preference目录下不能直接创建偏好设置文件, 而是应该使用 nsuserdefault 类来取得和设置应用程序的偏好)</li><li>tmp: 保存应用程序运行时所需的临时数据, 使用完毕后会将相应的文件从该目录删除。应用没有运行时, 系统也可能会清除该目录下的文件, iTunes同步设备时不会备份该目录</li></ol><h5 id="持久化方案"><a href="#持久化方案" class="headerlink" title="持久化方案"></a>持久化方案</h5><blockquote><p>plist文件 (属性列表)</p><p>preference (nsuserdefault 偏好设置)</p><p>nskeyedAchiver (归档)</p><p>Sqlite3 (fmdb)</p><p>coreData</p></blockquote><h5 id="1-plist文件"><a href="#1-plist文件" class="headerlink" title="1.plist文件"></a>1.plist文件</h5><p>将某些特定的类, 通过xml文件的方式保存在目录中, 可以被序列化的类型只包括如下几种:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSArray, NSMutableArray, NSDictionary, NSMutableDictionary, NSData, NSMutableData, NSString, NSMutableString, NSNumber, NSData</span></pre></td></tr></table></figure><p>获取文件路径:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSString *path &#x3D; NSSearchPathForDirectoriesInDomain(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">NSString *fileName &#x3D; [path stringByAppendingPthComponent:@&quot;231.plist&quot;];</span></pre></td></tr></table></figure><p>存储:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSArray *array &#x3D; @[@&quot;123&quot;, @&quot;321&quot;, @&quot;879&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[array writeToFile:fileName atomically:YES];</span></pre></td></tr></table></figure><p>读取:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSArray *result &#x3D; [NSArray arrayWithContentsOfFile: fileName]l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%@&quot;, result);</span></pre></td></tr></table></figure><p>注意:</p><p>只有以上所列出的类型才能使用plist文件存储, 存储的时候使用 writeToFile: atomically: 方法, 其中atomically 表示是否需要先写入一个辅助文件, 再把辅助文件拷贝到目标地址。这是更安全的写入文件方法, 一般为YES, 读取时使用 arrayWithContentOfFile: 方法。</p><h5 id="2-Preference-NSUserdefault-偏好设置"><a href="#2-Preference-NSUserdefault-偏好设置" class="headerlink" title="2.Preference (NSUserdefault 偏好设置)"></a>2.Preference (NSUserdefault 偏好设置)</h5><p>使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.获得NSUserdefault文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">NSUserdefault *userDefault &#x3D; [NSUserdefault standardUserDefaults];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2.向文件中写入内容</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">[userDefault setObject:@&quot;AAA&quot; forKey:@&quot;a&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">[userDefault setBool:YES forKey:@&quot;sex&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">[userDefault setInteger:21 forKey:@&quot;age&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2.1立即同步</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">[userDefault synchronize];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 3.读取文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">NSString *name &#x3D; [userDefaults objectForKey:@&quot;a&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">Bool sex &#x3D; [userDefaults boolForKey:@&quot;sex&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">NSInteger age &#x3D; [userDefaults integerForKey:@&quot;age&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%@, %ld, %ld&quot;, name, sex, age);</span></pre></td></tr></table></figure><p>注意: </p><ul><li>偏好设置是专门用来存储应用程序的配置信息的, 一般不会在偏好设置中保存其他数据</li><li>如果没有 synchronize 方法, 系统会根据 I/O 情况不定时刻地保存到文件中。所以如果需要立即写入文件的话就必须调用 synchronize 方法。</li><li>偏好设置会将所有数据保存到同一个文件, 即 preference 目录下的一个以此应用包名来命名的 plist 文件。</li></ul><h5 id="3-NSkeyedAchiver-归档"><a href="#3-NSkeyedAchiver-归档" class="headerlink" title="3.NSkeyedAchiver (归档)"></a>3.NSkeyedAchiver (归档)</h5><p>归档在 iOS中是另一种形式的序列化, 只要遵循了 NSCoding 协议的对象都可以通过它实现序列化。 由于绝大多数支持存储数据的 Foundation 和 Cocoa Touch 类都遵循了 NSCoding 协议, 因此, 对于大多数类来说, 归档相对而言还是比较容易实现的。</p><ol><li>遵循NSCoding协议</li></ol><p>NSCoding 协议实现了两个方法, 这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中, 另一个说明如何进行接档来获取一个新对象。</p><p>遵循协议和设置协议:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic) UIImage *avatar;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">@property (copy, nonatomic) NSString *name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">@property (assign, nonatomic) NSInteger age;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">@end</span></pre></td></tr></table></figure><p>实现协议方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 解档</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  if ([super init])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    self.avater &#x3D; [aDecoder decoderObjectForKey:@&quot;avater&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    self.name &#x3D; [aDecoder decoderObjectForKey:@&quot;name&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    self.age &#x3D; [aDecoder decoderObjectForKey:@&quot;age&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  return self;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 归档</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">- (void)endodeWithCoder:(NSCoder *)aCoder &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  [aCoder encodeObject:self.avater forKey:@&quot;avater&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  [aCoder encodeObject:self.name forKey:@&quot;name&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  [aCoder encodeObject:self.age forKey:@&quot;age&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>注意: 如果需要归档的类是某个自定义的子类时, 就需要在归档和解档之前先实现父类的归档和解档方法。即, [super encodeWithCoder:aCoder]和[super initWithCoder:aCoder]方法。</p><ol start="2"><li>使用</li></ol><p>需要把对象归档时调用 NSKeyedArchiver的工厂方法 archiveRootObject: toFile: 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSString *file &#x3D; [NSSearchPathForDirectoriesIndDomains(NSDocumentDictionary, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">person.avatar &#x3D; self.avatarView.image;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">person.name &#x3D; self.nameField.text;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">person.age &#x3D; self.ageField.text;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">[NSKeyedArchiver archiveRootObject:person toFile:file];</span></pre></td></tr></table></figure><p>需要从文件中解档对象就调用 NSKeyedUnarchiver 的一个工厂方法unarchiveObjectWithFile: 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSString *file &#x3D; [NSSearchPathForDirectoriesIndDomains(NSDocumentDictionary, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">if (person) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  self.avatarView.image &#x3D; person.avatar;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  self.nameField.text &#x3D; person.name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  self.ageField.text &#x3D; [NSString stringWithFormat:@&quot;%ld&quot;, person.age];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><ol start="3"><li>注意</li></ol><ul><li>必须遵循并实现 NSCoding 协议</li><li>保存文件的扩展名可以任意指定</li><li>继承时必须先调用父类的归档解档方法</li></ul><h5 id="4-SQLite3-fmdb"><a href="#4-SQLite3-fmdb" class="headerlink" title="4.SQLite3 (fmdb)"></a>4.SQLite3 (fmdb)</h5><p>前面的存储方法, 都是覆盖存储。如果想要增加一条数据就必须把整个文件读取出来, 然后修改数据后再把整个内容写入文件, 所以他们都不适合存储大量的内容。</p><ol><li>字段类型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">integer: 整数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">real: 实数 (浮点数)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">text: 文本字符串</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">blob: 二进制数据, 比如 文件, 图片之类的</span></pre></td></tr></table></figure><p>实际上 SQLite 是无类型的, 不管你在创建表时指定的字段类型是什么, 存储仍然可以存储任意类型的数据, 并且创建表时也可以不指定字段的类型。SQLite之所以什么类型就是为了良好的编程规范 和 方便开发人员的交流。</p><ol start="2"><li>准备工作</li></ol><p>导入依赖库, 在iOS中要使用SQLite3, 需要添加库文件: libsqlite3.dylib 并导入主头文件, 这是一个C语言的库, 所以直接属于SQLite3还是比较麻烦的。</p><ol start="3"><li>使用</li></ol><ul><li>创建数据库并打开(操作数据库之前必须先知道数据库文件和要操作的表, 所以使用SQLite3, 首先要打开数据库文件, 然后指定或者创建一张表)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打开数据库并创建一个表</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">- (void)openDataBase &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 1.设置文件名</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  NSString *fileName&#x3D; [NSSearchPathDirectoriesInDomain(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.db&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 2.打开数据库文件, 如果没有, 自动创建一个文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  NSInteger result &#x3D; sqlite3_open(fileName.UTF8String, &amp;_sqlite3);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  if (result &#x3D;&#x3D; SQLITE_OK) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;打开数据库成功!&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 创建一个数据库表</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    char *errmsg &#x3D; NULL;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    sqlite3_exec(_sqlite3, &quot;CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)&quot;, NULL, NULL, &amp;errmsg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    if (errmsg) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      NSLog(@&quot;错误: %s&quot;, errmsg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;else&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      NSLog(@&quot;创建成功!&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  &#125;else&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;打开数据库失败&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><ul><li>执行命令(使用sqlite3_exec() 方法可以执行任何SQL语句, 比如 创建、更新、插入和删除表操作。但是一般不用它执行查询语句, 因为它不会返回查询到的数据。)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在表中插入数据</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">- (void)insertData &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  NSString *nameStr;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  NSInteger age;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  for (NSInteger i &#x3D; 0; i &lt; 1000, i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    nameStr &#x3D; [NSString stringWithFormat:@&quot;Bourne:-%d&quot;, arc4random_uniform(1000)];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    age &#x3D; arc4random_uniform(80) + 20;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    NSString *sql &#x3D; [NSString stringWithFormat:@&quot;INSERT INTO t_person(name, age) VALUES(&#39;%@&#39;,&#39;%ld&#39;)&quot;, nameStr, age];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    char *errMsg &#x3D; NULL;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    sqlite3_exec(_sqlite3, sql.UTF8String, NULL, NULL, &amp;errMsg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    if (errMsg) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      NSLog(@&quot;错误: %s&quot;, errMsg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  NSLog(@&quot;插入完毕!&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><ul><li>查询指令(前面说过一般不使用 sqlite3_exec() 方法查询数据, 因为查询数据必须要获取查询结果, 所以查询相对比较麻烦。示例如下)</li></ul><p>Sqlite3_prepare_v2(): 检查sql的合法性。</p><p>Sqlite3_step(): 运行获取查询结果, 不断重复, 知道最后一条记录</p><p>Sqlite3_coloum_xx(): 获取对应类型的内容, iCloud对应的就是SQL语句中字段的顺序, 从0开始, 根据实际查询字段的属性, 使用  sqlite3__column_xxx 获得对应的内容即可。</p><p>Sqlite3_finalize(): 释放stmt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从表中读取数据到数组中</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">- (void)readData &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  NSMutableArray *mArray &#x3D; [NSMutableArray arrayWithCapacity:1000];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  char *sql &#x3D; &quot;select name, age from t_person;&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  sqlite3_stat *stat;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  NSInteger result &#x3D; sqlite3_prepare_v2(_sqlite3, sql, -1, &amp;stat, NULL);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  if(result &#x3D;&#x3D; SQLITE_OK) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    while (sqlite3_step(stat) &#x3D;&#x3D; SQLITE_ROW) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      char *name &#x3D; (char *)sqlite3_colum_text(stat, 0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      NSInteger age &#x3D; sqlite3_colum_int(stat, 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F; 创建对象</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      Person *person &#x3D; [Person personWithName:[NSString stringWithUTF8String:name] Age:age];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      [mArray addObject:person];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    self.dataList &#x3D; mArray;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  sqlite3_finalize(stat);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>总结</p><p>sqlite3的使用还是比较麻烦的, 因为都是些C语言函数, 理解起来有些困难。不过在一般开发过程中, 使用的都是第三方开元库FMDB, 封装了这些基本的C语言方法, 使得我们在使用时更加容易理解, 提高开发效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数据持久化方案&quot;&gt;&lt;a href=&quot;#数据持久化方案&quot; class=&quot;headerlink&quot; title=&quot;数据持久化方案&quot;&gt;&lt;/a&gt;&lt;center&gt;数据持久化方案&lt;/center&gt;&lt;/h4&gt;&lt;p&gt;沙盒机制是 iPhone 出于安全考虑, 对于安装在手机上的应用程
      
    
    </summary>
    
    
      <category term="知识点" scheme="https://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="iOS" scheme="https://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>基于原生JS与OC方法互相调用并传值</title>
    <link href="https://yoursite.com/2017-03-10-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E7%94%9FJS%E4%B8%8EOC%E6%96%B9%E6%B3%95%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8%E5%B9%B6%E4%BC%A0%E5%80%BC/"/>
    <id>https://yoursite.com/2017-03-10-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E7%94%9FJS%E4%B8%8EOC%E6%96%B9%E6%B3%95%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8%E5%B9%B6%E4%BC%A0%E5%80%BC/</id>
    <published>2017-03-09T17:23:32.000Z</published>
    <updated>2019-12-18T04:57:40.161Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目里面有有个商品活动界面，要与web端传值，将用户在网页点击的商品id 传给客户端，也就是js交互，其实再说明白一点就是方法的互相调用而已。</p><p>本文叙述下如何进行原生的JavaScript交互</p><p>包括<strong>JS调用OC方法并传值，OC调用JS方法并传值</strong></p><h2 id="HTML代码"><a href="#HTML代码" class="headerlink" title="HTML代码"></a>HTML代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;margin-top: 20px&quot;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;JS与OC交互&lt;&#x2F;h2&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;唤起本地方法(call)&quot; onclick&#x3D;&quot;tianbai.call()&quot;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;唤起getCall:(NSString *)callString传值&quot; onclick&#x3D;&quot;call()&quot;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">var call &#x3D; function()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    var callInfo &#x3D; JSON.stringify(&#123;&quot;jianshu&quot;: &quot;http:&#x2F;&#x2F;www.jianshu.com&quot;&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        tianbai.getCall(callInfo);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">var Callback &#x3D; function(str)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    alert(str);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">var alerCallback &#x3D; function()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    alert(&#39;成功&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;script&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;body&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;html&gt;</span></pre></td></tr></table></figure><p>上面html的代码：建立了两个button</p><p>第一个button绑定了 <code>tianbai.call()</code> 方法，这里 <code>tianbai</code> 是一个对象，这个对象的作用下面OC代码中会说明， <code>tianbai.call()</code> 代表 <code>tianbai</code> 对象调用 <code>call()</code> 方法</p><p>第二个button绑定了 <code>call()</code> 的方法，调用的是下面JavaScript中的 <code>call()</code> 方法，在 JavaScript 的 <code>call()</code> 里面，定义一个 <code>callInfo</code> 参数，方法中 <code>tianbai.getCall(callInfo)</code> 代表 <code>tianbai</code> 对象调用 <code>getCall</code> 方法并传参数 <code>callInfo</code> ，下面两个方法是OC调用JavaScript方法，其中Callback传回str，alerCallback为OC仅调用JavaScript方法！</p><h2 id="OC代码"><a href="#OC代码" class="headerlink" title="OC代码"></a>OC代码</h2><p>demo采用原生的JavaScriptCore类</p><p>引入三个名词：</p><ol><li>JSContext：给JavaScript提供运行的上下文环境</li><li>JSValue：JavaScript和Objective-C数据和方法的桥梁</li><li>JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议</li></ol><p>ViewController.h中的代码(代码过长，方法说明都在注释里)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;导入头文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#import &lt;JavaScriptCore&#x2F;JavaScriptCore.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">@protocol JSObjcDelegate &lt;JSExport&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;tianbai对象调用的JavaScript方法，必须声明！！！</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">- (void)call;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">- (void)getCall:(NSString *)callString;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">@end</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">@interface ViewController : UIViewController&lt;UIWebViewDelegate,JSObjcDelegate&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) JSContext *jsContext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic)  UIWebView *webView;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">@end</span></pre></td></tr></table></figure><p>ViewController.m中的代码(代码过长，方法说明都在注释里)</p><p>JavaScriptCore中web页面调用原生应用的方法可以用Delegate或Block两种方法，此文以按Delegate讲解。</p><p>设置webView</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">self.webView &#x3D; [[UIWebView alloc]initWithFrame:CGRectMake(0, 20, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    self.webView.delegate &#x3D; self;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;从本地加载html文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    NSString* path &#x3D; [[NSBundle mainBundle] pathForResource:@&quot;index&quot; ofType:@&quot;html&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    NSURL* url &#x3D; [NSURL fileURLWithPath:path];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    NSURLRequest* request &#x3D; [NSURLRequest requestWithURL:url] ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    [self.webView loadRequest:request];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    [self.view addSubview:self.webView];</span></pre></td></tr></table></figure><p>JavaScript的tianbai是一个对象，充当原生应用和web页面之间的一个桥梁。用来调用方法</p><p>webview加载完成调用代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 设置javaScriptContext上下文</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    self.jsContext &#x3D; [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;将tianbai对象指向自身</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    self.jsContext[@&quot;tianbai&quot;] &#x3D; self;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    self.jsContext.exceptionHandler &#x3D; ^(JSContext *context, JSValue *exceptionValue) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        context.exception &#x3D; exceptionValue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        NSLog(@&quot;异常信息：%@&quot;, exceptionValue);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>将对象指向自身后，如果调用 <code>tianbai.call()</code> 会响应下面的方法，OC方法中调用js中的Callback方法，并传值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (void)call&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;call&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 之后在回调js的方法Callback把内容传出去</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    JSValue *Callback &#x3D; self.jsContext[@&quot;Callback&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;传值给web端</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    [Callback callWithArguments:@[@&quot;唤起本地OC回调完成&quot;]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>将对象指向自身后，如果调用 <code>tianbai.getCall(callInfo)</code> 会响应下面的方法，OC方法中仅调用js中的alerCallback方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (void)getCall:(NSString *)callString&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    NSLog(@&quot;Get:%@&quot;, callString);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 成功回调js的方法Callback</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    JSValue *Callback &#x3D; self.jsContext[@&quot;alerCallback&quot;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    [Callback callWithArguments:nil];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>将对象指向自身后，还可以向html注入js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">- (void)alert&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 直接添加提示框</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    NSString *str &#x3D; @&quot;alert(&#39;OC添加JS提示成功&#39;)&quot;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    [self.jsContext evaluateScript:str];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目里面有有个商品活动界面，要与web端传值，将用户在网页点击的商品id 传给客户端，也就是js交互，其实再说明白一点就是方法的互相调用而已。&lt;/p&gt;
&lt;p&gt;本文叙述下如何进行原生的JavaScript交互&lt;/p&gt;
&lt;p&gt;包括&lt;strong&gt;JS调用OC方法并传值，OC
      
    
    </summary>
    
    
      <category term="知识点" scheme="https://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="iOS" scheme="https://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Git教程</title>
    <link href="https://yoursite.com/2017-01-13-GitTutorial/"/>
    <id>https://yoursite.com/2017-01-13-GitTutorial/</id>
    <published>2017-01-12T16:00:00.000Z</published>
    <updated>2019-12-03T03:21:54.209Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>　　Git是做项目的版本管理，你也可以称它们为版本管理工具。假如现在你有一个文件夹，里面可以是项目，也可以是你的个人笔记(如我这个博客)，或者是你的简历、毕业设计等等，都可以使用git来管理。</p><p>　　目前常用的版本控制器有Git和SVN，即使这两个你没有全用过，至少也会听过，我这里以Git为例，个人比较喜欢Git，你也可以看看这篇文章：<a href="http://www.worldhello.net/2012/04/12/why-git-is-better-than-svn.html" target="_blank" rel="noopener">为什么Git比SVN好</a>。我使用的是Mac，Mac上没自带Git环境，但是作为iOS开发者，我安装Xcode的时候，Xcode里是有自带Git的，所以我不需要考虑怎么去安装Git了。          </p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><strong>在Mac OS X上安装Git</strong>      </p><p>提供两种方法参考：      </p><blockquote><p>1、通过homebrew安装Git，具体方法请参考<a href="http://brew.sh/" target="_blank" rel="noopener">homebrew的文档</a><br>2、直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode。     </p></blockquote><p><strong>在Windows上安装Git</strong>      </p><blockquote><p>从<a href="https://git-for-windows.github.io" target="_blank" rel="noopener">https://git-for-windows.github.io</a> 下载，然后按默认选项安装即可，安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p></blockquote><h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><p>安装完成后，还需要最后一步设置，在命令行输入：</p><blockquote><ul><li>$ git config –global user.name “Your Name”</li><li>$ git config –global user.email “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“</li></ul></blockquote><p>“Your Name”： 是每次提交时所显示的用户名，因为Git是分布式版本控制系统，当我们push到远端时，就需要区分每个提交记录具体是谁提交的，这个”Your Name”就是最好的区分。          </p><p>“email@example.com”： 是你远端仓库的email       </p><p>–global：用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然我们也可以对某个仓库指定不同的用户名和Email地址。         </p><h3 id="开始使用-建立仓库："><a href="#开始使用-建立仓库：" class="headerlink" title="开始使用-建立仓库："></a>开始使用-建立仓库：</h3><p>你在目标文件夹下使命令：    </p><blockquote><ul><li>git init  （创建.git文件）      </li></ul></blockquote><p>就会创建一个 <code>.git</code> 隐藏文件，相当于已经建立了一个本地仓库。</p><p><strong>添加到暂存区：</strong>      </p><blockquote><ul><li>git add .   （全部添加到暂存区）    </li><li>git commit -m ‘ first commit’  （提交暂存区的记录到本地仓库）     </li></ul></blockquote><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>git branc 查看时如出现</p><blockquote><ul><li>(HEAD detached at analytics_v2)   </li><li>dev</li><li>master</li></ul></blockquote><p>代表现在已经进入一个临时的HEAD，可以使用 <code>git checkout -b temp</code> 创建一个 temp branch，这样临时HEAD上修改的东西就不会被丢掉了。<br>然后切换到 dev 分支上，在使用 git branch merge temp，就可以把 temp 分支上的代码合并到 dev 上了。</p><br><p>转载请注明：<a href="https://yujialel.github.io" target="_blank" rel="noopener">M了个C的博客</a> » <a href="https://yujialel.github.io/2016/07/GitTutorial/" target="_blank" rel="noopener">点击阅读原文</a>     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;　　Git是做项目的版本管理，你也可以称它们为版本管理工具。假如现在你有一个文件夹，里面可以是项目，也可以是你的个人笔记(如我这个博客)，或
      
    
    </summary>
    
    
      <category term="工具" scheme="https://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods使用心得</title>
    <link href="https://yoursite.com/2016-12-20-CocoaPod_Use/"/>
    <id>https://yoursite.com/2016-12-20-CocoaPod_Use/</id>
    <published>2016-12-19T16:00:00.000Z</published>
    <updated>2019-12-03T03:25:48.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>　本章介绍什么是 <code>CocoaPods</code> ,如何使用 <code>CocoaPods</code> , 以及 <code>CocoaPods</code> 的原理,和使用 <code>CocoaPods</code> 时经常出现的一些问题。</p><p>　Cocoapods 是 OS X 和 iOS 下的一个第三方库管理工具。我们能使用CocoaPods添加被称作 “Pods”的依赖库,并轻松管理它们的版本,CocoaPods会帮我们配置好这些三方库的路径及开发环境,极大的提升了开发者的工作效率。</p><h3 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods　"></a>安装CocoaPods　</h3><p>　Mac下自带ruby,使用ruby的gem命令安装,ruby的软件源被墙了,把官方的ruby源替换成国内的淘宝源。</p><h3 id="更换Gem源"><a href="#更换Gem源" class="headerlink" title="更换Gem源"></a>更换Gem源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ gem sources --remove https://rubygems.org/</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ gem sources -a https://ruby.taobao.org/</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span></pre></td></tr></table></figure><ul><li>1.移除掉原有的源（服务器在国外，速度较慢）。</li><li>2.等1有反应之后再敲2命令（替换成淘宝上的ruby镜像https）。</li><li>3.验证是否成功。成功如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">http://ruby.taobao.org/</span></pre></td></tr></table></figure><h3 id="更新Gem源"><a href="#更新Gem源" class="headerlink" title="更新Gem源"></a>更新Gem源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">sudo gem update --system</span></pre></td></tr></table></figure><h3 id="安装cocoapods"><a href="#安装cocoapods" class="headerlink" title="安装cocoapods"></a>安装cocoapods</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$ pod setup</span></pre></td></tr></table></figure><p>pod setup 在执行时会比较慢，因为Cocoapods 要将它的信息下载到 ~/.cocoapods目录下, 耐心等待…</p><h4 id="提升cocoapods的安装速度"><a href="#提升cocoapods的安装速度" class="headerlink" title="提升cocoapods的安装速度"></a>提升cocoapods的安装速度</h4><p>所有的项目的 Podspec 文件都托管在<a href="https://github.com/CocoaPods/Specs。第一次执行" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs。第一次执行</a> pod setup 时，CocoaPods 会将这些podspec索引文件更新到本地的 ~/.cocoapods/目录下，这个索引文件比较大，有 80M 左右。<br>作者akinliu 在 gitcafe 和 oschina 上建立了 CocoaPods 索引库的镜像(在国内),我们可以使用CocoaPods国内的镜像索引，操作时会快多了,如gitcafe：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">pod repo remove master</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">pod repo add master https://gitcafe.com/akuandev/Specs.git</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">pod repo update</span></pre></td></tr></table></figure><h3 id="使用cocoapods"><a href="#使用cocoapods" class="headerlink" title="使用cocoapods"></a>使用cocoapods</h3><p>cocoapods安装完成后，使用 pod search 命令来验证一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">pod search AFNetworking</span></pre></td></tr></table></figure><p>终端将会有如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-&gt; AFNetworking (3.0.4)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">A delightful iOS and OS X networking framework.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">pod <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 3.0.4'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">- Homepage: https://github.com/AFNetworking/AFNetworking</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">- Source:   https://github.com/AFNetworking/AFNetworking.git</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">- Versions: 3.0.4, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-beta.3, 3.0.0-beta.2,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">3.0.0-beta.1, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.4, 2.5.3, 2.5.2, 2.5.1, 2.5.0,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">2.4.1, 2.4.0, 2.3.1, 2.3.0, 2.2.4, 2.2.3, 2.2.2, 2.2.1, 2.2.0, 2.1.0, 2.0.3,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">2.0.2, 2.0.1, 2.0.0, 2.0.0-RC3, 2.0.0-RC2, 2.0.0-RC1, 1.3.4, 1.3.3, 1.3.2,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">1.3.1, 1.3.0, 1.2.1, 1.2.0, 1.1.0, 1.0.1, 1.0, 1.0RC3, 1.0RC2, 1.0RC1,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">0.10.1, 0.10.0, 0.9.2, 0.9.1, 0.9.0, 0.7.0, 0.5.1 [master repo]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">- Subspecs:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">- AFNetworking/Serialization (3.0.4)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">- AFNetworking/Security (3.0.4)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">- AFNetworking/Reachability (3.0.4)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">- AFNetworking/NSURLSession (3.0.4)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">- AFNetworking/UIKit (3.0.4)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">-&gt; AFNetworking+AutoRetry (0.0.5)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">Auto Retries <span class="keyword">for</span> AFNetworking requests</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">pod <span class="string">'AFNetworking+AutoRetry'</span>, <span class="string">'~&gt; 0.0.5'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">- Homepage: https://github.com/shaioz/AFNetworking-AutoRetry</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">- Source:   https://github.com/shaioz/AFNetworking-AutoRetry.git</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">- Versions: 0.0.5, 0.0.4, 0.0.3, 0.0.2, 0.0.1 [master repo]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">.........太多了，省略</span></pre></td></tr></table></figure><p>pod search 是CocoaPods的一个搜索命令,我们可以用来搜索任何托管在CocoaPods上的三方库。    </p><p>使用CocoaPods时需要新建一个 Podfile 的文件,cd 到 我的Demo项目里，Demo目录下有三个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Demo 、  Demo.xcodeproj  、 DemoTests</span></pre></td></tr></table></figure><p>新建 Podfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">touch Podfile</span></pre></td></tr></table></figure><p>vim 编辑 Podfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">vim Podfile</span></pre></td></tr></table></figure><p>由于是新建的 Podfile 里面应该是空白的。然后我们在里面添加依赖库，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">platform :ios</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">pod <span class="string">'Reachability'</span>,  <span class="string">'~&gt; 3.0.0'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">pod <span class="string">'ASIHTTPRequest'</span></span></pre></td></tr></table></figure><p>‘~&gt; 3.0.0’ 是 Reachability 的版本号, 设定了版本号CocoaPods就会下载对应的版本,ASIHTTPRequest没指定版本号,CocoaPods就会下载最新版本的ASIHTTPRequest。<br>退出编辑，执行 pod install 下载三方库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">pod install</span></pre></td></tr></table></figure><p>完成后我Demo项目下的文件多了几个:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Demo 、  Demo.xcodeproj  、 DemoTests （之前的三个）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Demo.xcworkspace 、Podfile 、Podfile.lock 、Pods</span></pre></td></tr></table></figure><p>这个时候我们打开Demo项目是点击 Demo.xcworkspace 文件了，到此CocoaPods的基本使用已经讲完了，接下来的CocoaPods的原理，和让我们自己的三方库也支持CocoaPods。</p><p>待续…</p><p><a href="http://blog.jobbole.com/53365/" target="_blank" rel="noopener">深入理解 CocoaPods</a>    </p><br><p>转载请注明：<a href="https://yujialel.github.io" target="_blank" rel="noopener">M了个C的博客</a> » <a href="https://yujialel.github.io/2016/04/CocoaPod_Use/" target="_blank" rel="noopener">点击阅读原文</a>     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h3&gt;&lt;p&gt;　本章介绍什么是 &lt;code&gt;CocoaPods&lt;/code&gt; ,如何使用 &lt;code&gt;CocoaPods&lt;/code&gt; , 以及 
      
    
    </summary>
    
    
      <category term="工具" scheme="https://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>开发常用工具</title>
    <link href="https://yoursite.com/2016-12-12-Develop_Tool/"/>
    <id>https://yoursite.com/2016-12-12-Develop_Tool/</id>
    <published>2016-12-11T16:00:00.000Z</published>
    <updated>2019-12-18T05:09:57.539Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事必先利其器，选择一些好的工具可以成吨的提高自己的工作效率。</p><h3 id="个人开发常用工具的收集"><a href="#个人开发常用工具的收集" class="headerlink" title="个人开发常用工具的收集"></a>个人开发常用工具的收集</h3><ul><li><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">cmd Markdown</a> 作业部落出版的Markdown编辑器       </li><li><a href="https://github.com/rest-client/rest-client" target="_blank" rel="noopener">RESTClient</a> 一个开源的客户端HTTP调试工具。    </li><li><a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">lantern</a> 蓝灯,一款开源的翻墙工具。    </li><li><a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">Charles</a> 青花瓷, 一款HTTP/HTTPS的抓包工具。<ul><li><a href="http://blog.devtang.com/2015/11/14/charles-introduction/" target="_blank" rel="noopener">Charles 从入门到精通</a>  </li></ul></li><li><a href="http://www.sublimetext.com" target="_blank" rel="noopener">Sublime</a> 一款强大的IDE,支持Python、JS、JSON格式化等等…更重要的是<code>Sublime</code>支持的插件很多。  <ul><li><a href="http://www.xuanfengge.com/practical-collection-of-sublime-plug-in.html" target="_blank" rel="noopener">实用的sublime插件集合</a>     </li></ul></li></ul><h3 id="文章配图网站"><a href="#文章配图网站" class="headerlink" title="文章配图网站"></a>文章配图网站</h3><p>还在为文章配图而苦恼吗？点击店面的网站吧，各种各样的图片帮你丰富你的文章。</p><p><a href="http://www.gratisography.com/" target="_blank" rel="noopener">Gratisography</a> gratisography 里面的图片每周都会更新，很多时尚流行的照片在里面，并且适合用在设计项目上。</p><p><a href="http://www.ssyer.com/home-index.html" target="_blank" rel="noopener">ssyer</a>国内的网站，不需要翻墙，速度很快，图片最全。完全免费的图片库。</p><p><a href="https://pixabay.com/" target="_blank" rel="noopener">Pixabay</a> 不同类型的高清摄影照片。</p><h3 id="UI设计网站"><a href="#UI设计网站" class="headerlink" title="UI设计网站"></a>UI设计网站</h3><p>作为一个开发者，自己写些小程序的时候经常会为没有UI而烦恼，下面就是一些UI设计网站，有新颖的UI界面设计，也有单独的UI元素，icon等。</p><p><a href="http://www.ui.cn/" target="_blank" rel="noopener">UI中国</a> 国内潮流的UI设计作品。</p><p><a href="http://www.webdesigndev.com/" target="_blank" rel="noopener">webdesigndev</a> 国外网站设计文章，各种各样的资料看到你眼花缭乱。</p><p><a href="https://dribbble.com/" target="_blank" rel="noopener">dribbble</a> 接触过设计的应该都知道，一个很好的UI设计平台。</p><p><a href="http://www.flaticon.com/" target="_blank" rel="noopener">flaticon</a> 各种icon的设计，一定有你想想要的。</p><br><p>转载请注明：<a href="https://yujialel.github.io" target="_blank" rel="noopener">M了个C的博客</a> » <a href="https://yujialel.github.io/2016/04/Develop_Tool/" target="_blank" rel="noopener">点击阅读原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工欲善其事必先利其器，选择一些好的工具可以成吨的提高自己的工作效率。&lt;/p&gt;
&lt;h3 id=&quot;个人开发常用工具的收集&quot;&gt;&lt;a href=&quot;#个人开发常用工具的收集&quot; class=&quot;headerlink&quot; title=&quot;个人开发常用工具的收集&quot;&gt;&lt;/a&gt;个人开发常用工具的收集
      
    
    </summary>
    
    
      <category term="工具" scheme="https://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Markdown工具集</title>
    <link href="https://yoursite.com/2016-11-20-MarkdownTool/"/>
    <id>https://yoursite.com/2016-11-20-MarkdownTool/</id>
    <published>2016-11-19T16:00:00.000Z</published>
    <updated>2019-12-03T03:21:54.209Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现群里面的大佬们都有自己的博客, 用来记录一下自己每隔一段时间的收获。然后自己本着向大佬看齐同时也觉得这确实是一个可以记录自己收获的好工具, 就去研究了一下。下面就是记录的一些 markdown 平时用到的一些语法, 方便自己查看吧。同时也仅此记录一下, 从此也有属于自己的博客了, 向大佬更近了一步😈。</p><h3 id="一、快捷键"><a href="#一、快捷键" class="headerlink" title="一、快捷键"></a>一、快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">加粗 Ctrl + B   </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">斜体 Ctrl + I</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">引用 Ctrl + Q</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">插入链接 Ctrl + L</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">插入代码 Ctrl + K</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">插入图片 Ctrl + G</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">提升标题 Ctrl + H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">有序列表 Ctrl + O</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">无需列表 Ctrl + U</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">横线 Ctrl + R</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">撤销 Ctrl + Z</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">重做 Ctrl + Y</span></pre></td></tr></table></figure><h3 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h3><blockquote><p>####(一) 对字体设置斜体、粗体、删除线   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">**粗体文本**</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">*斜体文本*      </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">*文字*</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">_文字_</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">~~文字~~</span></pre></td></tr></table></figure><p>效果如下:<br><strong>粗体</strong><br><em>斜体</em><br><em>斜体</em><br><del>删除线</del></p><blockquote><p>####(二) 分级标题, 两种写法 </p></blockquote><p>写法1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># 一级标题</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">## 二级标题</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">### 三级标题</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#### 四级标题 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">##### 五级标题</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">###### 六级标题  (这个写法 和 **普通文字** 的效果是一样的)</span></pre></td></tr></table></figure><p>写法2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">这是一个一级标题</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">或者</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">二级标题</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">-------------------</span></pre></td></tr></table></figure><blockquote><p>####(三) 链接</p></blockquote><p>(1) 插入本地图片链接, 语法规则, 有两种写法: </p><pre><code>![图片描述](图片路径&quot;title&quot;)![图片描述](图片路径)注意: 这个图片描述可以不写</code></pre><p>(2) 插入互联网图片, 语法规则: </p><pre><code>![图片描述](图片网络路径)注意: 这个图片描述也可以不写</code></pre><p><img src="http://pic31.nipic.com/20130731/13313355_145329022000_2.jpg" alt="网络图片"></p><p>(3) 自动链接<br>Markdown 支持以比较简短的自动形式来处理网址和电子邮件信箱, 只需要用 ‘&lt; &gt;’ 包起来, Markdown 就会自动把它转成链接, 也可以直接写, 也是可以显示成链接形式的。例如: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;https:&#x2F;&#x2F;www.baidu.com&gt;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.baidu.com</span></pre></td></tr></table></figure><blockquote><p>####(四) 分割线</p></blockquote><p>你可以再一行中用三个以上的星号(*)、减号(-)、下划线(_)来建立一个分隔线, 注意行内不能有其他东西。你也可以在星号或者减号中间插入空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">***</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">___   </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">---</span></pre></td></tr></table></figure><p>效果</p><hr><hr><hr><blockquote><p>####(五) 代码块</p></blockquote><p>对于程序员来说这个功能是必不可少的, 插入程序代码的方式有两种, 一种是利用缩进(tab), 另一种是利用英文”`”符号 (一般在ESC的下方, 和~是同一个按键) 包裹代码。</p><p>(1) 代码块: 缩进4个空格或是1个制表符。</p><pre><code>#include &lt;stdio.h&gt;int main(void){    printf(&quot;hello world\n&quot;);}</code></pre><p>(2) 行内式: 如果在一个行内需要引用代码, 只要用单反引号`引起来就好了。</p><p>这是一个示例<code>示例效果</code></p><p>(3) 多行代码块与语法高亮: 在需要高亮的代码块的前一行和后一行使用三个单反引号包裹, 就可以了(块内的 ‘&#39; 请忽略)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">\</span></pre></td></tr></table></figure><p>class Demo{<br>    public static void test () {<br>    }<br>}<br>```</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">效果</span></pre></td></tr></table></figure><p>class Demo{<br>    public static void test () {<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">(4) 代码块里面包含html代码</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">在代码块里面, &amp;、&lt; 和 &gt; 会自动转存 HTML 实体, 这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码, 只需要复制粘贴上去, 剩下的 Markdown 都会帮你处理。(注意: 简书的代码块里不支持HTML)</span></pre></td></tr></table></figure><table>    <tr>        <th rowpan="2">值班人员</th>        <th>星期一</th>        <th>星期二</th>        <th>星期三</th>    </tr>    <tr>        <td>小强</td>        <td>小明</td>        <td>小瓶</td>    </tr></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span></pre></td></tr></table></figure><tr>    <th rowpan="2">值班人员</th>    <th>星期一</th>    <th>星期二</th>    <th>星期三</th></tr><tr>    <td>小强</td>    <td>小明</td>    <td>小瓶</td></tr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;table&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&gt; ####(六) 引用</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">在被引用的文本前加上 &gt; 符号, 以及一个空格就可以了, 如果只输入一个 &gt; 符号会产生空白的引用。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">(1) 基本使用</span></pre></td></tr></table></figure>> 文字>> 文字>>> 文字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">(2) 引用的嵌套使用</span></pre></td></tr></table></figure>>>> 引用1>> 引用2> 引用3<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">(3) 引用其它要素</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">引用的区块也可以使用其他 Markdown 语法， 包括标题、列表、代码区块等。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&gt; ####(七) 列表</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">(1) 无序列表</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">使用 *, +, - 表示无序列表。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">**注意: 符号后面一定要有空格, 起到缩进的作用**</span></pre></td></tr></table></figure>- 列表文字- 列表文字- 列表文字<ul><li>列表文字</li><li>列表文字</li><li>列表文字</li></ul><ul><li>列表文字</li><li>列表文字</li><li>列表文字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">- 列表文字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">- 列表文字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">- 列表文字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">* 列表文字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">* 列表文字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">* 列表文字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">+ 列表文字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">+ 列表文字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">+ 列表文字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">(2) 有序列表</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">使用数字和一个英文句点表示有序列表。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">**注意: 英文句点后面一定要有一个空格, 起到缩进的作用。**</span></pre></td></tr></table></figure>不加空格</li></ul><p>1.有序错误<br>2.有序错误<br>3.有序错误</p><p>加空格</p><ol><li>有序示范</li><li>有序示范</li><li>有序示范<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">不加空格</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">1.有序错误</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">2.有序错误</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">3.有序错误</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">加空格</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">1. 有序示范</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">2. 有序示范</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">3. 有序示范</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">(3) 有序列表和无序列表同时使用</span></pre></td></tr></table></figure>无序</li></ol><ul><li>文字1</li><li>文字2<br>有序</li></ul><ol><li>文字1</li><li>文字2<br>混合使用</li></ol><p>*1. 文字1<br>*2. 文字2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">无序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">* 文字1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">* 文字2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  有序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">1. 文字1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">2. 文字2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   混合使用</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">   *1. 文字1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">   *2. 文字2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">(4) 列表和其他要素混合使用</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">列表不光可以单独使用, 也可以使用其他的 Markdown 语法, 包括标题、引用、代码区块等。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">**注意事项:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">(1) 加粗效果不能直接用于列表标题里面, 但是可以嵌套在列表里面混合使用</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">(2) 列表中包含代码块 (前面加2个tab或者8个空格, 并且需要空一行, 否则不显示)。**</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">(5) 注意事项</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">在使用列表时, 只要是数字后面加上英文的点, 就会无意间产生列表, 比如2017.12.20这时候想表达的是日期, 有些软件把它误认为是列表。解决方式: 在每个点前面加上 \ 就可以了。</span></pre></td></tr></table></figure><p>2017.12.20. 今天是个好天气。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&gt; ####(八) 表格</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">表格的基本写法很简单, 就跟表格形状很相似:</span></pre></td></tr></table></figure><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>95</td></tr><tr><td>小红</td><td>女</td><td>70</td></tr><tr><td>小龙</td><td>女</td><td>55</td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">| 学号   | 姓名   | 分数   |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">| ---- | ---- | ---- |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">| 小明   | 男    | 95   |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">| 小红   | 女    | 70   |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">| 小龙   | 女    | 55   |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">**表格对齐方式: 我们可以指定表格的单元格的对齐方式, 冒号在左边表示左对齐, 右边表示右对齐, 两边都有表示居中。**</span></pre></td></tr></table></figure></td><td></td><td></td></tr><tr><td>学号</td><td>姓名</td><td>分数</td></tr><tr><td>:-</td><td>:-:</td><td>-:</td></tr><tr><td>小明</td><td>男</td><td>95</td></tr><tr><td>小红</td><td>女</td><td>70</td></tr><tr><td>小龙</td><td>女</td><td>55</td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">| 学号   |  姓名  |   分数 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">| :--- | :--: | ---: |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">| 小明   |  男   |   95 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">| 小红   |  女   |   70 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">| 小龙   |  女   |   55 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">### 三、常用技巧</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&gt; ####(一) 换行</span></pre></td></tr></table></figure></td><td></td><td></td></tr><tr><td>方法1: 连续两个以上空格 + 回车</td><td></td><td></td></tr><tr><td>方法2: 使用html语言换行标签: <br></td><td></td><td></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&gt; ####(二) 缩进字符</span></pre></td></tr></table></figure></td><td></td><td></td></tr><tr><td>不断行的空格 &nbsp; 或 &#160;</td><td></td><td></td></tr><tr><td>半角空格 &ensp; 或 &#8194;</td><td></td><td></td></tr><tr><td>全角空格 &emsp; 或 &#8195;</td><td></td><td></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; ####(三) 如何打出一些特殊符号</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">* (1) 对于 Markdown 中的语法符号, 前面加反斜杠 \ 即可显示符号本身。</span></pre></td></tr></table></figure></td><td></td><td></td></tr><tr><td>\ 反斜杠</td><td></td><td></td></tr><tr><td>* 星号</td><td></td><td></td></tr><tr><td>_ 下划线</td><td></td><td></td></tr><tr><td>{}[]() 括号</td><td></td><td></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">* (2) 其他特殊字符</span></pre></td></tr></table></figure></td><td></td><td></td></tr><tr><td>&#10084;</td><td></td><td></td></tr><tr><td>&#10003;</td><td></td><td></td></tr><tr><td>&#9782;</td><td></td><td></td></tr><tr><td>&#9733;</td><td></td><td></td></tr><tr><td>&#9775;</td><td></td><td></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">字符对应的 Unicode 编码, 可以看这个网站 &lt;https:&#x2F;&#x2F;unicode-table.com&#x2F;cn&#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">**附上几个工具对特殊字符的支持的对比图:**</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">**工具或网站** | **是否特殊字符**</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">:-|:-</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">简书|是</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">MarkDownPad|否(不知道付费版是否支持)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">有道云笔记|是</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">zybuluo.com|是</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&gt; ####(四) 字体、字号与颜色</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">Markdown是一种可以使用普通文本编辑器编写的标记语言, 通过类似HTML的标记语法, 它可以使普通文本内容具有一定的格式。 但是它本身是不支持修改字体、字号与颜色等功能的!</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">CSDN-markdown 编辑器是其衍生版本, 扩展了 Markdown 的功能 (如表格、脚注、内嵌HTML等), 对, 就是内嵌HTML, 接下来要说的功能就需要内嵌HTML的方法来实现。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">字体, 字号和颜色编辑如下代码</span></pre></td></tr></table></figure></td><td></td><td></td></tr><tr><td><font face="黑体">我是黑体</font></td><td></td><td></td></tr><tr><td><font face="微软雅黑">我是微软雅黑</font></td><td></td><td></td></tr><tr><td><font face="STCAIYUN">我是华文彩云</font></td><td></td><td></td></tr></tbody></table><p>Size: 规定文本的尺寸大小。可能的值:从 1 到 7 的数字。浏览器默认是 3。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&gt; ####(五) 链接的高级操作 (这个需要掌握一下, 很有用)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">**(1) 行内式。这个在上文第二条 &#96;基本语法&#96; 的 &#96;链接&#96; 这个小结已经讲过, 这里就不继续讲解了。**</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">**(2) 参考式链接。**</span></pre></td></tr></table></figure><p>在文档要插入图片的地方写 ![图片或网址][标记], 在文档的最后写上[标记]:图片地址 “标题”。(最后这个”标题”可以不填写)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">写法:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[简书地址][1], [文章地址][3], [百度地址][2]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">标记:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">[1]:https:&#x2F;&#x2F;www.jianshu.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">[2]:https:&#x2F;&#x2F;www.baidu.com &quot;百度&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">[3]:https:&#x2F;&#x2F;www.zybuluo.com&#x2F;15606711121&#x2F;note&#x2F;1063289</span></pre></td></tr></table></figure><p><strong>(3) 内容目录</strong></p><p>在段落中填写 [TOC] 以显示全文内容的目录结构。</p><p><strong>(4) 锚点</strong></p><p>锚点其实就是页内超链接。比如我这里写下一个锚点, 就能跳转到目录。在目录中点击这个点, 就能跳回来。</p><p><strong>注意: 在简书中使用锚点时, 点击会打开一个新的页面, 虽然锚点用的不是很舒服, 但是可以用注脚实现这个功能。</strong></p><p><strong>语法说明:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">在你准备跳转到的指定标题后面插入锚点&#123;#标记&#125;,  然后再文档其它地方写上连接到锚点的链接。</span></pre></td></tr></table></figure><p>使用如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">插入锚点</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">## 标题 &#123;#index&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">链接锚点</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">跳转到[标题](#index)</span></pre></td></tr></table></figure><p><strong>(5) 注脚</strong></p><p>语法说明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">在需要添加注脚的文字后加上注脚名字[^注脚名字], 称为加注。然后在文本的任意位置(一般在文章末尾)添加注脚。</span></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">使用 Markdown[^1] 可以效率的书写文档, 并直接转换为 HTML[^2] 语言。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">[^1]:Markdown是一种纯文本标记语言    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">[^2]:HyperText Markup Language 超文本标记语言</span></pre></td></tr></table></figure><p>注:<br>(1) 脚注自动被搬运到最后面, 请到文章末尾查看, 并且脚注的链接可以直接回到加注的地方。<br>(2) 由于简书不支持锚点 , 所以可以用脚注实现页面内部跳转。</p><blockquote><p>####(六) 背景色</p></blockquote><p>Markdown本身不支持背景色设置, 需要采用内置html的方式实现: 借助 table, tr, td等表格的 bgcolor 属性来实现背景色的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;orange&gt;背景色为:orange&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;</span></pre></td></tr></table></figure><blockquote><p>####(七) emoji表情符号</p></blockquote><p>emoji表情使用:EMOJICODE:的格式, 详细列表可见<br><a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">https://www.webpagefx.com/tools/emoji-cheat-sheet/</a></p><p>现在很多 Markdown 工具或者网站都不支持。</p><p><strong>下面列出平台对比:</strong></p><table><thead><tr><th align="left"><strong>工具或网站</strong></th><th align="left"><strong>是否支持emoji表情符号</strong></th></tr></thead><tbody><tr><td align="left">简书</td><td align="left">否</td></tr><tr><td align="left">MarkDownPad</td><td align="left">否(付费版未知)</td></tr><tr><td align="left">有道云笔记</td><td align="left">否</td></tr><tr><td align="left">zybuluo.com</td><td align="left">否</td></tr><tr><td align="left">github</td><td align="left">是</td></tr></tbody></table><p>###四、高端用法</p><p>目前的简书, CSDN, 包括MarkdownPad软件都不支持下面这些功能, 有一个网站 <a href="https://www.zybuluo.com" target="_blank" rel="noopener">https://www.zybuluo.com</a> 可以支持。</p><blockquote><p>####(一) 使用LaTex数学公式</p></blockquote><ul><li><ol><li>行内公式: 使用两个 “$”  符号引用公式:</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$公式$</span></pre></td></tr></table></figure><ul><li><ol start="2"><li>行间公式: 使用两对 “$$” 符号引用公式:</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$$公式$$</span></pre></td></tr></table></figure><p>举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$\sqrt&#123;x^&#123;2&#125;&#125;$</span></pre></td></tr></table></figure><p>$\sqrt{x^{2}}$</p><p>具体参考 <a href="http://blog.csdn.net/testcs_dn/article/details/44229085" target="_blank" rel="noopener">markdown编辑器使用LaTeX数学公式</a></p><blockquote><p>####(二) 流程图</p></blockquote><p>简单介绍一下流程图语法, 仅作了解, 如下</p><p><strong>Markdown 流程图语法主要有三部分组成, 流程图语块定义、流程图符号声明和流程处理</strong></p><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">\&#96;&#96;&#96;flow    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始     &#x2F;&#x2F; 定义流程图的开始</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">op1&#x3D;&gt;operation: My Operation    &#x2F;&#x2F; 定义一个长方形的里路程图</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">c&#x3D;&gt;condition: YES or NO?    &#x2F;&#x2F; 定义一个判断</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">e&#x3D;&gt;end: 结束    &#x2F;&#x2F; 定义了流程图结束</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">st-&gt;op1-&gt;c      &#x2F;&#x2F; 从开始到长方形再到判断</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">c(yes)-&gt;e       &#x2F;&#x2F; 判断为真的时候执行分支</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">c(no)-&gt;op1      &#x2F;&#x2F; 判断为假的时候执行分支</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">\</span></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">效果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;flow</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始:&gt;www.baidu.com     </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">op1&#x3D;&gt;operation: My Operation    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">c&#x3D;&gt;condition: YES or NO?    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">e&#x3D;&gt;end: 结束    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">st-&gt;op1-&gt;c</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">c(yes)-&gt;e</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">c(no)-&gt;op1</span></pre></td></tr></table></figure><pre><code>*另外,可以在流程图符号后面加上需要跳转的链接, 例如: st=&gt;start: 开始:&gt;www.baidu.com*</code></pre><p><strong>说明: operation、subroutine 和 inputoutput 分别对应的是 长方形、子程序和四边形, 需要哪一种就写哪一个。</strong></p><p>也可以通过(right, left, top, bottom)这四个方向来调整流程图处理的时候调整流程的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">\&#96;&#96;&#96;flow    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始     &#x2F;&#x2F; 定义流程图的开始</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">op1&#x3D;&gt;operation: My Operation    &#x2F;&#x2F; 定义一个长方形的里路程图</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">c&#x3D;&gt;condition: YES or NO?    &#x2F;&#x2F; 定义一个判断</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">e&#x3D;&gt;end: 结束    &#x2F;&#x2F; 定义了流程图结束</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">st(right)-&gt;op1(right)-&gt;c      &#x2F;&#x2F; 从开始到长方形再到判断</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">c(yes,right)-&gt;e       &#x2F;&#x2F; 判断为真的时候执行分支</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">c(no,top)-&gt;op1      &#x2F;&#x2F; 判断为假的时候执行分支</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">\</span></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;flow</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始:&gt;www.baidu.com     </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">op1&#x3D;&gt;operation: My Operation    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">c&#x3D;&gt;condition: YES or NO?    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">e&#x3D;&gt;end: 结束    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">st(right)-&gt;op1(right)-&gt;c</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">c(yes,right)-&gt;e</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">c(no,top)-&gt;op1</span></pre></td></tr></table></figure><p>更多流程图语法参考: <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">流程图语法参考</a></p><blockquote><p>####(三) 制作一份待办事宜—-Todo列表 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">**使用规范:**</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">- [ ] 已处理的事情1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">- [ ] 已处理的事情2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">- [x] 未处理的事情1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">- [x] 未处理的事情22</span></pre></td></tr></table></figure><ul><li><input disabled type="checkbox"> 已处理的事情1</li><li><input disabled type="checkbox"> 已处理的事情2</li><li><input checked disabled type="checkbox"> 未处理的事情1</li><li><input checked disabled type="checkbox"> 未处理的事情22</li></ul><blockquote><p>####(四) 绘制 序列图</p></blockquote><p><strong>使用示范:</strong></p><pre><code>​```seqAlice-&gt;bob: hello bob, how are you?Note right of bob: bob thinksbob--&gt;Alice: I am good thanks!​```</code></pre><p>效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello bob, How are you?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Note left of Alice: Look Bob</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Note right of Bob: Bob thinks</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Bob--&gt;Alice: I am good, thanks!</span></pre></td></tr></table></figure><pre><code>​```sepTitle: here is a title  // 标题A-&gt;B: Normal line       // 实心箭头, 实线B--&gt;C: Dashed line      // 实心箭头, 虚线C-&gt;&gt;D: Open arrow       // 空心箭头, 实线D--&gt;&gt;A: Dashed open arrow   // 空心箭头, 虚线​```</code></pre><p>效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Title: Here is a title</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">A-&gt;B: Normal line</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">B--&gt;C: Dashed line</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">C-&gt;&gt;D: Open arrow</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">D--&gt;&gt;A: Dashed open arrow</span></pre></td></tr></table></figure><p>更多语法参考: <a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">序列图语法参考</a></p><blockquote><p>####(五) 绘制 甘特图</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">\&#96;&#96;&#96; gantt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">section 项目确定</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    需求分析    :a1, 2018-03-05, 3d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    可行性报告  :after a1, 5d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    概念验证    :5d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">section 项目实施</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    概要设计    :2018-03-13, 5d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    详细设计    :2018-03-18, 10d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    编码        :2018-03-28, 10d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    测试        :2018-04-07, 5d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">section 发布验收</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    发布: 3d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    验收: 3d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">\</span></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">效果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96; gantt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">section 项目确定</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    需求分析    :a1, 2018-03-05, 3d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    可行性报告  :after a1, 5d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    概念验证    :5d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">section 项目实施</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    概要设计    :2018-03-13, 5d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    详细设计    :2018-03-18, 10d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    编码        :2018-03-28, 10d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    测试        :2018-04-07, 5d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">section 发布验收</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    发布: 3d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    验收: 3d</span></pre></td></tr></table></figure><p>更多语法参考: <a href="https://knsv.github.io/mermaid/#gant-diagrams" target="_blank" rel="noopener">甘特图语法参考</a></p><p>[^2]: HyperText Markup Language 超文本标记语言</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近发现群里面的大佬们都有自己的博客, 用来记录一下自己每隔一段时间的收获。然后自己本着向大佬看齐同时也觉得这确实是一个可以记录自己收获的好工具, 就去研究了一下。下面就是记录的一些 markdown 平时用到的一些语法, 方便自己查看吧。同时也仅此记录一下, 从此也有属于
      
    
    </summary>
    
    
      <category term="工具" scheme="https://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="博客" scheme="https://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
